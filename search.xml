<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端知识分享-前端权限管理</title>
      <link href="/2025/04/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB-%E5%89%8D%E7%AB%AF%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2025/04/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB-%E5%89%8D%E7%AB%AF%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前端权限控制思路"><a href="#前端权限控制思路" class="headerlink" title="前端权限控制思路"></a>前端权限控制思路</h1><h2 id="界面控制"><a href="#界面控制" class="headerlink" title="界面控制"></a>界面控制</h2><p>登录请求中获取权限数据，根据权限展示对应菜单。</p><p>用户未登录时，手动敲入管理界面地址，需跳转到登录界面</p><p>用户已登录时，手动敲入非权限地址，需跳转 404 界面</p><h2 id="按钮控制"><a href="#按钮控制" class="headerlink" title="按钮控制"></a>按钮控制</h2><p>仅显示有权操作的按钮，或禁用无权操作的按钮</p><h2 id="请求与响应控制"><a href="#请求与响应控制" class="headerlink" title="请求与响应控制"></a>请求与响应控制</h2><p>对于非常规操作，如通过浏览器调试工具将某些禁用的按钮变成启用状态，此时发请求也应该被前端拦截</p><h1 id="Vue-前端实现"><a href="#Vue-前端实现" class="headerlink" title="Vue 前端实现"></a>Vue 前端实现</h1><h2 id="界面控制-1"><a href="#界面控制-1" class="headerlink" title="界面控制"></a>界面控制</h2><p>界面控制的实现方法是动态路由。用户登录后获取用户有权操作的菜单列表，前端在进行路由构建的时候将用户有权操作的路由添加到 vue-router 中，这样即便用户手动输入无权界面的地址也会因为没有在 vue-router 中添加该路由而返回 not found。</p><p>1、用户登录获取菜单列表</p><p>2、将用户菜单列表存储到 pinia 中</p><p>3、通过 pinia 中的数据构建菜单栏</p><p>注意事项：网页刷新后 pinia 的数据也会被刷新，如果构建菜单栏时使用的 pinia 的数据，会出现菜单无法构建的情况。</p><p>解决方式：通过将用户菜单权限信息存储在 sessionstroage 中或通过 pinia 持久化来解决</p><p>登录成功后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useDirectoryConfigStore</span>();</span><br><span class="line"><span class="comment">// 登录成功后的跳转</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">signInSuccess</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setSession</span>(<span class="string">&quot;token&quot;</span>, userInfo.<span class="property">username</span>);</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getDirectory</span>(); <span class="comment">//获取用户目录权限</span></span><br><span class="line">  store.<span class="property">directory</span> = res.<span class="property">data</span>;</span><br><span class="line">  <span class="title function_">initDynamicRoutes</span>(); <span class="comment">//初始化动态路由</span></span><br><span class="line">  router.<span class="title function_">push</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pinia：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useDirectoryConfigStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;directoryConfig&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">directory</span>: [] <span class="keyword">as</span> any[]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">//  持久化</span></span><br><span class="line">  <span class="attr">persist</span>: &#123; <span class="attr">paths</span>: [<span class="string">&#x27;directory&#x27;</span>] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个推荐的写法，当获取到后端出来的路由数据，我们需要给 vue-router 进行添加动态路由的操作，若服务器返回结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icon-user&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用户管理&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;users&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;add&quot;</span><span class="punctuation">,</span> <span class="string">&quot;edit&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>我们可以让 path 路径自动对应我们的 view 下的页面（仅作示范）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// route.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: staticRoutes,</span><br><span class="line">  <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">top</span>: <span class="number">0</span> &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initDynamicRoutes = ()&#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useDirectoryConfigStore</span>();</span><br><span class="line">    <span class="keyword">const</span> pageModule = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&quot;@/views/**/**/*.vue&quot;</span>);</span><br><span class="line">    store.<span class="property">directory</span>.<span class="title function_">foreach</span>(<span class="function">(<span class="params">dir</span>)=&gt;</span>&#123;</span><br><span class="line">    router.<span class="title function_">addRoute</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>+dir.<span class="property">path</span>,</span><br><span class="line">        <span class="attr">component</span>:pageModule[<span class="string">`/src/view/<span class="subst">$&#123;path&#125;</span>/index.vue`</span>],</span><br><span class="line">        <span class="attr">name</span>:dir.<span class="property">path</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：动态路由是通过点击登录按钮后添加的，如果刷新了页面这个路由就不会添加。<br>解决方式：在 App.vue 的 created 生命周期中调用 initDynamicRoutes 即可。</p><h2 id="按钮控制-1"><a href="#按钮控制-1" class="headerlink" title="按钮控制"></a>按钮控制</h2><p>按钮控制可以通过自定义指令来实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> , <span class="attr">v-permission</span>=<span class="string">&quot;&#123;action:&#x27;add&#x27;&#125;&quot;</span>&gt;</span> 添加用户 <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在加载动态路由的时候，给路由的 meta 元数据添加一个权限列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// route.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: staticRoutes,</span><br><span class="line">  <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">top</span>: <span class="number">0</span> &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initDynamicRoutes = ()&#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useDirectoryConfigStore</span>();</span><br><span class="line">    <span class="keyword">const</span> pageModule = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&quot;@/views/**/**/*.vue&quot;</span>);</span><br><span class="line">    store.<span class="property">directory</span>.<span class="title function_">foreach</span>(<span class="function">(<span class="params">dir</span>)=&gt;</span>&#123;</span><br><span class="line">    router.<span class="title function_">addRoute</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>+dir.<span class="property">path</span>,</span><br><span class="line">        <span class="attr">component</span>:pageModule[<span class="string">`/src/view/<span class="subst">$&#123;path&#125;</span>/index.vue`</span>],</span><br><span class="line">        <span class="attr">name</span>:dir.<span class="property">path</span>,</span><br><span class="line">        <span class="attr">meta</span>:&#123;</span><br><span class="line">            <span class="attr">auth</span>:dir.<span class="property">auth</span> <span class="comment">// 添加当前路由规则在用户所具有的权限</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义指令实现方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;permission&#x27;</span>.&#123;</span><br><span class="line">    <span class="title function_">inserted</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> action =binding.<span class="property">value</span>.<span class="property">action</span></span><br><span class="line">        <span class="comment">// 判断当前的路由所对应的组件中，用户是否具备action的权限</span></span><br><span class="line">        <span class="keyword">if</span>(router.<span class="property">currentRoute</span>.<span class="property">meta</span>.<span class="title function_">indexOf</span>(aciton) == -<span class="number">1</span>)&#123;</span><br><span class="line">            el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el) <span class="comment">//如果没有权限则移除这个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="请求与响应控制-1"><a href="#请求与响应控制-1" class="headerlink" title="请求与响应控制"></a>请求与响应控制</h2><p>拦截用户请求的基本思路是通过 axios 的请求拦截器来实现，在我给出的示例中，仅适用于 restful 风格的请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router frm <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> actionMapping = &#123;</span><br><span class="line">    <span class="string">&#x27;get&#x27;</span>:<span class="string">&#x27;view&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;post&#x27;</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;put&#x27;</span>:<span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;delete&#x27;</span>:<span class="string">&#x27;delete&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">axios.<span class="property">interceprots</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUrl = req.<span class="property">url</span></span><br><span class="line">    <span class="keyword">if</span>(currentUrl !== <span class="string">&#x27;login&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 不是登录的请求，应在请求头中加入token</span></span><br><span class="line">        req.<span class="property">headers</span>.<span class="property">Authorzation</span> = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> auth = router.<span class="property">currentRoute</span>.<span class="property">meta</span>.<span class="property">auth</span></span><br><span class="line">        <span class="comment">// 判断当前请求的请求方式（仅适用于restful风格）</span></span><br><span class="line">        <span class="keyword">const</span> action = actionMapping[req.<span class="property">method</span>]</span><br><span class="line">        <span class="keyword">if</span>(auth &amp;&amp; auth.<span class="title function_">indexOf</span>(action) === -<span class="number">1</span> )&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;没有权限&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;没有权限&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当服务器返回状态码为 401 代表 token 过期或被篡改，此时应强制跳转到登录界面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">meta</span>.<span class="property">status</span> === <span class="number">401</span>) &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="位掩码实现权限运算"><a href="#位掩码实现权限运算" class="headerlink" title="位掩码实现权限运算"></a>位掩码实现权限运算</h1><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>权限用二进制位表示：每个权限对应一个独立的二进制位（如 0001、0010、0100 等）<br>权限组合：通过按位或（|）运算合并权限<br>权限校验：通过按位与（&amp;）运算判断是否拥有某个权限</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1、定义权限<br>每个权限用唯一的二进制位表示，通常用<code>1&lt;&lt;n</code>生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Permission</span> = &#123;</span><br><span class="line">  <span class="attr">READ</span>: <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">  <span class="attr">WRITE</span>: <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  <span class="attr">DELETE</span>: <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="attr">ADMIN</span>: <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、分配用户权限<br>用户权限是多个权限的组合，通过按位或运算合并：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户拥有 READ 和 WRITE 权限</span></span><br><span class="line"><span class="keyword">const</span> userPermissions = <span class="title class_">Permission</span>.<span class="property">READ</span> | <span class="title class_">Permission</span>.<span class="property">WRITE</span>; <span class="comment">// 0001 | 0010 = 0011 -&gt; 3</span></span><br></pre></td></tr></table></figure><p>3、校验权限<br>用按位与（&amp;）判断用户是否拥有某个权限：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPermission</span>(<span class="params">userPerm, requiredPerm</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (userPerm &amp; requiredPerm) === requiredPerm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有 WRITE 权限</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPermission</span>(userPermissions, <span class="title class_">Permission</span>.<span class="property">WRITE</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPermission</span>(userPermissions, <span class="title class_">Permission</span>.<span class="property">DELETE</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果 userPerm &amp; requiredPerm 的结果等于 requiredPerm，说明用户拥有该权限。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>​​ 高效 ​​：二进制运算速度极快。<br>​​ 节省空间 ​​：单个数字可表示多达 32 种权限（JavaScript 中位运算使用 32 位整数）。<br>​​ 组合灵活 ​​：支持动态添加&#x2F;移除权限。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>​​ 可读性差 ​​：对不熟悉位运算的开发者不友好。<br>​​ 权限数量限制 ​​：最多支持 32 种独立权限（在 JS 中）。</p>]]></content>
      
      
      <categories>
          
          <category> 前端知识分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite-插件</title>
      <link href="/2024/09/13/Vite-%E6%8F%92%E4%BB%B6/"/>
      <url>/2024/09/13/Vite-%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>Vite会在生命周期的不同阶段调用不同的插件以达到不同的目的。</p><h1 id="vite-aliases插件"><a href="#vite-aliases插件" class="headerlink" title="vite-aliases插件"></a>vite-aliases插件</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>vite-aliases插件可以帮我们自动生成别名：帮我们检测src下的目录并生成别名，省去了自己配置alias的繁琐过程。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ViteAliases</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vite-aliases&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// resolve:&#123;</span></span><br><span class="line">    <span class="comment">//   alias:&#123;</span></span><br><span class="line">    <span class="comment">//     &quot;@&quot;:path.resolve(__dirname,&quot;./src&quot;),//用@符号表示src目录</span></span><br><span class="line">    <span class="comment">//     &quot;@assets&quot;:path.resolve(__dirname,&quot;./src/assets&quot;)</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">      <span class="title class_">ViteAliases</span>()</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Vite插件必须返回给Vite一个配置对象，我们一般封装为一个函数，有利于代码的拓展性。<br>vite-aliases插件在vite的config生命周期中执行，如果我们想自己开发一个插件就可以使用config生命周期。<br>其原理大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyPlugins/MyViteAliases.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSrcDir</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dirs = []</span><br><span class="line">    <span class="keyword">let</span> files = []</span><br><span class="line">    <span class="keyword">let</span> result = fs.<span class="title function_">readdirSync</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;../src&#x27;</span>))</span><br><span class="line">    result.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> state = fs.<span class="title function_">statSync</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;../src&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span>(state.<span class="property">isDirectory</span>)&#123;</span><br><span class="line">            dirs.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            files.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dirs,</span><br><span class="line">        files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyViteAliases</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">getSrcDir</span>()</span><br><span class="line">    <span class="keyword">let</span> opt=&#123;&#125;</span><br><span class="line">    res.<span class="property">dirs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">dir</span>=&gt;</span>&#123;</span><br><span class="line">        opt[<span class="string">`@<span class="subst">$&#123;dir&#125;</span>`</span>]=path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;../src&#x27;</span>+<span class="string">&#x27;/&#x27;</span>,dir).<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">//该函数允许返回部分的viteconfig的配置内容</span></span><br><span class="line">        <span class="comment">//其原理相当于使用了Object.assign()对对象进行了合并</span></span><br><span class="line">        <span class="attr">config</span>:<span class="keyword">function</span>(<span class="params">config,env</span>)&#123;</span><br><span class="line">            <span class="comment">//config：当前的配置</span></span><br><span class="line">            <span class="comment">//env：当前的运行环境</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">resolve</span>:&#123;</span><br><span class="line">                    <span class="attr">alias</span>:opt</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vite-plugin-mock插件"><a href="#vite-plugin-mock插件" class="headerlink" title="vite-plugin-mock插件"></a>vite-plugin-mock插件</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>vite-plugin-mock插件使用了mock.js，用于帮我们创建数据模拟后端返回内容。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>Vite插件必须返回给Vite一个配置对象，我们一般封装为一个函数，有利于代码的拓展性。<br>vite-plugin-mock插件在Vite的configureServer生命周期中执行，在生命周期钩子中可以拿到vite-server服务器相关的配置。<br>我们可以使用服务器配置的中间件上对请求和响应数据进行处理。<br>其原理大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">configureServer</span>(<span class="params">server</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> mockRes = &#123;&#125;;</span><br><span class="line">      <span class="keyword">let</span> fileStat = fs.<span class="title function_">statSync</span>(path.<span class="title function_">resolve</span>(<span class="string">&quot;./mock&quot;</span>));</span><br><span class="line">      <span class="keyword">if</span> (fileStat.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">        mockRes = <span class="built_in">require</span>(path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&quot;mock/index.js&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      server.<span class="property">middlewares</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> mockItem = mockRes.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">url</span> === req.<span class="property">url</span>);</span><br><span class="line">        <span class="keyword">if</span> (mockItem) &#123;</span><br><span class="line">          <span class="keyword">let</span> responseData = mockItem.<span class="title function_">response</span>(req);</span><br><span class="line">          res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">          res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(responseData)); <span class="comment">//这个操作是异步的，所以next()要写在else里面</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="title function_">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vite-plugin-checker插件"><a href="#vite-plugin-checker插件" class="headerlink" title="vite-plugin-checker插件"></a>vite-plugin-checker插件</h1><h2 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h2><p>Vite天生支持typescript，但是vite只会编译ts文件但是不会进行类型检查，我们可以配合vite-plugin-checker对项目中的typescript语法进行约束。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>1、安装vite-plugin-checker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vite-plugin-checker</span><br></pre></td></tr></table></figure><p>2、在vite.config.js中启用这个插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> checker <span class="keyword">from</span> <span class="string">&quot;vite-plugin-checker&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">      <span class="title function_">checker</span>(&#123;</span><br><span class="line">        <span class="attr">typescript</span>:<span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，这个时候运行会报错，因为没有创建tsconfig.json文件或文件中无内容。<br>3、创建tsconfig.json文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;skipLibCheck&quot;: true // 跳过依赖包的检查</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [&quot;**/*&quot;],</span><br><span class="line">    &quot;exclude&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;axios&quot;: &quot;^1.7.7&quot;,</span><br><span class="line">    &quot;less&quot;: &quot;^4.2.0&quot;,</span><br><span class="line">    &quot;typescript&quot;: &quot;^5.7.2&quot;,</span><br><span class="line">    &quot;vite&quot;: &quot;^5.4.3&quot;,</span><br><span class="line">    &quot;vite-plugin-checker&quot;: &quot;^0.8.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;tsc --noEmit &amp;&amp; vite&quot;, //这个操作表示如果tsc --noEmit执行不成功就跳过vite命令</span><br><span class="line">    &quot;build&quot;: &quot;vite build&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite-静态资源与别名配置</title>
      <link href="/2024/09/11/Vite-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%8E%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/09/11/Vite-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%8E%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><p>vite对大多数静态资源都是开箱即用的</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>导入图片可以直接获取图片路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imageUrl <span class="keyword">from</span> <span class="string">&quot;./src/assets/images/1.webp&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(imageUrl) <span class="comment">//为图片路径</span></span><br></pre></td></tr></table></figure><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>导入json可以直接得到反序列化后的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> adminConfig <span class="keyword">from</span> <span class="string">&quot;./src/assets/jsons/adminConfig.json&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(adminConfig)<span class="comment">//得到一个反序列化的对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(adminConfig.<span class="property">delete</span>) </span><br></pre></td></tr></table></figure><p>这种写法在生产环境性能差并且非常臃肿，因为导入了一个对象中的全部内容，不利于摇树优化。<br>在生产环境应尽量控制导入的数量，可以使用以下写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&quot;./src/assets/jsons/adminConfig.json&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(add)</span><br></pre></td></tr></table></figure><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><p>svg源码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 500&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M117.1 256.1c-25.8 3.7-84 13.7-100.9 30.6-21.9 21.9-21.5 57.9.9 80.3s58.3 22.8 80.3.9C114.3 351 124.3292.8 128 267c.8-6.4-4.6-11.8-10.9-10.9zm506.7 30.6c-16.9-16.9-75.1-26.9-100.9-30.6-6.3-.9-11.7 4.5-10.8 10.8 3.725.8 13.7 84 30.6 100.9 21.9 21.9 57.9 21.5 80.3-.9 22.3-22.3 22.7-58.3.8-80.2zm-126.6 61.7C463.8 412.3 396.9 456320 456c-76.9 0-143.8-43.7-177.2-107.6-12.5 37.4-25.2 43.9-28.3 46.5C159.1 460.7 234.5 504 320 504s160.9-43.3 2055-109.1c-3.2-2.7-15.9-9.2-28.3-46.5zM122.7 224.5C137.9 129.2 220.5 56 320 56c99.5 0 182.1 73.2 197.3 168.5 2.1-.25.2-2.4 49.5 7C554.4 106 448.7 8 320 8S85.6 106 73.2 231.4c44.5-9.4 47.1-7.2 49.5-6.9zM320 400c51.9 0 115.3-32.9123.3-80 1.7-9.9-7.7-18.5-17.7-15.3-25.9 8.3-64.4 13.1-105.6 13.1s-79.6-4.8-105.6-13.1c-9.8-3.1-19.4 5.3-17.7 153 8 47.1 71.4 80 123.3 80zm130.3-168.3c3.6-1.1 6-4.5 5.7-8.3-3.3-42.1-32.2-71.4-56-71.4s-52.7 29.3-56 71.4c-.3 37 2.1 7.2 5.7 8.3 3.5 1.1 7.4-.5 9.3-3.7l9.5-17c7.7-13.7 19.2-21.6 31.5-21.6s23.8 7.9 31.5 21.6l9.5 17c2.1 3.6 62 4.6 9.3 3.7zM240 189.4c12.3 0 23.8 7.9 31.5 21.6l9.5 17c2.1 3.7 6.2 4.7 9.3 3.7 3.6-1.1 6-4.5 5.7-8.3-3.3-421-32.2-71.4-56-71.4s-52.7 29.3-56 71.4c-.3 3.7 2.1 7.2 5.7 8.3 3.5 1.1 7.4-.5 9.3-3.7l9.5-17c7.7-13.8 19.2-21.631.5-21.6z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以将svg的源代码直接导入并写在页面某个元素的innerHtml上，想要修改svg图片的颜色可以采用以下写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> svgUrl <span class="keyword">from</span> <span class="string">&quot;@assets/svgs/laugh.svg?url&quot;</span><span class="comment">//得到一个指向svg图片的地址</span></span><br><span class="line"><span class="keyword">import</span> svgRaw <span class="keyword">from</span> <span class="string">&quot;@assets/svgs/laugh.svg?raw&quot;</span><span class="comment">//得到svg图片的源代码</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>=svgRaw</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(svgUrl)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(svgRaw)</span><br><span class="line"><span class="keyword">let</span> svgImg = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;svg&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">svgImg.<span class="property">onmouseenter</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">fill</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h1><p>有没有觉得导入一个文件特别的费劲，vite提供了简化导入路径的方法，只需要做一点配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vite.config.js中添加以下配置</span></span><br><span class="line"><span class="attr">resolve</span>:&#123;</span><br><span class="line">  <span class="attr">alias</span>:&#123;</span><br><span class="line">    <span class="string">&quot;@&quot;</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./src&quot;</span>),<span class="comment">//用@符号表示src目录</span></span><br><span class="line">    <span class="string">&quot;@assets&quot;</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&quot;./src/assets&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要用到的地方这样写就行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imageUrl <span class="keyword">from</span> <span class="string">&quot;@assets/images/1.webp&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(imageUrl)</span><br></pre></td></tr></table></figure><h1 id="静态资源打包"><a href="#静态资源打包" class="headerlink" title="静态资源打包"></a>静态资源打包</h1><h2 id="文件名变了"><a href="#文件名变了" class="headerlink" title="文件名变了"></a>文件名变了</h2><p>vite打包后默认生成一个名为dist的文件夹，里面包含了index.html和assets文件夹，assets文件夹内有许多我们使用到的静态文件（js、css、图片等），不难发现打包后文件的文件名添加了哈希值，这是为了解决浏览器缓存的问题（当访问了名字一样的静态文件，浏览器就会走缓存，每次打包使用不同的hash值就可以解决浏览器缓存的问题）。</p><h2 id="构建时配置策略"><a href="#构建时配置策略" class="headerlink" title="构建时配置策略"></a>构建时配置策略</h2><p>vite.config.js中添加以下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build</span>:&#123;</span><br><span class="line">  <span class="comment">//vite在打包时使用了rollup，所以通过配置rollup就可以更改构建时配置</span></span><br><span class="line">  <span class="attr">rollupOptions</span>:&#123;</span><br><span class="line">    <span class="comment">//控制输出</span></span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">      <span class="comment">//配置静态文件的命名格式</span></span><br><span class="line">      <span class="attr">assetFileNames</span>:<span class="string">&quot;[hash].[name].[ext]&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//有些图片非常小，生成单独的文件会浪费体积，当图片大小小于该值时会把图片变成base64字符</span></span><br><span class="line">  <span class="attr">assetsInlineLimit</span>:<span class="number">4096</span>,</span><br><span class="line">  <span class="comment">//打包后文件夹的名字</span></span><br><span class="line">  <span class="attr">outDir</span>:<span class="string">&quot;testDist&quot;</span>,</span><br><span class="line">  <span class="comment">//打包后静态文件文件夹的名字</span></span><br><span class="line">  <span class="attr">assetsDir</span>:<span class="string">&quot;testAssets&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> 静态资源 </tag>
            
            <tag> 别名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite-对CSS的支持</title>
      <link href="/2024/09/05/Vite-%E5%AF%B9CSS%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2024/09/05/Vite-%E5%AF%B9CSS%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Vite处理CSS"><a href="#Vite处理CSS" class="headerlink" title="Vite处理CSS"></a>Vite处理CSS</h1><h2 id="处理简单css"><a href="#处理简单css" class="headerlink" title="处理简单css"></a>处理简单css</h2><p>当我们写出以下代码并通过vite启动：<br>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>秋华软创<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span></span><br></pre></td></tr></table></figure><p>index.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: large;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vite会做以下内容：<br>读取到main.js中引入了index.css<br>通过fs读取index.css中的内容<br>创建style标签包裹css文件中的内容<br>将style标签插入html的head中<br>将css中的文件替换为js脚本（方便热更新或css模块化），同时设置Content-Type为js（和读取vue文件同理），让浏览器以脚本方式执行css后缀的文件</p><h2 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h2><p>1、当有多个css文件定义了相同的类名就会造成类名冲突，可以通过以下方式处理冲突：<br>（1）将css文件命名为”xxx.module.css”<br>（2）main.js中写成以下形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&quot;./index.module.css&quot;</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.name&quot;</span>)</span><br><span class="line">div.<span class="property">className</span>=index.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>index为一个对象，该对象属性的属性名为原始类名，属性值为原始类名+哈希值<br>我们可以将对应元素的类名设置成对应属性就可以避免类名冲突<br>2、CSS模块化原理如下：<br>（1）module.css是一种约定，说明要开启模块化<br>（2）会将所有类名进行替换，变成类名+哈希值的样子<br>（3）同时创建一个映射对象如：{“xxx”:”<em>xxx_as51we2</em>“}<br>（4）将替换后的内容塞入style标签再插入html的head中<br>（5）将xxx.module.css变成js脚本<br>（6）将创建的映射对象在脚本中进行默认导出</p><h1 id="Vite处理Less"><a href="#Vite处理Less" class="headerlink" title="Vite处理Less"></a>Vite处理Less</h1><p>首先下载Less，编写less文件如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.module.less</span></span><br><span class="line"><span class="selector-class">.out</span>&#123;</span><br><span class="line">    <span class="selector-class">.in</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">        <span class="attribute">font-size</span>: large;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改main.js文件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&quot;./index.module.less&quot;</span></span><br><span class="line"><span class="keyword">let</span> outDiv = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.out&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> inDiv = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.out .in&quot;</span>)</span><br><span class="line">outDiv.<span class="property">className</span>=index.<span class="property">out</span></span><br><span class="line">inDiv.<span class="property">className</span>=index.<span class="property">in</span></span><br></pre></td></tr></table></figure><h1 id="Vite关于CSS的配置"><a href="#Vite关于CSS的配置" class="headerlink" title="Vite关于CSS的配置"></a>Vite关于CSS的配置</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig&#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">envPrefix</span>:<span class="string">&quot;QIUHUA_&quot;</span>,</span><br><span class="line">    <span class="attr">css</span>:&#123;<span class="comment">//对css进行配置</span></span><br><span class="line">      <span class="comment">//modules配置最终会对给postcss modules进行处理</span></span><br><span class="line">      <span class="attr">modules</span>:&#123;</span><br><span class="line">        <span class="attr">localsConvention</span>:<span class="string">&quot;camelCaseOnly&quot;</span>,<span class="comment">//修改生成对象的key的展示形式为（驼峰或中划线）</span></span><br><span class="line">        <span class="attr">scopeBehaviour</span>:<span class="string">&quot;local&quot;</span>,<span class="comment">//local则开启模块化，global则为取消模块化</span></span><br><span class="line">        <span class="attr">generateScopedName</span>:<span class="string">&quot;[name]_[local]_[hash:5]&quot;</span>,<span class="comment">//配置生成类名的格式，还可以使用函数进行配置</span></span><br><span class="line">        <span class="attr">hashPrefix</span>:<span class="string">&quot;hello&quot;</span>,<span class="comment">//根据该值生成独特的hash值</span></span><br><span class="line">        <span class="attr">globalModulePaths</span>:[<span class="string">&quot;./index.module.css&quot;</span>]<span class="comment">//不想进行模块化的css文件</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">preprocessorOptions</span>:&#123;<span class="comment">//key+config表示预处理器的名字</span></span><br><span class="line">        <span class="attr">less</span>:&#123;<span class="comment">//整个配置对象最终会给到less的执行参数（全局参数）中去</span></span><br><span class="line">          <span class="attr">match</span>:<span class="string">&quot;always&quot;</span>,<span class="comment">//总是处理数学运算，不论它是否被包裹在括号中</span></span><br><span class="line">          <span class="attr">globalVars</span>:&#123;<span class="comment">//less全局变量</span></span><br><span class="line">            <span class="attr">mainColor</span>:<span class="string">&quot;red&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">devSourcemap</span>:<span class="literal">true</span><span class="comment">//开启css的sourceMap（文件索引）</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite-环境变量</title>
      <link href="/2024/09/04/Vite-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2024/09/04/Vite-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="更好的配置Vite"><a href="#更好的配置Vite" class="headerlink" title="更好的配置Vite"></a>更好的配置Vite</h1><p>vite.config.js文件是在node环境下运行的，vite会将es模块化语法替换为commonjs模块化语法，所以我们可以使用import xxx from xxx的方式来写。<br>创建vite.config.js文件，文件内部写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, optimizeDeps &#125; <span class="keyword">from</span><span class="string">&quot;vite&quot;</span>;</span><br><span class="line">exportdefault <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>)</span><br><span class="line">  <span class="comment">//command:&quot;build/serve&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (command == <span class="string">&quot;build&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//生产环境的配置</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">optimizeDeps</span>: [], <span class="comment">//写在数组里面的依赖不进行依赖预处理</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//开发环境的配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>vite使用dotenv来配置环境变量，dotenv会读取.env文件，并将.env文件中的配置注入process对象身上，但是vite考虑到一些冲突，所以不会直接把环境变量放到process上。如：root和envDir，vite可以通过envDir来配置环境变量的文件地址，故在defineConfig的函数变量内部读取process.env是没有意义的。不过可以通过loadEnv函数来解决这个问题。<br>loadEnv做了以下内容：<br>直接读取.env文件的配置内容将其放到一个对象中<br>会将传进来的mode值进行拼接：”.env.development”。并根据我们配置的路径找到对应的配置文件并将.env和.env.xxx的配置内容进行拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, loadEnv, optimizeDeps &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//command:&quot;build/serve&quot;</span></span><br><span class="line">  <span class="keyword">let</span> env = <span class="title function_">loadEnv</span>(mode, process.<span class="title function_">cwd</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(env);</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="string">&quot;build&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">//生产环境的配置</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">optimizeDeps</span>: [], <span class="comment">//写在数组里面的依赖不进行依赖预处理</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//开发环境的配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>.env：默认情况下读取的环境变量，开发和生产等环境均可使用<br>.env.development：开发环境用到的环境变量<br>.env.production：生产环境用到的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">相当于：</span><br><span class="line">npm run dev --mode development</span><br></pre></td></tr></table></figure><p>客户端：vite会将环境变量注入到import.meta.env中<br>node环境：通过loadEnv函数返回值读取<br>注意：如果客户端想使用环境变量，环境变量的名字必须使用VITE开头，若想修改前缀可以在vite.config.js中使用envPrefix配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">envPrefix</span>:<span class="string">&quot;QIUHUA_&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite-Vite做了什么事</title>
      <link href="/2024/09/04/Vite-Vite%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B/"/>
      <url>/2024/09/04/Vite-Vite%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="构建工具是什么"><a href="#构建工具是什么" class="headerlink" title="构建工具是什么"></a>构建工具是什么</h1><p>1、企业开发中可能涉及以下内容：<br>TypeScript：tsc<br>Vue&#x2F;React：vue-complier、react-complier<br>Less&#x2F;Sass：less-loader、sass-loader<br>语法降级：babel<br>体积压缩：uglifyjs<br>浏览器只认识css、js、html，每次修改代码都需要通过以上工具将所有代码重新编译一遍，非常麻烦，Vite帮我们解决了这个问题。<br>2、直接支持从node_modles中引包，解决CommonJs模块化和ES6模块化不兼容的问题。<br>3、热更新<br>4、自带开发服务器，解决跨域问题。</p><h1 id="Vite对比WebPack"><a href="#Vite对比WebPack" class="headerlink" title="Vite对比WebPack"></a>Vite对比WebPack</h1><p>WebPack：分析出文件的所有导入与导出，将CommonJs模块化和ES6模块化通过webpack_require函数变成统一的模块化代码，并包裹成立即执行函数。这意味着它将所有的文件都读了一遍，项目启动速度会非常慢，但是可以兼容浏览器端和服务器端。<br>Vite：基于ES6模块化不支持CommmonJs模块化（新版本好像支持了），所以不需要把所有文件都读一遍，启动速度非常快。</p><h1 id="Vite脚手架和Vite的区别"><a href="#Vite脚手架和Vite的区别" class="headerlink" title="Vite脚手架和Vite的区别"></a>Vite脚手架和Vite的区别</h1><p>当执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create vite</span><br></pre></td></tr></table></figure><p>帮我们全局安装create-vite<br>直接运行bin目录下的执行配置<br>关系：create-vite内置了vite，就像vue-cli内置了webpack一样，create-vite配置模板并设置最佳实践的配置。</p><h1 id="Vite预加载"><a href="#Vite预加载" class="headerlink" title="Vite预加载"></a>Vite预加载</h1><p>问题1：当我们打开一个网页，浏览器会通过查询有多少个es6引入与导出来确定发出多少请求来获取.js文件（commonjs没这个要求，因为commonjs是工作在node环境下的），当引入和导出的文件数很多时，浏览器就会发出多个网络请求，这很离谱。<br>问题2：npm安装的包会通过层层向上的方式进行查找，在开发环境中当然没问题，但是生产环境中必须使用相对路径或绝对路径，这种机制就不太好用了。<br>问题3：不同第三方包的导入和导出形式不同，有些是commonjs模块化有些是es模块化。<br>Vite做了一些处理：<br>Vite会找到对应依赖，然后调用esbuild将其他规范代码转为es规范代码，然后放到当前目录下&#x2F;node_modules中，解决了不同的第三方包的导出格式不同的问题，由于将所有的包都打包到node_modules中方便路径补全与重写。<br>Vite将导入和导出的代码集成到一个或几个文件中，解决了网络多包传输的性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Modbus通信</title>
      <link href="/2024/08/04/Python-Modbus%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/08/04/Python-Modbus%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="PyModbus库"><a href="#PyModbus库" class="headerlink" title="PyModbus库"></a>PyModbus库</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>PyModbus广泛用于基于Python语言进行Modbus通信，该库支持使用异步和同步两种方式进行调用且函数使用方式没有任何区别。<br>PyModbus支持ModbusRTU、ModbusTCP、ModbusTLS、ModbusUDP四种连接方式，本文主要介绍RTU与TCP的通信方式。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>ModbusTCP通信方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymodbus.client <span class="keyword">import</span> ModbusTcpClient</span><br><span class="line"></span><br><span class="line">client = ModbusTcpClient(<span class="string">&#x27;MyDevice.lan&#x27;</span>)   <span class="comment"># Create client object</span></span><br><span class="line">client.connect()                           <span class="comment"># connect to device, reconnect automatically</span></span><br><span class="line">client.write_coil(<span class="number">1</span>, <span class="literal">True</span>, slave=<span class="number">1</span>)        <span class="comment"># set information in device</span></span><br><span class="line">result = client.read_coils(<span class="number">2</span>, <span class="number">3</span>, slave=<span class="number">1</span>)  <span class="comment"># get information from device</span></span><br><span class="line"><span class="built_in">print</span>(result.bits[<span class="number">0</span>])                      <span class="comment"># use information</span></span><br><span class="line">client.close()                             <span class="comment"># Disconnect device</span></span><br></pre></td></tr></table></figure><p>简单函数调用不论是读、写还是诊断调用的返回结果都是统一的，常用诊断方式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    res = <span class="keyword">await</span> client.read_coils(<span class="number">1</span>, <span class="number">1</span>, slave=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ModbusException <span class="keyword">as</span> exc:</span><br><span class="line">    _logger.error(<span class="string">f&quot;ERROR: exception in pymodbus <span class="subst">&#123;exc&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span> exc</span><br><span class="line"><span class="keyword">if</span> res.isError():</span><br><span class="line">    _logger.error(<span class="string">&quot;ERROR: pymodbus returned an error!&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span> ModbusException(txt)</span><br></pre></td></tr></table></figure><p>在读取状态下res.bits为线圈或输入寄存器的值，res.registers为其他的值。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-事务</title>
      <link href="/2024/05/28/SQLite3-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/05/28/SQLite3-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 Transaction"></a>事务 Transaction</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务是一个对数据库执行工作单元。事务是以逻辑顺序完成的工作单位或序列，可以是由用户手动操作完成，也可以是由某种数据库程序自动完成。</p><p>事务是指一个或多个更改数据库的扩展。例如，如果您正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么您正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。</p><p>实际上，您可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行</p><h2 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h2><p>事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID：</p><p>原子性（Atomicity）：确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。</p><p>一致性（Consistency）：确保数据库在成功提交的事务上正确地改变状态。</p><p>隔离性（Isolation）：使事务操作相互独立和透明。</p><p>持久性（Durability）：确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。</p><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>使用下面的命令来控制事务：</p><p>BEGIN TRANSACTION：开始事务处理。</p><p>COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。</p><p>ROLLBACK：回滚所做的更改。</p><p>事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一个回滚的事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>一个提交的事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> 事务 </tag>
            
            <tag> Transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-视图</title>
      <link href="/2024/05/28/SQLite3-%E8%A7%86%E5%9B%BE/"/>
      <url>/2024/05/28/SQLite3-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>视图只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图（View）实际上是一个以预定义的 SQLite 查询形式存在的表的组合。</p><p>视图可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQLite 查询。、</p><p>视图是一种虚表，允许用户实现以下几点：</p><p>用户或用户组查找结构数据的方式更自然或直观。</p><p>限制数据访问，用户只能看到有限的数据，而不是完整的表。</p><p>汇总各种表中的数据，用于生成报告。</p><p>SQLite 视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。但是可以在视图上创建一个触发器，当尝试 DELETE、INSERT 或 UPDATE 视图时触发，需要做的动作在触发器内容中定义。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>SQLite 的视图是使用 CREATE VIEW 语句创建的。SQLite 视图可以从一个单一的表、多个表或其他视图创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMP <span class="operator">|</span> TEMPORARY] <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2.....</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> COMPANY_VIEW <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ID, NAME, AGE</span><br><span class="line"><span class="keyword">FROM</span>  COMPANY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY_VIEW;</span><br></pre></td></tr></table></figure><h1 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h1><p>使用DROP VIEW</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> 视图 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-索引</title>
      <link href="/2024/05/28/SQLite3-%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/05/28/SQLite3-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>索引（Index）是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。一个数据库中的索引与一本书的索引目录是非常相似的。</p><p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p><p>索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。索引可以创建或删除，但不会影响数据。</p><p>使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。</p><p>索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>单列索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name </span><br><span class="line"><span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure><p>唯一索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column_name);</span><br></pre></td></tr></table></figure><p>联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure><p>隐式索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">隐式索引是在创建对象时，由数据库服务器自动创建的索引。索引自动创建为主键约束和唯一约束。</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX salary_index <span class="keyword">ON</span> COMPANY (salary);</span><br></pre></td></tr></table></figure><h1 id="列出索引"><a href="#列出索引" class="headerlink" title="列出索引"></a>列出索引</h1><p>1、可以使用 .indices 或 .indexes 命令列出 COMPANY 表上所有可用的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.indices COMPANY</span><br></pre></td></tr></table></figure><p>这将产生如下结果，其中 sqlite_autoindex_COMPANY_1 是创建表时创建的隐式索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salary_index</span><br><span class="line">sqlite_autoindex_COMPANY_1</span><br></pre></td></tr></table></figure><p>2、查询数据库范围的所有索引<br>可以查询sqlite_master表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sqlite_master <span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;index&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h1><p>一个索引可以使用 SQLite 的 DROP 命令删除。当删除索引时应特别注意，因为性能可能会下降或提高：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><h1 id="何时应避免使用索引"><a href="#何时应避免使用索引" class="headerlink" title="何时应避免使用索引"></a>何时应避免使用索引</h1><p>虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：</p><p>索引不应该使用在较小的表上。</p><p>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</p><p>索引不应该使用在含有大量的 NULL 值的列上。</p><p>索引不应该使用在频繁操作的列上。</p><h1 id="INDEX-BY"><a href="#INDEX-BY" class="headerlink" title="INDEX BY"></a>INDEX BY</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>“INDEXED BY index-name” 子句规定必须需要命名的索引来查找前面表中值。</p><p>如果索引名 index-name 不存在或不能用于查询，然后 SQLite 语句的准备失败。</p><p>“NOT INDEXED” 子句规定当访问前面的表（包括由 UNIQUE 和 PRIMARY KEY 约束创建的隐式索引）时，没有使用索引。</p><p>然而，即使指定了 “NOT INDEXED”，INTEGER PRIMARY KEY 仍然可以被用于查找条目。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> column1, column2...</span><br><span class="line">INDEXED <span class="keyword">BY</span> (index_name)</span><br><span class="line">table_name</span><br><span class="line"><span class="keyword">WHERE</span> (<span class="keyword">CONDITION</span>);</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY INDEXED <span class="keyword">BY</span> salary_index <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> 索引 </tag>
            
            <tag> Index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-触发器</title>
      <link href="/2024/05/23/SQLite3-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2024/05/23/SQLite3-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="触发器-Trigger"><a href="#触发器-Trigger" class="headerlink" title="触发器 Trigger"></a>触发器 Trigger</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行&#x2F;调用。以下是关于 SQLite 的触发器的要点：<br>SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。<br>SQLite 只支持 FOR EACH ROW（行级触发器）触发器，没有 FOR EACH STATEMENT（语句级触发器）触发器。因此，明确指定 FOR EACH ROW 是可选的。<br>WHEN 子句和触发器动作可能访问使用表单 NEW.column-name 和 OLD.column-name 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。<br>如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。<br>BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。<br>当触发器相关联的表删除时，自动删除触发器（Trigger）。<br>要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 tablename，而不是 database.tablename。<br>一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。<br>在部分事件的触发器的回调中（begin、end中）可以通过new.和old.获取新的值和旧的值</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>创建触发器基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] event_name </span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 触发器逻辑....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在 UPDATE 操作上在表的一个或多个指定列上创建触发器的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] <span class="keyword">UPDATE</span> <span class="keyword">OF</span> column_name </span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 触发器逻辑....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建插入数据的触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> audit_log AFTER <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> COMPANY</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">INSERT</span> <span class="keyword">INTO</span> AUDIT(EMP_ID, ENTRY_DATE) <span class="keyword">VALUES</span> (new.ID, datetime(<span class="string">&#x27;now&#x27;</span>));</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h1 id="列出触发器"><a href="#列出触发器" class="headerlink" title="列出触发器"></a>列出触发器</h1><p>可以从 sqlite_master 表中列出所有触发器，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;trigger&#x27;</span> <span class="keyword">AND</span> tbl_name <span class="operator">=</span> <span class="string">&#x27;COMPANY&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> 触发器 </tag>
            
            <tag> Trigger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-多表查询</title>
      <link href="/2024/05/23/SQLite3-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2024/05/23/SQLite3-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段。<br>SQL 定义了三种主要类型的连接：<br>交叉连接 - CROSS JOIN<br>内连接 - INNER JOIN<br>外连接 - OUTER JOIN</p><h1 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接 - CROSS JOIN"></a>交叉连接 - CROSS JOIN</h1><p>交叉连接（CROSS JOIN）把第一个表的每一行与第二个表的每一行进行匹配。如果两个输入表分别有 x 和 y 行，则结果表有 x*y 行。由于交叉连接（CROSS JOIN）有可能产生非常大的表，使用时必须谨慎，只在适当的时候使用它们。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2 ...</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> DEPARTMENT;</span><br></pre></td></tr></table></figure><h1 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接 - INNER JOIN"></a>内连接 - INNER JOIN</h1><p>内连接（INNER JOIN）根据连接谓词结合两个表（table1 和 table2）的列值来创建一个新的结果表。查询会把 table1 中的每一行与 table2 中的每一行进行比较，找到所有满足连接谓词的行的匹配对。当满足连接谓词时，A 和 B 行的每个匹配对的列值会合并成一个结果行。<br>内连接（INNER JOIN）是最常见的连接类型，是默认的连接类型。INNER 关键字是可选的。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> conditional_expression ...</span><br></pre></td></tr></table></figure><p>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">JOIN</span> table2 <span class="keyword">USING</span> ( column1 ,... ) ...</span><br></pre></td></tr></table></figure><p>自然连接（NATURAL JOIN）类似于 JOIN…USING，只是它会自动测试存在两个表中的每一列的值之间相等值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> table2...</span><br></pre></td></tr></table></figure><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure><h1 id="外连接-OUTER-JOIN"><a href="#外连接-OUTER-JOIN" class="headerlink" title="外连接 - OUTER JOIN"></a>外连接 - OUTER JOIN</h1><p>外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，但 SQLite 只支持 左外连接（LEFT OUTER JOIN）。<br>外连接（OUTER JOIN）声明条件的方法与内连接（INNER JOIN）是相同的，使用 ON、USING 或 NATURAL 关键字来表达。最初的结果表以相同的方式进行计算。一旦主连接计算完成，外连接（OUTER JOIN）将从一个或两个表中任何未连接的行合并进来，外连接的列使用 NULL 值，将它们附加到结果表中。</p><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> conditional_expression ...</span><br></pre></td></tr></table></figure><p>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明外连接（OUTER JOIN）条件。这个表达式指定一个或多个列的列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">USING</span> ( column1 ,... ) ...</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure><h1 id="联合查询-UNION-UNION-ALL"><a href="#联合查询-UNION-UNION-ALL" class="headerlink" title="联合查询 - UNION , UNION ALL"></a>联合查询 - UNION , UNION ALL</h1><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>SQLite的 UNION 子句&#x2F;运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。<br>为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID</span><br><span class="line">   <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure><h2 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a>UNION ALL</h2><p>UNION ALL 运算符用于结合两个 SELECT 语句的结果，包括重复行。<br>适用于 UNION 的规则同样适用于 UNION ALL 运算符。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID</span><br><span class="line">   <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> JOIN </tag>
            
            <tag> UNION </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-约束</title>
      <link href="/2024/05/23/SQLite3-%E7%BA%A6%E6%9D%9F/"/>
      <url>/2024/05/23/SQLite3-%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="约束的定义"><a href="#约束的定义" class="headerlink" title="约束的定义"></a>约束的定义</h1><p>约束是在表的数据列上强制执行的规则，这些是用来限制可以插入到表中的数据类型，这确保了数据库中数据的准确性和可靠性。</p><p>约束可以是列级或表级。列级约束仅适用于列，表级约束被应用到整个表。</p><p>以下是在 SQLite 中常用的约束。</p><p>NOT NULL 约束：确保某列不能有 NULL 值。</p><p>DEFAULT 约束：当某列没有指定值时，为该列提供默认值。</p><p>UNIQUE 约束：确保某列中的所有值是不同的。</p><p>PRIMARY Key 约束：唯一标识数据库表中的各行&#x2F;记录。</p><p>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。</p><h1 id="NOT-NULL约束"><a href="#NOT-NULL约束" class="headerlink" title="NOT NULL约束"></a>NOT NULL约束</h1><p>默认情况下，列可以保存 NULL 值。如果您不想某列有 NULL 值，那么需要在该列上定义此约束，指定在该列上不允许 NULL 值。<br>NULL 与没有数据是不一样的，它代表着未知的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="DEFAULT约束"><a href="#DEFAULT约束" class="headerlink" title="DEFAULT约束"></a>DEFAULT约束</h1><p>DEFAULT 约束在 INSERT INTO 语句没有提供一个特定的值时，为列提供一个默认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">DEFAULT</span> <span class="number">50000.00</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="UNIQUE约束"><a href="#UNIQUE约束" class="headerlink" title="UNIQUE约束"></a>UNIQUE约束</h1><p>UNIQUE 约束防止在一个特定的列存在两个记录具有相同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">DEFAULT</span> <span class="number">50000.00</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="PRIMARY-KEY约束"><a href="#PRIMARY-KEY约束" class="headerlink" title="PRIMARY KEY约束"></a>PRIMARY KEY约束</h1><p>PRIMARY KEY 约束唯一标识数据库表中的每个记录。在一个表中可以有多个 UNIQUE 列，但只能有一个主键。在设计数据库表时，主键是很重要的。主键是唯一的 ID。<br>我们使用主键来引用表中的行。可通过把主键设置为其他表的外键，来创建表之间的关系。由于”长期存在编码监督”，在 SQLite 中，主键可以是 NULL，这是与其他数据库不同的地方。<br>主键是表中的一个字段，唯一标识数据库表中的各行&#x2F;记录。主键必须包含唯一值。主键列不能有 NULL 值。<br>一个表只能有一个主键，它可以由一个或多个字段组成。当多个字段作为主键，它们被称为复合键。<br>如果一个表在任何字段上定义了一个主键，那么在这些字段上不能有两个记录具有相同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h1><p>CHECK 约束启用输入一条记录要检查值的条件。如果条件值为 false，则记录违反了约束，且不能输入到表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> COMPANY3(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">CHECK</span>(SALARY <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h1><p>在 SQLite 中，要删除表的约束，通常需要使用 ALTER TABLE 语句，并指定要删除的约束类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> key_name;</span><br></pre></td></tr></table></figure><p>table_name 是你要操作的表名，key_name 是要删除的约束的名称。</p>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> 约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-DQL基本查询</title>
      <link href="/2024/04/26/SQLite3-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2/"/>
      <url>/2024/04/26/SQLite3-DQL%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h1><h2 id="语句定义"><a href="#语句定义" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>1）查询某些列的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> ID, NAME, SALARY <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure><p>2）查询全部列的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure><h1 id="LIKE语句"><a href="#LIKE语句" class="headerlink" title="LIKE语句"></a>LIKE语句</h1><h2 id="语句定义-1"><a href="#语句定义-1" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用：<br>百分号 （%）<br>下划线 （_）<br>百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>AGE以2开头：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE  <span class="keyword">LIKE</span> <span class="string">&#x27;2%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> ADDRESS  <span class="keyword">LIKE</span> <span class="string">&#x27;%-%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="GLOB语句"><a href="#GLOB语句" class="headerlink" title="GLOB语句"></a>GLOB语句</h1><h2 id="语句定义-2"><a href="#语句定义-2" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。<br>*：匹配零个、一个或多个数字或字符。<br>?：代表一个单一的数字或字符。<br>[…]：匹配方括号内指定的字符之一。例如，[abc] 匹配 “a”、”b” 或 “c” 中的任何一个字符。<br>[^…]：匹配不在方括号内指定的字符之一。例如，[^abc] 匹配不是 “a”、”b” 或 “c” 中的任何一个字符的字符。<br>以上这些符号可以被组合使用。</p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><p>显示 COMPANY 表中 AGE 以 2 开头的所有记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE  GLOB <span class="string">&#x27;2*&#x27;</span>;</span><br></pre></td></tr></table></figure><p>显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> ADDRESS  GLOB <span class="string">&#x27;*-*&#x27;</span>;</span><br></pre></td></tr></table></figure><p>[…] 表达式用于匹配方括号内指定的字符集中的任何一个字符。<br>实例 1：匹配以 “A” 或 “B” 开头的产品名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_name <span class="keyword">LIKE</span> <span class="string">&#x27;[AB]%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>[^…] 表达式用于匹配不在方括号内指定的字符集中的任何字符。<br>实例 1：匹配不以 “X” 或 “Y” 开头的产品代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> product_code <span class="keyword">LIKE</span> <span class="string">&#x27;[^XY]%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="LIMIT语句"><a href="#LIMIT语句" class="headerlink" title="LIMIT语句"></a>LIMIT语句</h1><h2 id="语句定义-3"><a href="#语句定义-3" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。</p><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>LIMIT语句的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [<span class="keyword">no</span> <span class="keyword">of</span> <span class="keyword">rows</span>]</span><br></pre></td></tr></table></figure><p>下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [<span class="keyword">no</span> <span class="keyword">of</span> <span class="keyword">rows</span>] <span class="keyword">OFFSET</span> [<span class="type">row</span> num]</span><br></pre></td></tr></table></figure><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><p>只返回6行数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY LIMIT <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>从一个特定的偏移开始提取记录。如从第三位开始提取 3 个记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="ORDER-BY语句"><a href="#ORDER-BY语句" class="headerlink" title="ORDER BY语句"></a>ORDER BY语句</h1><h2 id="语句定义-4"><a href="#语句定义-4" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。</p><h2 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h2><p>ASC 默认值，从小到大，升序排列<br>DESC 从大到小，降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2, .. columnN] [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure><h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><p>将工资升序排列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">ORDER</span> <span class="keyword">BY</span> SALARY <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1 id="GROUP-BY语句"><a href="#GROUP-BY语句" class="headerlink" title="GROUP BY语句"></a>GROUP BY语句</h1><h2 id="语句定义-5"><a href="#语句定义-5" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。<br>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p><h2 id="语法结构-2"><a href="#语法结构-2" class="headerlink" title="语法结构"></a>语法结构</h2><p>GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2....columnN</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2....columnN</span><br></pre></td></tr></table></figure><h2 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h2><p>将求出年龄相同的人的工资总总和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> AGE, <span class="built_in">SUM</span>(SALARY) <span class="keyword">FROM</span> COMPANY <span class="keyword">GROUP</span> <span class="keyword">BY</span> AGE;</span><br></pre></td></tr></table></figure><h1 id="HAVING语句"><a href="#HAVING语句" class="headerlink" title="HAVING语句"></a>HAVING语句</h1><h2 id="语句定义-6"><a href="#语句定义-6" class="headerlink" title="语句定义"></a>语句定义</h2><p>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。<br>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><h2 id="语法结构-3"><a href="#语法结构-3" class="headerlink" title="语法结构"></a>语法结构</h2><p>HAVING 子句在 SELECT 查询中的位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure><p>在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> [ conditions ]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2</span><br></pre></td></tr></table></figure><h2 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h2><p>显示名称计数小于 2 的所有记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">GROUP</span> <span class="keyword">BY</span> name <span class="keyword">HAVING</span> <span class="built_in">count</span>(name) <span class="operator">&lt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="DISTINCT关键字"><a href="#DISTINCT关键字" class="headerlink" title="DISTINCT关键字"></a>DISTINCT关键字</h1><h2 id="关键字定义"><a href="#关键字定义" class="headerlink" title="关键字定义"></a>关键字定义</h2><p>SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。<br>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p><h2 id="语法结构-4"><a href="#语法结构-4" class="headerlink" title="语法结构"></a>语法结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2,.....columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure><h2 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure><p>如果COMPANY表有重复数据，则重复数据只出现一次。</p>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> DQL语句 </tag>
            
            <tag> select </tag>
            
            <tag> like </tag>
            
            <tag> blob </tag>
            
            <tag> order by </tag>
            
            <tag> group by </tag>
            
            <tag> limit </tag>
            
            <tag> having </tag>
            
            <tag> distinct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-DML语句基本使用</title>
      <link href="/2024/04/26/SQLite3-DML%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/04/26/SQLite3-DML%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="INSERT-语句-插入数据"><a href="#INSERT-语句-插入数据" class="headerlink" title="INSERT 语句-插入数据"></a>INSERT 语句-插入数据</h1><h2 id="语句定义"><a href="#语句定义" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLE_NAME [(column1, column2, column3,...columnN)]</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3,...valueN);</span><br></pre></td></tr></table></figure><p>如果不指定列名则按列的顺序给数据赋值。<br>可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> first_table_name [(column1, column2, ... columnN)]</span><br><span class="line">   <span class="keyword">SELECT</span> column1, column2, ...columnN</span><br><span class="line">   <span class="keyword">FROM</span> second_table_name</span><br><span class="line">   [<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure><h1 id="UPDATE-语句-修改数据"><a href="#UPDATE-语句-修改数据" class="headerlink" title="UPDATE 语句-修改数据"></a>UPDATE 语句-修改数据</h1><h2 id="语句定义-1"><a href="#语句定义-1" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2...., columnN <span class="operator">=</span> valueN</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure><p>实际使用如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> COMPANY <span class="keyword">SET</span> ADDRESS <span class="operator">=</span> <span class="string">&#x27;Texas&#x27;</span> <span class="keyword">WHERE</span> ID <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>如果您想修改 COMPANY 表中 ADDRESS 和 SALARY 列的所有值，则不需要使用 WHERE 子句，UPDATE 查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> COMPANY <span class="keyword">SET</span> ADDRESS <span class="operator">=</span> <span class="string">&#x27;Texas&#x27;</span>, SALARY <span class="operator">=</span> <span class="number">20000.00</span>;</span><br></pre></td></tr></table></figure><h1 id="DELETE-语句-删除数据"><a href="#DELETE-语句-删除数据" class="headerlink" title="DELETE 语句-删除数据"></a>DELETE 语句-删除数据</h1><h2 id="语句定义-2"><a href="#语句定义-2" class="headerlink" title="语句定义"></a>语句定义</h2><p>SQLite 的 DELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。</p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure><h1 id="清空数据"><a href="#清空数据" class="headerlink" title="清空数据"></a>清空数据</h1><h2 id="语句定义-3"><a href="#语句定义-3" class="headerlink" title="语句定义"></a>语句定义</h2><p>在 SQLite 中，并没有 TRUNCATE TABLE 命令，但可以使用 SQLite 的 DELETE 命令从已有的表中删除全部的数据。</p><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> DML语句 </tag>
            
            <tag> insert </tag>
            
            <tag> update </tag>
            
            <tag> delete </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-DDL语句基本使用</title>
      <link href="/2024/04/26/SQLite3-DDL%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/04/26/SQLite3-DDL%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>创建数据库可以在命令行中使用以下命令：<br>1）创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sqlite3 DatabaseName.db</span><br></pre></td></tr></table></figure><p>2）使用.open 命令，有则打开无则创建并打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.open test.db</span><br></pre></td></tr></table></figure><h2 id="dump-导出数据库"><a href="#dump-导出数据库" class="headerlink" title=".dump 导出数据库"></a>.dump 导出数据库</h2><p>你可以使用.dump 命令将一个数据库完全导出到一个文本文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sqlite3 testDB.db .dump &gt; testDB.sql</span><br></pre></td></tr></table></figure><p>上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sqlite3 testDB.db &lt; testDB.sql</span><br></pre></td></tr></table></figure><h2 id="ATTACH-语句-附加数据库"><a href="#ATTACH-语句-附加数据库" class="headerlink" title="ATTACH 语句-附加数据库"></a>ATTACH 语句-附加数据库</h2><p>假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DATABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。<br>如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。<br>打开的数据库和使用 ATTACH 附加进来的数据库的必须位于同一文件夹下。<br>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATTACH DATABASE file_name <span class="keyword">AS</span> database_name;</span><br></pre></td></tr></table></figure><p>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>  ATTACH DATABASE <span class="string">&#x27;testDB.db&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;TEMP&#x27;</span>;</span><br><span class="line">Error: database TEMP <span class="keyword">is</span> already <span class="keyword">in</span> use</span><br><span class="line">sqlite<span class="operator">&gt;</span>  ATTACH DATABASE <span class="string">&#x27;testDB.db&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;main&#x27;</span>;</span><br><span class="line">Error: database main <span class="keyword">is</span> already <span class="keyword">in</span> use；</span><br></pre></td></tr></table></figure><h2 id="DETACH-语句-分离数据库"><a href="#DETACH-语句-分离数据库" class="headerlink" title="DETACH 语句-分离数据库"></a>DETACH 语句-分离数据库</h2><p>SQLite 的 DETACH DATABASE 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。<br>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DETACH DATABASE <span class="string">&#x27;Alias-Name&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h1><h2 id="CREATE-语句-创建表"><a href="#CREATE-语句-创建表" class="headerlink" title="CREATE 语句-创建表"></a>CREATE 语句-创建表</h2><p>SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。<br>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> database_name.table_name(</span><br><span class="line">   column1 datatype  <span class="keyword">PRIMARY</span> KEY(<span class="keyword">one</span> <span class="keyword">or</span> more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 database_name。<br>创建完成后可以使用.tables 命令查看当前数据库中所有的表。<br>也可以使用 SQLite .schema table_name 命令得到建表语句。</p><h2 id="DROP-语句-删除表"><a href="#DROP-语句-删除表" class="headerlink" title="DROP 语句-删除表"></a>DROP 语句-删除表</h2><p>SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。<br>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> database_name.table_name;</span><br></pre></td></tr></table></figure><h2 id="ALTER-语句-修改表结构"><a href="#ALTER-语句-修改表结构" class="headerlink" title="ALTER 语句-修改表结构"></a>ALTER 语句-修改表结构</h2><p>SQLite 的 ALTER TABLE 命令不通过执行一个完整的转储和数据的重载来修改已有的表。您可以使用 ALTER TABLE 语句重命名表，使用 ALTER TABLE 语句还可以在已有的表中添加额外的列。<br>在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作。<br>语法如下：<br>1）修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> database_name.table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br></pre></td></tr></table></figure><p>2）添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> database_name.table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_def...;</span><br></pre></td></tr></table></figure><p>实际使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OLD_COMPANY <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> SEX <span class="type">char</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="自动增长-Autoincrement"><a href="#自动增长-Autoincrement" class="headerlink" title="自动增长 Autoincrement"></a>自动增长 Autoincrement</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>指定column1列的值是自增的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column1 <span class="type">INTEGER</span> AUTOINCREMENT,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
            <tag> DDL语句 </tag>
            
            <tag> attach </tag>
            
            <tag> detach </tag>
            
            <tag> create </tag>
            
            <tag> drop </tag>
            
            <tag> alter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite3-基本操作</title>
      <link href="/2024/04/25/SQLite3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/04/25/SQLite3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLite-的特点"><a href="#SQLite-的特点" class="headerlink" title="SQLite 的特点"></a>SQLite 的特点</h1><p>SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是一个增长最快的数据库引擎，这是在普及方面的增长，与它的尺寸大小无关。SQLite 源代码不受版权限制。<br>SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。<br>SQLite 不需要一个单独的服务器进程或操作的系统（无服务器的）。<br>SQLite 不需要配置，这意味着不需要安装或管理。<br>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。<br>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于 250KiB。<br>SQLite 是自给自足的，这意味着不需要任何外部的依赖。<br>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。<br>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。<br>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。<br>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。<br>SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。<br>SQLite 的字符串请使用单引号，因为我用双引号会报错。</p><h1 id="SQLite-的命令"><a href="#SQLite-的命令" class="headerlink" title="SQLite 的命令"></a>SQLite 的命令</h1><p>SQLite 命令与 SQL 语句的不同之处在于它们不以分号 ; 结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sqlite3</span><br><span class="line">SQLite version 3.3.6</span><br><span class="line">Enter &quot;.help&quot; for instructions</span><br><span class="line">sqlite&gt;.help</span><br></pre></td></tr></table></figure><p>上面的命令会显示各种重要的 SQLite 点命令的列表，其中常用的有：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>.databases</td><td>显示打开的数据库</td></tr><tr><td>.open ?DB_NAME?</td><td>打开名为 DB_NAME.db 的数据库，没有则创建</td></tr><tr><td>.tables ?PATTERN?</td><td>列出匹配 pattern 模式的表的名称</td></tr><tr><td>.backup ?DB? FILE</td><td>备份 DB 数据库（默认是 “main”）到 FILE 文件</td></tr><tr><td>.exit</td><td>退出 SQLite 提示符</td></tr><tr><td>.help</td><td>显示命令帮助列表</td></tr><tr><td>.schema ?TABLE?</td><td>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表</td></tr><tr><td>.show</td><td>显示各种设置的当前值</td></tr></tbody></table><h1 id="sqlite-master-表"><a href="#sqlite-master-表" class="headerlink" title="sqlite_master 表"></a>sqlite_master 表</h1><p>主表中保存数据库表的关键信息，并把它命名为 sqlite_master。如要查看表概要，可按如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.schema sqlite_master</span><br></pre></td></tr></table></figure><p>将产生以下结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqlite_master (</span><br><span class="line">  type text,</span><br><span class="line">  name text,</span><br><span class="line">  tbl_name text,</span><br><span class="line">  rootpage <span class="type">integer</span>,</span><br><span class="line">  <span class="keyword">sql</span> text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="SQLite-数据类型"><a href="#SQLite-数据类型" class="headerlink" title="SQLite 数据类型"></a>SQLite 数据类型</h1><p>SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。<br>开发者可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。<br>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p><table><thead><tr><th>存储类型</th><th>描述</th></tr></thead><tbody><tr><td>NULL</td><td>值是一个 NULL 值</td></tr><tr><td>INTEGER</td><td>值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中</td></tr><tr><td>REAL</td><td>值是一个浮点值，存储为 8 字节的 IEEE 浮点数字</td></tr><tr><td>TEXT</td><td>值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储</td></tr><tr><td>BLOB</td><td>值是一个 blob 数据，完全根据它的输入存储</td></tr></tbody></table><p>SQLite 的存储类稍微比数据类型更普遍。例如 INTEGER 存储类型，包含 6 种不同的不同长度的整数数据类型。<br>SQLite 没有一个单独的用于存储日期和&#x2F;或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。<br>存储为 TEXT：格式为：”YYYY-MM-DD HH:MM:SS.SSS”的日期。<br>存储为 REAL：从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。<br>存储为 INTEGER：从 1970-01-01 00:00:00 UTC 算起的秒数。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>比较运算符和算数运算法则与编程语言的运算符相同。<br>逻辑运算符由一些区别</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符如下图所示：<br><img src="/images/SQLite3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/1.jpg"></p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>SQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> SINGLE <span class="keyword">VALUE</span> MATCHING EXPRESSION;</span><br></pre></td></tr></table></figure><p>实际使用如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> SALARY <span class="operator">=</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h2 id="数值表达式"><a href="#数值表达式" class="headerlink" title="数值表达式"></a>数值表达式</h2><p>用来执行查询中的任何数学运算。<br>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> numerical_expression <span class="keyword">as</span>  OPERATION_NAME</span><br><span class="line">[<span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">CONDITION</span>] ;</span><br></pre></td></tr></table></figure><p>实际使用如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (<span class="number">15</span> <span class="operator">+</span> <span class="number">6</span>) <span class="keyword">AS</span> ADDITION</span><br><span class="line">ADDITION <span class="operator">=</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><h2 id="日期表达式"><a href="#日期表达式" class="headerlink" title="日期表达式"></a>日期表达式</h2><p>日期表达式返回当前系统日期和时间值，这些表达式将被用于各种数据操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">=</span> <span class="number">2013</span><span class="number">-03</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">35</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQLite3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-网络请求</title>
      <link href="/2024/04/24/Python-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
      <url>/2024/04/24/Python-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="requests-模块"><a href="#requests-模块" class="headerlink" title="requests 模块"></a>requests 模块</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>Python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP 请求，并获取响应结果。<br>requests 模块比 urllib 模块更简洁。<br>如同 JavaScript 的 AJAX 与 C#的 HttpClient 一样，requests 模块用于请求网络接口，发送 get、post、put 等 http 请求。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>发送 Get 网络请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">res = requests.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>requests 模块有以下常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>delete(url, args)</td><td>发送 DELETE 请求到指定 url</td></tr><tr><td>get(url, params, args)</td><td>发送 GET 请求到指定 url</td></tr><tr><td>head(url, args)</td><td>发送 HEAD 请求到指定 url</td></tr><tr><td>patch(url, data, args)</td><td>发送 PATCH 请求到指定 url</td></tr><tr><td>post(url, data, json, args)</td><td>发送 POST 请求到指定 url</td></tr><tr><td>put(url, data, args)</td><td>发送 PUT 请求到指定 url</td></tr><tr><td>request(method, url, args)</td><td>向指定的 url 发送指定的请求方法</td></tr><tr><td>使用 requests.request()发送 http 请求代码如下：</td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">x = requests.request(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.runoob.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回网页内容</span></span><br><span class="line"><span class="built_in">print</span>(x.status_code)</span><br></pre></td></tr></table></figure><h2 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h2><p>很多时候我们需要附带或修改请求头的信息比如携带 cookie，以下代码演示发送 get 请求并携带请求头的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 requests 包</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kw = &#123;<span class="string">&#x27;s&#x27;</span>:<span class="string">&#x27;python 教程&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置请求头</span></span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://www.runoob.com/&quot;</span>, params = kw, headers = headers)</span><br></pre></td></tr></table></figure><h1 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h1><h2 id="基本理论-1"><a href="#基本理论-1" class="headerlink" title="基本理论"></a>基本理论</h2><p>每次调用 requests 请求之后，会返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头、响应内容等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 获取响应状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  <span class="comment"># 获取响应头</span></span><br><span class="line"><span class="built_in">print</span>(response.content)  <span class="comment"># 获取响应内容</span></span><br><span class="line"><span class="built_in">print</span>(response.json())  <span class="comment"># 需要返回内为json格式，不然就报错</span></span><br></pre></td></tr></table></figure><p>response 对象还有许多属性与方法，可以查文档了解他们。</p><h1 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h1><h2 id="基本理论-2"><a href="#基本理论-2" class="headerlink" title="基本理论"></a>基本理论</h2><p>json是一种在http通信中常用的数据格式。<br>Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数：<br>json.dumps(): 对数据进行编码。<br>json.loads(): 对数据进行解码。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>将一个JSON编码的字符串转换回一个Python数据结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Python 字典类型转换为 JSON 对象</span></span><br><span class="line">data1 = &#123;</span><br><span class="line">    <span class="string">&#x27;no&#x27;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;Runoob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span> : <span class="string">&#x27;http://www.runoob.com&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">json_str = json.dumps(data1)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Python 原始数据：&quot;</span>, <span class="built_in">repr</span>(data1))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;JSON 对象：&quot;</span>, json_str)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将 JSON 对象转换为 Python 字典</span></span><br><span class="line">data2 = json.loads(json_str)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;data2[&#x27;name&#x27;]: &quot;</span>, data2[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;data2[&#x27;url&#x27;]: &quot;</span>, data2[<span class="string">&#x27;url&#x27;</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> requests模块 </tag>
            
            <tag> json模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-多线程</title>
      <link href="/2024/04/24/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/04/24/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="多线程的概念与-Python-实现"><a href="#多线程的概念与-Python-实现" class="headerlink" title="多线程的概念与 Python 实现"></a>多线程的概念与 Python 实现</h2><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>每个线程都有他自己的一组 CPU 寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的 CPU 寄存器的状态。<br>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。<br>线程可以被抢占（中断）。<br>在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。<br>线程可以分为:<br>内核线程：由操作系统内核创建和撤销。<br>用户线程：不需要内核支持而在用户程序中实现的线程。<br>Python3 线程中常用的两个模块为：<br>_thread<br>threading(推荐使用)<br>thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。</p><h1 id="thread-模块"><a href="#thread-模块" class="headerlink" title="_thread 模块"></a>_thread 模块</h1><p>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。</p><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>调用 _thread 模块中的 start_new_thread()函数来产生新线程，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_thread.start_new_thread ( function, args[, kwargs] )</span><br></pre></td></tr></table></figure><p>参数说明:<br>function - 线程函数。<br>args - 传递给线程函数的参数,他必须是个 tuple 类型。<br>kwargs - 可选参数。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>创建两个线程并同时执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为线程定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params"> threadName, delay</span>):</span><br><span class="line">   count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">      time.sleep(delay)</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % ( threadName, time.ctime(time.time()) ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个线程</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   _thread.start_new_thread( print_time, (<span class="string">&quot;Thread-1&quot;</span>, <span class="number">2</span>, ) )</span><br><span class="line">   _thread.start_new_thread( print_time, (<span class="string">&quot;Thread-2&quot;</span>, <span class="number">4</span>, ) )</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;Error: 无法启动线程&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="threading-模块"><a href="#threading-模块" class="headerlink" title="threading 模块"></a>threading 模块</h1><p>推荐使用 threading 模块来使用多线程</p><h2 id="基本理论-1"><a href="#基本理论-1" class="headerlink" title="基本理论"></a>基本理论</h2><p>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：</p><p>threading. current_thread(): 返回当前的线程变量。<br>threading.enumerate(): 返回一个包含正在运行的线程的列表。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。<br>threading.active_count(): 返回正在运行的线程数量，与 len(threading.enumerate()) 有相同的结果。<br>threading.Thread(target, args&#x3D;(), kwargs&#x3D;{}, daemon&#x3D;None)：<br>创建 Thread 类的实例。<br>target：线程将要执行的目标函数。<br>args：目标函数的参数，以元组形式传递。<br>kwargs：目标函数的关键字参数，以字典形式传递。<br>daemon：指定线程是否为守护线程。<br>threading.Thread 类提供了以下方法与属性:</p><p><strong>init</strong>(self, group&#x3D;None, target&#x3D;None, name&#x3D;None, args&#x3D;(), kwargs&#x3D;{}, *, daemon&#x3D;None)：</p><p>初始化 Thread 对象。<br>group：线程组，暂时未使用，保留为将来的扩展。<br>target：线程将要执行的目标函数。<br>name：线程的名称。<br>args：目标函数的参数，以元组形式传递。<br>kwargs：目标函数的关键字参数，以字典形式传递。<br>daemon：指定线程是否为守护线程。<br>start(self)：</p><p>启动线程。将调用线程的 run()方法。<br>run(self)：</p><p>线程在此方法中定义要执行的代码。<br>join(self, timeout&#x3D;None)：</p><p>等待线程终止。默认情况下，join()会一直阻塞，直到被调用线程终止。如果指定了 timeout 参数，则最多等待 timeout 秒。<br>is_alive(self)：</p><p>返回线程是否在运行。如果线程已经启动且尚未终止，则返回 True，否则返回 False。<br>getName(self)：</p><p>返回线程的名称。<br>setName(self, name)：</p><p>设置线程的名称。<br>ident 属性：</p><p>线程的唯一标识符。<br>daemon 属性：</p><p>线程的守护标志，用于指示是否是守护线程。<br>isDaemon()方法：</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>一个简单的线程示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">thread = threading.Thread(target=print_numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程</span></span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待线程结束</span></span><br><span class="line">thread.join()</span><br></pre></td></tr></table></figure><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。<br>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。<br>考虑这样一种情况：一个列表里所有元素都是 0，线程 “set” 从后向前把所有元素改成 1，而线程 “print” 负责从前往后读取列表并打印。<br>那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半 0 一半 1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。</p><h2 id="基本理论-2"><a href="#基本理论-2" class="headerlink" title="基本理论"></a>基本理论</h2><p>使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。</p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><p>创建继承自 threading.Thread 类的 myThread 类，在 run()的时候使用锁机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span> (threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, threadID, name, delay</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.delay = delay</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程： &quot;</span> + self.name)</span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.delay, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params">threadName, delay, counter</span>):</span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加线程到线程列表</span></span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> _thread </tag>
            
            <tag> threading </tag>
            
            <tag> 线程同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-面向对象</title>
      <link href="/2024/04/11/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/04/11/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h1><h2 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h2><p>使用 class 关键字定义一个类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">    age=<span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;吃东西&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = People() <span class="comment"># 实例化</span></span><br><span class="line">p.eat()</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>众所周知，js 的构造函数是 constructor，c#的构造函数是与类名同名的不带返回值的方法。<br>而在 python 中构造函数是__init__()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,a,b</span>):</span><br><span class="line">        self.a=a</span><br><span class="line">        self.b=b</span><br></pre></td></tr></table></figure><p>注意实例化的时候要给构造函数传参。</p><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。<br>有点类似 js 和 c#的 this。<br>当你定义一个类，并在类中定义方法时，第一个参数通常被命名为 self，尽管你可以使用其他名称，但强烈建议使用 self，以保持代码的一致性和可读性。</p><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>在定义类的时候使用括号()包住要继承的父类。<br>继承多个父类使用逗号分隔。<br>子类的方法和属性可以与父类同名，表示覆写父类的方法或属性。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br></pre></td></tr></table></figure><h1 id="私有属性与方法"><a href="#私有属性与方法" class="headerlink" title="私有属性与方法"></a>私有属性与方法</h1><h2 id="基本理论-1"><a href="#基本理论-1" class="headerlink" title="基本理论"></a>基本理论</h2><p>__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。<br>__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JustCounter</span>:</span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> (self.__secretCount)</span><br><span class="line"></span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span> (counter.publicCount)</span><br><span class="line"><span class="built_in">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br></pre></td></tr></table></figure><h1 id="运算符重载示例"><a href="#运算符重载示例" class="headerlink" title="运算符重载示例"></a>运算符重载示例</h1><p>重载加法运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 类 </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-错误与异常</title>
      <link href="/2024/04/09/Python-%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
      <url>/2024/04/09/Python-%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>1、python 的错误捕获使用 try&#x2F;except 语法。<br>2、工作方式如下：<br>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。<br>如果没有异常发生，忽略 except 子句，try 子句执行后结束。<br>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。<br>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。<br>3、一个 try 语句可能包含多个 except 子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。<br>4、处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>数值错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字: &quot;</span>))</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您输入的不是数字，请再次尝试输入！&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="try-except…else"><a href="#try-except…else" class="headerlink" title="try&#x2F;except…else"></a>try&#x2F;except…else</h2><p>try&#x2F;except…else 语法在 try&#x2F;catch 的基础上增加了当没有错误时执行 else 语句的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(arg, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cannot open&#x27;</span>, arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(arg, <span class="string">&#x27;has&#x27;</span>, <span class="built_in">len</span>(f.readlines()), <span class="string">&#x27;lines&#x27;</span>)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><h2 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h2><p>try-finally 语句和 js、c#一样，finally 的语句总是会被执行，无论异常与否。</p><h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><h2 id="基本理论-1"><a href="#基本理论-1" class="headerlink" title="基本理论"></a>基本理论</h2><p>Python 使用 raise 语句抛出一个指定的异常。<br>语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></table></figure><h1 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h1><h2 id="基本理论-2"><a href="#基本理论-2" class="headerlink" title="基本理论"></a>基本理论</h2><p>可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。</p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">repr</span>(self.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="string">&#x27;oops!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;自定义错误：<span class="subst">&#123;e.value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> try/except </tag>
            
            <tag> raise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-模块化</title>
      <link href="/2024/04/06/Python-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2024/04/06/Python-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>需在另一个源文件里执行 import 语句，js 中为”import {xxx} from ‘xxx’ “，c#中为”using namespace xxx”，python 中为”from xxx import xxx”。<br>需要把引入命令放在脚本的顶端。<br>一个模块只会被导入一次，不管你执行了多少次 import。这样可以防止导入模块被一遍又一遍地执行。<br>模块搜索路径：Python 解释器依次从搜索路径中去寻找所引入的模块，可以通过 sys.path 查看搜索路径。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>1、导入 sys 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;命令行参数如下:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\nPython 路径为：&#x27;</span>, sys.path, <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>2、导入同目录下某个模块的某个函数或变量<br>目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">    main.py</span><br><span class="line">    package.py</span><br></pre></td></tr></table></figure><p>package.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>main.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> package <span class="keyword">import</span> fun1</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure><p>3、导入其他路径下的某个模块<br>目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">    main.py</span><br><span class="line">    packages/</span><br><span class="line">        package.py</span><br></pre></td></tr></table></figure><p>package.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>main.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> packages <span class="keyword">import</span> package</span><br><span class="line">package.fun1()</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。<br>比如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B 。<br>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。<br>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><p>目录只有包含一个叫做__init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块，当然这个文件中也可以包含一些初始化代码或者为__all__变量赋值。<br>我们可以在__init__.py 中的__all__&#x3D;[]中定义这个包包含哪些模块，如果用户使用 from xxx import *时，就会引入__all__定义的模块。如果没有__all__就不会引入任何模块。<br>目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">    main.py</span><br><span class="line">    packages/</span><br><span class="line">        __init__.py</span><br><span class="line">        package1.py</span><br><span class="line">        package2.py</span><br></pre></td></tr></table></figure><p>__init__.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__all__=[<span class="string">&quot;package1&quot;</span>,<span class="string">&quot;package2&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;作为主程序使用&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;作为引入使用&quot;</span>)</span><br></pre></td></tr></table></figure><p>package1.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>package2.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun3</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun4</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>main.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> packages <span class="keyword">import</span> *</span><br><span class="line">package1.fun1()</span><br><span class="line">package2.fun3()</span><br></pre></td></tr></table></figure><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”__main__“，一个 Python 应用程序的主模块，应当总是使用绝对路径引用。<br>包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py 被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-函数</title>
      <link href="/2024/04/06/Python-%E5%87%BD%E6%95%B0/"/>
      <url>/2024/04/06/Python-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>函数内容以冒号 : 起始，并且缩进。<br>return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>() :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。<br>不可变类型：变量赋值 a&#x3D;5 后再赋值 a&#x3D;10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。<br>可变类型：变量赋值 la&#x3D;[1,2,3,4] 后再赋值 la[2]&#x3D;5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。<br>python 函数的参数传递：<br>不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。<br>可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响<br>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p><h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>可以显式指定一个函数的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> str1 , str2 </span>):</span><br><span class="line">   <span class="built_in">print</span> (str1 + str2)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( str2=<span class="string">&quot;world&quot;</span> , str1 = <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>可以给参数指定默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure><h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><p>python中如果不指定默认值，则不定长参数是一个空元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">doSth</span>(<span class="params">*words</span>):</span><br><span class="line">    <span class="built_in">print</span>(words)</span><br><span class="line">doSth(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>加了两个星号 ** 的参数会以字典的形式导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>对比一下别的语言：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSth</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] words</span>)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSth</span>(<span class="params">...params</span>)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数内部的变量和全局的变量不是一个，所以如果想在函数内部去修改一个全局变量通过一下写法不会生效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doSth</span>():</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(a) <span class="comment">#100</span></span><br><span class="line">doSth()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#10</span></span><br></pre></td></tr></table></figure><p>可以使用global来修改全局变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doSth</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a=<span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(a) <span class="comment">#100</span></span><br><span class="line">doSth()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">#100</span></span><br></pre></td></tr></table></figure><h1 id="匿名函数（lambda表达式）"><a href="#匿名函数（lambda表达式）" class="headerlink" title="匿名函数（lambda表达式）"></a>匿名函数（lambda表达式）</h1><h2 id="基本理论-1"><a href="#基本理论-1" class="headerlink" title="基本理论"></a>基本理论</h2><p>Python 使用 lambda 来创建匿名函数。<br>lambda 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。<br>匿名函数不需要使用 def 关键字定义完整函数。<br>lambda 函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。<br>lambda 函数特点：<br>lambda 函数是匿名的，它们没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。<br>lambda 函数通常只包含一行代码，这使得它们适用于编写简单的函数。</p><h2 id="代码展示-1"><a href="#代码展示-1" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span>: <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(f())  <span class="comment"># 输出: Hello, world!</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(squared)  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(even_numbers)  <span class="comment"># 输出：[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 使用 reduce() 和 lambda 函数计算乘积</span></span><br><span class="line">product = reduce(<span class="keyword">lambda</span> x, y: x * y, numbers)</span><br><span class="line"><span class="built_in">print</span>(product)  <span class="comment"># 输出：120</span></span><br></pre></td></tr></table></figure><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="基本理论-2"><a href="#基本理论-2" class="headerlink" title="基本理论"></a>基本理论</h2><p>装饰器（decorators）是 Python 中的一种高级功能，它允许你动态地修改函数或类的行为。<br>装饰器是一种函数，它接受一个函数作为参数，并返回一个新的函数或修改原来的函数。<br>装饰器的语法使用 @decorator_name 来应用在函数或方法上。<br>Python 还提供了一些内置的装饰器，比如 @staticmethod 和 @classmethod，用于定义静态方法和类方法。<br>装饰器的应用场景：<br>日志记录: 装饰器可用于记录函数的调用信息、参数和返回值。<br>性能分析: 可以使用装饰器来测量函数的执行时间。<br>权限控制: 装饰器可用于限制对某些函数的访问权限。<br>缓存: 装饰器可用于实现函数结果的缓存，以提高性能。</p><h2 id="代码展示-2"><a href="#代码展示-2" class="headerlink" title="代码展示"></a>代码展示</h2><p>Python 装饰允许在不修改原有函数代码的基础上，动态地增加或修改函数的功能，装饰器本质上是一个接收函数作为输入并返回一个新的包装过后的函数的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_function</span>(<span class="params">original_function</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 这里是在调用原始函数前添加的新功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函數執行前&quot;</span>)</span><br><span class="line"></span><br><span class="line">        result = original_function(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里是在调用原始函数后添加的新功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;函數執行後&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用装饰器</span></span><br><span class="line"><span class="meta">@decorator_function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target_function</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg1)</span><br><span class="line">    <span class="built_in">print</span>(arg2)</span><br><span class="line">target_function(<span class="string">&#x27;你好&#x27;</span>,<span class="string">&#x27;世界&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>除了函数装饰器，Python 还支持类装饰器。类装饰器是包含 _<em>call_</em> 方法的类，它接受一个函数作为参数，并返回一个新的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 在调用原始函数之前/之后执行的代码</span></span><br><span class="line">        result = self.func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 在调用原始函数之后执行的代码</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@DecoratorClass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 函数 </tag>
            
            <tag> lambda表达式 </tag>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-迭代器与生成器</title>
      <link href="/2024/04/06/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2024/04/06/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>和js的iterator类似，python的迭代器其实也是实现某个接口或者对象中具有某个方法（ _<em>iter_</em>() 与 _<em>next_</em>()）就可以被迭代。<br>迭代器是一个可以记住遍历的位置的对象。<br>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。<br>迭代器有两个基本的方法：iter() 和 next()。</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><p>字符串，列表或元组对象都可用于创建迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们可以使用iter(可迭代对象)获取它的枚举器</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it)) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it)) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>循环语句实际遍历的是迭代器对象，所以可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h2 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h2><p>把一个类作为一个迭代器使用需要在类中实现两个方法 _<em>iter_</em>() 与 _<em>next_</em>() 。<br>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 _<em>init_</em>(), 它会在对象初始化的时候执行。<br>_<em>iter_</em>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 _<em>next_</em>() 方法并通过 StopIteration 异常标识迭代的完成。<br>_<em>next_</em>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。<br>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br></pre></td></tr></table></figure><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 _<em>next_</em>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。<br>在 20 次迭代后停止执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass) </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。<br>yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。<br>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。<br>当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。<br>然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。<br>调用一个生成器函数，返回的是一个迭代器对象。<br>下面是一个简单的示例，展示了生成器函数的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-语句</title>
      <link href="/2024/04/06/Python-%E8%AF%AD%E5%8F%A5/"/>
      <url>/2024/04/06/Python-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h2 id="match…case"><a href="#match…case" class="headerlink" title="match…case"></a>match…case</h2><p>Python 3.10 增加了 <strong>match…case</strong> 的条件判断，不需要再使用一连串的 <strong>if-else</strong> 来判断了。<br>match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，”_” 可以匹配一切。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">match</span> value:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while…else…"><a href="#while…else…" class="headerlink" title="while…else…"></a>while…else…</h2><p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> (count, <span class="string">&quot; 小于 5&quot;</span>)</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> (count, <span class="string">&quot; 大于或等于 5&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="for…else…"><a href="#for…else…" class="headerlink" title="for…else…"></a>for…else…</h2><p>和while…else…一样，当不满足for循环的条件时就执行else语句，用于在循环结束后执行一段代码。<br>break用于跳出循环，而else属于循环的一部分，所以break会跳过else的执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    <span class="keyword">if</span> index&gt;=<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(arr[index])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数组越界&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line">或者 </span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">res = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line">或</span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user=&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;school&quot;</span>:<span class="string">&quot;清华大学&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">res = &#123;key:<span class="built_in">str</span>(user[key])+<span class="string">&quot;hello&quot;</span> <span class="keyword">for</span> key <span class="keyword">in</span> user&#125;</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h2><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;返回的是生成器对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(a)) <span class="comment"># 可以通过tuple()将生成器对象转为元组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 条件判断 </tag>
            
            <tag> 循环语句 </tag>
            
            <tag> 推导式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-数据类型</title>
      <link href="/2024/03/27/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/03/27/Python-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>1、输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;请输入一个数字：&#x27;</span>) <span class="comment"># 按下enter后input函数返回值即刚才输入的数据</span></span><br></pre></td></tr></table></figure><p>2、输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a,b) <span class="comment"># 输出1 hello</span></span><br></pre></td></tr></table></figure><p>注意：Python不能通过“+”将数字与字符串拼接，你可以用str(10)将数字转为字符串再用“+”拼接<br>3、代码组<br>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。<br>我们将首行及后面的代码组称为一个子句(clause)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">10</span>:</span><br><span class="line">    a++</span><br><span class="line"><span class="keyword">elif</span> a&gt;<span class="number">10</span>:</span><br><span class="line">    a--</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>4、模块化<br>在 python 用 import 或者 from…import 来导入相应的模块。<br>将整个模块(somemodule)导入，格式为： import somemodule<br>从某个模块中导入某个函数,格式为： from somemodule import somefunction<br>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc<br>将某个模块中的全部函数导入，格式为： from somemodule import *<br>全部引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br></pre></td></tr></table></figure><p>部分引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================python from import===================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="type-与isinstance"><a href="#type-与isinstance" class="headerlink" title="type()与isinstance()"></a>type()与isinstance()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">True</span>)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="literal">True</span>,<span class="built_in">int</span>)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>type()不会认为子类是一种父类类型。<br>isinstance()会认为子类是一种父类类型</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>python中数字有四种类型：整数、布尔型、浮点数和复数：<br>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。<br>bool (布尔), 如 True。<br>float (浮点数), 如 1.23、3E-2<br>complex (复数), 如 1 + 2j、 1.1 + 2.2j</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>加 +；减 -；乘 *；除 &#x2F;；整除 &#x2F;&#x2F;；取余 %；求幂 **；<br>在混合计算时，Python会把整型转换成为浮点数</p><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>负数的实部与虚部均为float<br>创建一个复数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fushu1=<span class="number">3</span>+<span class="number">4j</span></span><br><span class="line">fushu2=<span class="built_in">complex</span>(<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># 3+4j</span></span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>布尔类型为True、False<br>布尔类是int的子类，True与1等价，False与0等价<br>布尔类型经常与逻辑运算符一起用，常见的逻辑运算符and、or、not（不同于js和c#的&amp;&amp;、||、!）</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>Python 中单引号 ‘ 和双引号 “ 使用完全相同。<br>使用三引号(‘’’ 或 “””)可以指定一个多行字符串。<br>转义符 \。<br>反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \n” 则 \n 会显示，并不是换行。<br>按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。<br>字符串可以用 + 运算符连接在一起，用 * 运算符重复。<br>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。<br>Python 中的字符串不能改变。<br>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。<br>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]<br>python的字符串不能被修改但可以重新赋值，和c#一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">4</span>]) <span class="comment"># 输出ll</span></span><br></pre></td></tr></table></figure><h2 id="字符串常用形式"><a href="#字符串常用形式" class="headerlink" title="字符串常用形式"></a>字符串常用形式</h2><p>1：插值语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;word&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;hello <span class="subst">&#123;<span class="built_in">str</span>&#125;</span>&quot;</span>)   <span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>2：不替换转义字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;hellol world \n&quot;</span>)   <span class="comment"># hello world \n</span></span><br></pre></td></tr></table></figure><p>3：f-string（字面量格式化字符串）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str2= <span class="string">&quot;word%f&quot;</span>%<span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(str2) <span class="comment"># word7.000000</span></span><br></pre></td></tr></table></figure><p>4：Unicode字符串<br>在字符串前面加上前缀u</p><h1 id="序列-list"><a href="#序列-list" class="headerlink" title="序列 list"></a>序列 list</h1><h2 id="基本理论-1"><a href="#基本理论-1" class="headerlink" title="基本理论"></a>基本理论</h2><p>序列是 Python 中最基本的数据结构。<br>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。<br>Python 有 6 个序列的内置类型，但最常见的是列表和元组。<br>列表都可以进行的操作包括索引，切片，加，乘，检查成员。<br>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。<br>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。<br>列表的数据项不需要具有相同的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">list4 = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="序列操作-append、pop"><a href="#序列操作-append、pop" class="headerlink" title="序列操作 append、pop"></a>序列操作 append、pop</h2><p>入栈、入队：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>出栈：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">list</span>.pop()</span><br></pre></td></tr></table></figure><p>出队：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">list</span>.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h1><h2 id="基本理论-2"><a href="#基本理论-2" class="headerlink" title="基本理论"></a>基本理论</h2><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。<br>元组使用小括号 ( )，列表使用方括号 [ ]。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span><br><span class="line">tup3 = <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>   <span class="comment">#  不需要括号也可以</span></span><br><span class="line"><span class="built_in">type</span>(tup3)  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>元组的使用和列表基本相同，但是不允许修改和删除元组成员</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">tup[<span class="number">0</span>] = <span class="number">10</span> <span class="comment"># 报错</span></span><br><span class="line"><span class="keyword">del</span> tup[<span class="number">0</span>] <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure><h2 id="列表与元组的选择"><a href="#列表与元组的选择" class="headerlink" title="列表与元组的选择"></a>列表与元组的选择</h2><p>如果需要一个不允许被改变的量就是用元组</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="基本理论-3"><a href="#基本理论-3" class="headerlink" title="基本理论"></a>基本理论</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值 key&#x3D;&gt;value 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中。<br>创建空字典可以直接写一个花括号{}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">12</span>,<span class="string">&quot;b&quot;</span>:<span class="number">13</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;a&quot;</span>])</span><br></pre></td></tr></table></figure><p>和c#与js中的对象不同，字典仅仅是字典而非对象，所以不能通过” . “运算符获取数值<br>可以通过len()函数获取字典的长度（键值对的数量）</p><h2 id="字典的修改与添加"><a href="#字典的修改与添加" class="headerlink" title="字典的修改与添加"></a>字典的修改与添加</h2><p>字典的内容允许修改与添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line">tinydict[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span>               <span class="comment"># 更新 Age</span></span><br><span class="line">tinydict[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;菜鸟教程&quot;</span>  <span class="comment"># 添加信息</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure><p>可以使用del删除字典或字典中的某个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">30</span>,</span><br><span class="line">    <span class="string">&quot;school&quot;</span>:<span class="string">&quot;清华大学&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">del</span> user[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">user.clear()</span><br><span class="line"><span class="keyword">del</span> user</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>字典的键名不允许修改所以应该使用不变的值作为键名，可以用数字，字符串或元组充当</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user = &#123;</span><br><span class="line">    (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>):<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="number">100</span>:<span class="number">30</span>,</span><br><span class="line">    <span class="string">&quot;school&quot;</span>:<span class="string">&quot;清华大学&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(user[(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)])</span><br><span class="line"><span class="built_in">print</span>(user[<span class="number">100</span>])</span><br></pre></td></tr></table></figure><h1 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h1><h2 id="基本理论-4"><a href="#基本理论-4" class="headerlink" title="基本理论"></a>基本理论</h2><p>集合（set）是一个无序的不重复元素序列。<br>集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。<br>可以使用大括号 { } 创建集合，元素之间用逗号 , 分隔， 或者也可以使用 set() 函数创建集合。<br>创建空集合不能直接写{}而应写成set()，因为{}默认指的是空字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mySet = &#123;<span class="string">&quot;red&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;green&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(mySet)    <span class="comment"># &#123;&#x27;green&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;&#125;</span></span><br><span class="line">myVoidSet = <span class="built_in">set</span>()   <span class="comment"># 空集合</span></span><br></pre></td></tr></table></figure><p>集合可以通过set()函数创建，set()函数的参数可以是一个可被迭代的数据<br>创建的集合的顺序可能和原数据的顺序不同，因为集合是无序的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySet = <span class="built_in">set</span>([<span class="number">11</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>])</span><br><span class="line"><span class="built_in">print</span>(mySet)    <span class="comment"># &#123;11,12,13&#125;</span></span><br></pre></td></tr></table></figure><h2 id="交集、并集"><a href="#交集、并集" class="headerlink" title="交集、并集"></a>交集、并集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面展示两个集合间的运算.</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)                               </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a-b)                              <span class="comment"># 集合a中包含而集合b中不包含的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a|b)                              <span class="comment"># 集合a或b中包含的所有元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a&amp;b)                              <span class="comment"># 集合a和b中都包含了的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a^b)                              <span class="comment"># 不同时包含于a和b的元素</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>1、set.add()方法<br>add()方法添加一个元素，它的参数是要添加的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySet = &#123;<span class="number">12</span>,<span class="number">546</span>,<span class="number">81</span>,<span class="number">154</span>,<span class="number">12</span>&#125;</span><br><span class="line">mySet.add(<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>2、set.update()方法<br>update()方法可以添加多个元素，它的参数是一个可枚举的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySet = <span class="built_in">set</span>(<span class="string">&quot;asdf&quot;</span>)</span><br><span class="line">mySet.update([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>1、set.remove()方法<br>如果删除的元素不存在，remove()方法会报错<br>2、set.discard()方法<br>如果删除的元素不存在，discard()方法不会报错</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-类</title>
      <link href="/2024/02/27/TypeScript-%E7%B1%BB/"/>
      <url>/2024/02/27/TypeScript-%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>1、public<br>在TypeScript里，成员都默认为 public。你也可以明确的将一个成员标记成public：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public name: string;</span><br><span class="line">    public constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">    public move(distanceInMeters: number) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、private<br>当成员被标记成private时，它就不能在声明它的类的外部访问。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line">new Animal(&quot;Cat&quot;).name; // Error: &#x27;name&#x27; is private;</span><br></pre></td></tr></table></figure><p>当我们比较带有private或protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rhino extends Animal &#123;</span><br><span class="line">    constructor() &#123; super(&quot;Rhino&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Employee &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line">let animal = new Animal(&quot;Goat&quot;);</span><br><span class="line">let rhino = new Rhino();</span><br><span class="line">let employee = new Employee(&quot;Bob&quot;);</span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; // Error: Animal and Employee are not compatible</span><br></pre></td></tr></table></figure><p>3、protected<br>protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animals&#123;</span><br><span class="line">  private name:string;</span><br><span class="line">  protected pname:string</span><br><span class="line">  constructor(name:string,pname:string)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.pname=name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animals&#123;</span><br><span class="line">  constructor(name:string,pname:string)&#123;</span><br><span class="line">    super(name,pname);</span><br><span class="line">    console.log(this.pname);//ok</span><br><span class="line">    console.log(this.name);//error</span><br><span class="line">    console.log(super.name);//error</span><br><span class="line">    console.log(super.pname);//error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog = new Dog(&quot;private&quot;,&quot;protected&quot;);</span><br><span class="line">console.log(dog.name);//error</span><br><span class="line">console.log(dog.pname);//error</span><br></pre></td></tr></table></figure><p>4、static<br>static声明的属性为静态属性，有类+’.’调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">  static Name=&quot;动物&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Animal.Name)</span><br></pre></td></tr></table></figure><p>5、readonly<br>使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Octopus &#123;</span><br><span class="line">    readonly name: string;</span><br><span class="line">    readonly numberOfLegs: number = 8;</span><br><span class="line">    constructor (theName: string) &#123;</span><br><span class="line">        this.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);</span><br><span class="line">dad.name = &quot;Man with the 3-piece suit&quot;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>修饰符</th><th>访问级别</th></tr></thead><tbody><tr><td>public</td><td>静态、实例、当前类、子类的属性与方法均可访问</td></tr><tr><td>static</td><td>仅可访问静态属性与方法</td></tr><tr><td>private</td><td>仅限当前类</td></tr><tr><td>protected</td><td>当前类和子类可访问</td></tr></tbody></table><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类不允许实例化，他可以给出某些属性、函数的实现，也可以不给交由子类实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(&#x27;roaming the earch...&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h1><p>类似C#中的get;set;在JS阶段就有getter和setter了</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">  private _value:number=10;</span><br><span class="line">  public get a():number&#123;</span><br><span class="line">    return this._value;</span><br><span class="line">  &#125;</span><br><span class="line">  public set a(value)&#123;</span><br><span class="line">    this._value=this._value+value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let t:Test = new Test();</span><br><span class="line">console.log(t.a);</span><br><span class="line">t.a=22;</span><br><span class="line">console.log(t.a)</span><br></pre></td></tr></table></figure><h2 id="与C-对比"><a href="#与C-对比" class="headerlink" title="与C#对比"></a>与C#对比</h2><p>C#代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        Console.WriteLine(test.Value);</span><br><span class="line">        test.Value = 22;</span><br><span class="line">        Console.WriteLine(test.Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class Test</span><br><span class="line">&#123;</span><br><span class="line">    private int _value = 10;</span><br><span class="line">    public int Value</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return this._value; &#125;</span><br><span class="line">        set &#123; this._value = value+this._value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-接口</title>
      <link href="/2024/02/27/TypeScript-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2024/02/27/TypeScript-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口的简单使用"><a href="#接口的简单使用" class="headerlink" title="接口的简单使用"></a>接口的简单使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//声明一个Student类，他的构造函数接受一个实现People接口的对象</span><br><span class="line">class Student &#123;</span><br><span class="line">    everyDay:string</span><br><span class="line">    constructor(people:People)&#123;</span><br><span class="line">        this.everyDay=`一个学生每天都要$&#123;people.eat&#125;和$&#123;people.sleep&#125;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//声明一个接口</span><br><span class="line">interface People&#123;</span><br><span class="line">    eat:string,</span><br><span class="line">    sleep:string</span><br><span class="line">&#125;</span><br><span class="line">//创建一个实现了该接口的对象</span><br><span class="line">let p = &#123;eat:&#x27;吃饭&#x27;,sleep:&#x27;睡觉&#x27;&#125;;</span><br><span class="line">//通过该对象对stu进行初始化</span><br><span class="line">let stu=new Student(p);</span><br><span class="line">console.log(stu.everyDay)</span><br></pre></td></tr></table></figure><h2 id="与C-对比"><a href="#与C-对比" class="headerlink" title="与C#对比"></a>与C#对比</h2><p>在ts中，只要实现了接口属性的对象就可以在需要这个接口的地方使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Computer&#123;</span><br><span class="line">    name:string,</span><br><span class="line">    size:number</span><br><span class="line">&#125;</span><br><span class="line">function fun(p:Computer)&#123;</span><br><span class="line">    console.log(`一台$&#123;p.size&#125;寸的$&#123;p.name&#125;电脑`)</span><br><span class="line">&#125;</span><br><span class="line">fun(&#123;name:&quot;苹果&quot;,size:14&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C#的接口不能单独使用，接口作为抽象类的进一步抽象，需要由实体类继承才可使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">internal class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Computer computer = new AppleComputer() &#123; Name=&quot;苹果&quot;,Size=14&#125;;</span><br><span class="line">        Show(computer);</span><br><span class="line">    &#125;</span><br><span class="line">    static void Show(Computer computer)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;一台&#123;computer.Size&#125;寸的&#123;computer.Name&#125;电脑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class AppleComputer : Computer</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public double Size &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal interface Computer</span><br><span class="line">&#123;</span><br><span class="line">    string Name &#123; get; set; &#125;</span><br><span class="line">    double Size &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br><span class="line">let p1: Point = &#123; x: 10, y: 20 &#125;;</span><br><span class="line">p1.x = 5; // error!</span><br></pre></td></tr></table></figure><p>TypeScript具有ReadonlyArray<code>&lt;T&gt;</code>类型，它与Array<code>&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a: number[] = [1, 2, 3, 4];</span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[0] = 12; // error!</span><br><span class="line">ro.push(5); // error!</span><br><span class="line">ro.length = 100; // error!</span><br><span class="line">a = ro; // error!</span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a= ro as number[];</span><br></pre></td></tr></table></figure><h2 id="额外检测"><a href="#额外检测" class="headerlink" title="额外检测"></a>额外检测</h2><p>如果一个接口不包含某些属性，但是依然传入了进去，就会得到一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">&#125;</span><br><span class="line">function createSquare(config: SquareConfig): void &#123;</span><br><span class="line">    console.log(config.color);</span><br><span class="line">&#125;</span><br><span class="line">createSquare(&#123;color:&#x27;白色&#x27;,width:14,other:&#x27;xxxx&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>这个错误的原因和赋值object类型的变量一样，解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1、类型断言</span><br><span class="line">createSquare(&#123;color:&#x27;白色&#x27;,width:14,other:&#x27;xxxx&#x27;&#125; as SquareConfig);</span><br><span class="line">//2、更改接口为</span><br><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">    [propName:string]:any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TS接口的函数类型与C-委托"><a href="#TS接口的函数类型与C-委托" class="headerlink" title="TS接口的函数类型与C#委托"></a>TS接口的函数类型与C#委托</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>ts的接口可以类似C#中的委托，可以通过定义ts接口来实现控制函数格式的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface funInterface &#123;</span><br><span class="line">    (a:string,b:number):boolean</span><br><span class="line">&#125;</span><br><span class="line">let fun:funInterface=(a:string,b:number)=&gt;&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">fun(&#x27;sdf&#x27;,15)</span><br></pre></td></tr></table></figure><h2 id="与C-对比-1"><a href="#与C-对比-1" class="headerlink" title="与C#对比"></a>与C#对比</h2><p>C#实现ts接口的函数类型是通过委托实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FunDelegate funDelegate = new FunDelegate(Fun);</span><br><span class="line">        funDelegate.Invoke(&quot;adsfas&quot;, 15);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static bool Fun(string a,double b)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public delegate bool FunDelegate(string a,double b);</span><br></pre></td></tr></table></figure><h1 id="TS接口的可索引的类型与C-索引器"><a href="#TS接口的可索引的类型与C-索引器" class="headerlink" title="TS接口的可索引的类型与C#索引器"></a>TS接口的可索引的类型与C#索引器</h1><h2 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h2><p>ts的接口可以类似C#中的索引器，可以通过定义ts接口来实现通过索引获取数据的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">    [index:number]:string</span><br><span class="line">&#125;</span><br><span class="line">let strArr:StringArray;</span><br><span class="line">strArr=[&#x27;hello&#x27;,&#x27;world&#x27;,&#x27;sdfasdf&#x27;];</span><br><span class="line">console.log(strArr[1]);</span><br></pre></td></tr></table></figure><h2 id="与C-对比-2"><a href="#与C-对比-2" class="headerlink" title="与C#对比"></a>与C#对比</h2><p>C#实现ts接口的可索引类型是通过索引器实现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">internal class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        StringArray stringArray = new StringArray();</span><br><span class="line">        Console.WriteLine(stringArray[0]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class StringArray</span><br><span class="line">&#123;</span><br><span class="line">    public string[] Arr=new string[] &#123;&quot;hello&quot;,&quot;world&quot;,&quot;asdfasdf&quot;&#125;;</span><br><span class="line">    public string this[int i]</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return this.Arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            this[i] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。<br>比如用数字索引去找动物可能返回一条狗这没问题<br>但是用数字索引去找狗可能返回一个动物这就有问题了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Error: indexing with a &#x27;string&#x27; will sometimes get you a Dog!</span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">    [x: number]: Animal;</span><br><span class="line">    [x: string]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TS的类实现接口"><a href="#TS的类实现接口" class="headerlink" title="TS的类实现接口"></a>TS的类实现接口</h1><p>和C#、Java一样接口可以由类实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    ring(time:number):boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    ring(time:number):boolean&#123;</span><br><span class="line">      if(time===7)return true;</span><br><span class="line">      else return false</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口进阶"><a href="#接口进阶" class="headerlink" title="接口进阶"></a>接口进阶</h1><h2 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h2><p>接口可以继承接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Me extends Student &#123;&#125;</span><br><span class="line">interface Student extends People&#123;&#125;</span><br><span class="line">interface People&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 错误：“Image”类型缺少“state”属性。</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Location &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="混合接口"><a href="#混合接口" class="headerlink" title="混合接口"></a>混合接口</h2><p>一个接口可以同时做为函数和对象使用，并带有额外的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">  (start: number): string;</span><br><span class="line">  interval: number;</span><br><span class="line">  reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">  let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class="line">  counter.interval = 123;</span><br><span class="line">  counter.reset = function () &#123; &#125;;</span><br><span class="line">  return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure><h1 id="接口解耦练习"><a href="#接口解耦练习" class="headerlink" title="接口解耦练习"></a>接口解耦练习</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface Phone&#123;</span><br><span class="line">  call(message:string):void;</span><br><span class="line">  email(message:string):void</span><br><span class="line">&#125;</span><br><span class="line">class ApplePhone implements Phone&#123;</span><br><span class="line">  call(message:string):void&#123;</span><br><span class="line">    console.log(`用苹果手机呼叫$&#123;message&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  email(message: string): void &#123;</span><br><span class="line">    console.log(`用苹果手机发送$&#123;message&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class People&#123;</span><br><span class="line">  phone:Phone;</span><br><span class="line">  toSomeone()&#123;</span><br><span class="line">    this.phone.call(&#x27;你好&#x27;)</span><br><span class="line">    this.phone.email(&#x27;hello&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(phone:Phone)&#123;</span><br><span class="line">    this.phone=phone</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let applePhone=new ApplePhone();</span><br><span class="line">let xiaohong=new People(applePhone);</span><br><span class="line">xiaohong.toSomeone();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-基本类型</title>
      <link href="/2024/02/27/TypeScript-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/02/27/TypeScript-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="为什么要设计-typescript"><a href="#为什么要设计-typescript" class="headerlink" title="为什么要设计 typescript"></a>为什么要设计 typescript</h2><p>JavaScript 是一门动态弱类型语言，对变量的类型非常宽容，而且不会在这些变量和它们的调用者间建立结构化的契约。如果你长期在没有类型约束的环境下开发，就会造成“类型思维”的缺失，养成不良的编程习惯，这也是做前端开发的短板之一，因此使用 TypeScript 对于前端开发者而言是迫切并且必要的。<br>使用 TypeScript 还能带来其他好处。比如,Visual Studio Code 具有强大的自动补全、导航和重构功能，这使得接口定义可以直接代替文档，同时也提高了开发效率，降低了维护成本。更重要的是，TypeScript 可以帮助团队重塑“类型思维”，使前端开发者从代码的编写者蜕变为代码的设计者。</p><h2 id="初识-TypeScript"><a href="#初识-TypeScript" class="headerlink" title="初识 TypeScript"></a>初识 TypeScript</h2><p>1、安装 TypeScript</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><p>2、编译 ts 文件<br>先创建一个 test.ts 文件，由于 typescript 需要先编译在运行，我们可以通过以下命令编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc test.ts</span><br></pre></td></tr></table></figure><p>编译之后会在目录中生成一个 test.js 文件。</p><h1 id="ts-类型"><a href="#ts-类型" class="headerlink" title="ts 类型"></a>ts 类型</h1><h2 id="类型概述"><a href="#类型概述" class="headerlink" title="类型概述"></a>类型概述</h2><p>ts 有以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;//boolean</span><br><span class="line">let decLiteral: number = 6;//number</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let name: string = &quot;bob&quot;;//string</span><br><span class="line">let list: number[] = [1, 2, 3];//数组</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3];//泛型数组</span><br><span class="line">let x: [string, number];//元组</span><br><span class="line">x = [&#x27;hello&#x27;, 10];</span><br><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;;//枚举</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line">let notSure: any = 4;//任意值，any类型能给任意类型的变量赋值</span><br><span class="line">notSure = &quot;maybe a string instead&quot;;</span><br><span class="line">notSure = false;</span><br><span class="line">let unusable: void = undefined;//空值，只能赋予它undefined或null</span><br><span class="line">function warnUser(): void &#123;</span><br><span class="line">    alert(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br><span class="line">let u: undefined = undefined;//undefined</span><br><span class="line">let n: null = null;//null</span><br><span class="line">function error(message: string): never &#123;//never</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。<br>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure><p>另一个为 as 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure><h2 id="any-与-unknown"><a href="#any-与-unknown" class="headerlink" title="any 与 unknown"></a>any 与 unknown</h2><p>声明为 any 的变量能给任意类型赋值，声明为 unknow 的变量不能给其他类型赋值<br>工作中不推荐使用 any</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a: any;</span><br><span class="line">a = &quot;hello&quot;;</span><br><span class="line">a = true;</span><br><span class="line">let s: string;</span><br><span class="line">s = a;</span><br><span class="line">console.log(s);//可以，打印ok</span><br><span class="line">let b: unknown;</span><br><span class="line">b = false;</span><br><span class="line">b = &#x27;world&#x27;;</span><br><span class="line">s = b;//报错</span><br></pre></td></tr></table></figure><p>unknown 类型是类型安全的 any，不能直接给别的变量赋值，如果需要给其他变量赋值应先检测 unknown 变量当前的类型或通过类型断言的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (typeof b === &quot;string&quot;) &#123;</span><br><span class="line">  s=b;</span><br><span class="line">&#125;</span><br><span class="line">s=b as string;</span><br><span class="line">s=&lt;string&gt;b</span><br></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>never 一般用在函数上，never 类型表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function error(message: string): never &#123;//never</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>声明一个 object 类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let objA :object</span><br><span class="line">objA=&#123;&#125;;</span><br><span class="line">objA=function()&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以指定一个对象必须有哪些属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let objB:&#123;name : string ,age? : number&#125;;</span><br><span class="line">objB=&#123;</span><br><span class="line">  name:&#x27;张三&#x27;,</span><br><span class="line">  age:18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上问号表示该属性可选，可以理解为 c#的可空类型。<br>上面的写法有一点缺陷，如果使用上面的写法，我们不能给 objB 添加新的属性，如果想添加新的属性可以使用以下写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let objC :&#123;name:string&#125;</span><br><span class="line">objC=&#123;name:&#x27;李四&#x27;,age:18,gender:&#x27;男&#x27;&#125;//报错，无法添加age和gender属性</span><br><span class="line">//解决方法</span><br><span class="line">let objD :&#123;name:string,[propName:string]:any&#125;</span><br><span class="line">objD=&#123;name:&#x27;王五&#x27;,age:18,gender:&#x27;男&#x27;&#125;//正确</span><br><span class="line">//propName译为属性名，不一定写propName，写成什么都行</span><br><span class="line">//[propName:string]指定属性名为string类型</span><br><span class="line">//[propName:string]:any 指定属性值为any类型</span><br></pre></td></tr></table></figure><h2 id="设置函数结构的类型"><a href="#设置函数结构的类型" class="headerlink" title="设置函数结构的类型"></a>设置函数结构的类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let f: Function;//用的少</span><br><span class="line">let fn: (a: number, b: number) =&gt; number;</span><br><span class="line">fn = function (val1, val2) &#123;</span><br><span class="line">  return val1+val2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let yz : [string,number];</span><br><span class="line">yz= [&#x27;hello&#x27;,12];</span><br><span class="line">yz=[12,&#x27;hello&#x27;];//error</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">    Red=1,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line">class Computer&#123;</span><br><span class="line">    //新语法，可以通过该语法创建对应属性</span><br><span class="line">    constructor(public name:string,public size:number,public color:Color)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let c = new Computer(&#x27;戴尔&#x27;,14.5,Color.Red);</span><br><span class="line">console.log(c.color)</span><br></pre></td></tr></table></figure><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>有点类似c#的可空类型写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let o:&#123;</span><br><span class="line">    name?:string,</span><br><span class="line">    age:number</span><br><span class="line">&#125;</span><br><span class="line">o=&#123;age:25&#125;</span><br><span class="line">function nullAble(a?:string):void&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>有点类似C语言的typedef<br>当我们用一下方式声明多个属性时需要写很多代码，我们可以给string | number |boolean类型起一个别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a: string | number |boolean</span><br><span class="line">let b: string | number |boolean</span><br><span class="line">let c: string | number |boolean</span><br></pre></td></tr></table></figure><p>type别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type myType = string | number |boolean;</span><br><span class="line">let a:myType;</span><br><span class="line">let b:myType</span><br></pre></td></tr></table></figure><p>注意：别和C#的type搞混了</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 基本类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-分包</title>
      <link href="/2024/02/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E5%8C%85/"/>
      <url>/2024/02/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h1><h2 id="分包介绍"><a href="#分包介绍" class="headerlink" title="分包介绍"></a>分包介绍</h2><p>1、概念<br>分包是把一个完整的小程序项目，按需分为不同的子包，在构建打包成不同的分包，用户在使用时按需进行加载。可以优化小程序首次启动的下载时间，在多团队开发时可以更好的解耦协作。<br>分包前，小程序项目中所有的页面和资源都被打包到了一起，导致整个项目体积过大，影响小程序首次启动的下载时间。<br>分包后，小程序由一个主包+多个分包组成。珠宝一般只包含项目的启动页面或TabBar页面，以及所有分包都需要用到的一些公共资源。分包只包含和当前分包有关的页面和私有资源。<br>2、加载规则<br>小程序启动时，默认下载主包，并启动主包内页面，tabBar页面需要放到主包。<br>当用户进入分包内某个页面时，客户端会把对应分包下载下来，完成后再进行展示。<br>3、体积限制<br>所有的分包大小不能超过20M<br>单个分包&#x2F;主包大小不能超过2M</p><h2 id="使用分包"><a href="#使用分包" class="headerlink" title="使用分包"></a>使用分包</h2><p>1、小程序目录结构：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E5%8C%85/1.jpg"><br>2、在app.json中window平级下使用subpackages节点，具体配置如下<br>app.json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;subPackages&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;root&quot;: &quot;packageA&quot;,//必须有，指定分包根目录</span><br><span class="line">    &quot;pages&quot;: [</span><br><span class="line">      &quot;pages/cat/cat&quot;,</span><br><span class="line">      &quot;pages/dag/dog&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    &quot;root&quot;: &quot;packageB&quot;,</span><br><span class="line">    &quot;pages&quot;: [</span><br><span class="line">      &quot;pages/apple/apple&quot;,</span><br><span class="line">      &quot;pages/banana/banana&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="打包原则"><a href="#打包原则" class="headerlink" title="打包原则"></a>打包原则</h2><p>1、小程序会按subpackages的配置进行分包，subpackages之外的目录将被打包到主包中。<br>2、主包也可以有自己的pages（即最外层的pages字段）。<br>3、tabBar页面必须在主包内。<br>4、分包之间不能互相嵌套。</p><h2 id="引用原则"><a href="#引用原则" class="headerlink" title="引用原则"></a>引用原则</h2><p>1、主包无法引用分包内的私有资源。<br>2、分包之间不能相互引用石油资源。<br>3、分包可以引用主包内的公共资源。</p><h1 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h1><h2 id="独立分包的概念"><a href="#独立分包的概念" class="headerlink" title="独立分包的概念"></a>独立分包的概念</h2><p>1、概述<br>独立分包本质上也是分包，不过独立分包可以独立于主包和其他分包而单独运行（比如美团和美团外卖）<br>2、和普通分包的区别<br>普通分包依赖于主包才能运行，独立分包可以独立运行。</p><h2 id="使用独立分包"><a href="#使用独立分包" class="headerlink" title="使用独立分包"></a>使用独立分包</h2><p>将上面subpackages节点中需要设置为独立分包的分包，添加independent:true节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;subPackages&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;root&quot;: &quot;package1&quot;,</span><br><span class="line">      &quot;pages&quot;: [</span><br><span class="line">        &quot;pages/cat/cat&quot;,</span><br><span class="line">        &quot;pages/dag/dog&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;independent&quot;: true,</span><br><span class="line">      &quot;name&quot;: &quot;pkg1&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      &quot;root&quot;: &quot;package2&quot;,</span><br><span class="line">      &quot;pages&quot;: [</span><br><span class="line">        &quot;pages/apple/apple&quot;,</span><br><span class="line">        &quot;pages/banana/banana&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;name&quot;: &quot;pkg2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="引用原则-1"><a href="#引用原则-1" class="headerlink" title="引用原则"></a>引用原则</h2><p>独立分包和普通分包以及主包之间是相互隔绝的，不能互相引用彼此的资源。<br>注意：独立分包不能引用主包内的公共资源！</p><h1 id="分包预下载"><a href="#分包预下载" class="headerlink" title="分包预下载"></a>分包预下载</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面的启动速度。</p><h2 id="使用分包预下载"><a href="#使用分包预下载" class="headerlink" title="使用分包预下载"></a>使用分包预下载</h2><p>在app.json中，使用preloadRule节点定义分包的预下载规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;preloadRule&quot;: &#123;</span><br><span class="line">   &quot;pages/home/home&quot;:&#123;//键值为某页面，当进入该页面触发预下载</span><br><span class="line">     &quot;network&quot;:&quot;all&quot;,//可以为all或wifi，表示在wifi模式下启动预下载</span><br><span class="line">     &quot;packages&quot;: [&quot;pkg1&quot;,&quot;pkg2&quot;]//需下载的包，可以通过对应分包的name或root来配置</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="分包预下载限制"><a href="#分包预下载限制" class="headerlink" title="分包预下载限制"></a>分包预下载限制</h2><p>分包预下载最大为2M，所有预下载的分包总和应小于2M。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 分包 </tag>
            
            <tag> 独立分包 </tag>
            
            <tag> 分包预下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-npm与数据共享</title>
      <link href="/2024/02/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-npm%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
      <url>/2024/02/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-npm%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="使用npm"><a href="#使用npm" class="headerlink" title="使用npm"></a>使用npm</h1><p>小程序使用npm有一些限制：<br>1、不支持依赖于nodejs内置库的包<br>2、不支持依赖于浏览器内置对象的包<br>3、不支持依赖于C++插件的包</p><h1 id="Vant-Weapp"><a href="#Vant-Weapp" class="headerlink" title="Vant Weapp"></a>Vant Weapp</h1><p>有赞前端团队开源的小程序UI组件库，使用MIT开源许可协议。<br>1、npm i @vant&#x2F;weapp -S –production<br>2、将 app.json 中的 “style”: “v2” 去除，小程序的新版基础组件强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。<br>3、开发者工具创建的项目，miniprogramRoot 默认为 miniprogram，package.json 在其外部，npm 构建无法正常工作。<br>需要手动在 project.config.json 内添加如下配置，使开发者工具可以正确索引到 npm 依赖的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;setting&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;packNpmManually&quot;: true,</span><br><span class="line">    &quot;packNpmRelationList&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;packageJsonPath&quot;: &quot;./package.json&quot;,</span><br><span class="line">        &quot;miniprogramNpmDistDir&quot;: &quot;./miniprogram/&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、打开微信开发者工具，点击 工具 -&gt; 构建 npm，并勾选 使用 npm 模块 选项，构建完成后，即可引入组件。<br>5、在app.json或页面.json文件中的usingComponents中添加要使用的组件，然后使用即可。</p><h2 id="CSS自定义变量"><a href="#CSS自定义变量" class="headerlink" title="CSS自定义变量"></a>CSS自定义变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>使用”–”（双横线）+变量名即可定义变量，不过要注意变量的作用域，比如定义在body标签的变量可以被body内的h1标签访问。但是定义在body内h1的变量不能被body访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">    --my-bg-color:#efefef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用自定义变量"><a href="#使用自定义变量" class="headerlink" title="使用自定义变量"></a>使用自定义变量</h3><p>在要使用的地方通过var(变量名)使用变量值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">    color:var(--my-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置Vant主题样式"><a href="#设置Vant主题样式" class="headerlink" title="设置Vant主题样式"></a>设置Vant主题样式</h2><p>可以在app.wxss中，写入CSS变量即可对全局生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//微信小程序最顶层标签是page</span><br><span class="line">page&#123;</span><br><span class="line">    --button-danger-background-color:#C00000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于Vant定义的变量叫什么名字，可以在官方文档的定制主题-&gt;配置文件中查到。</p><h1 id="API-Promise化"><a href="#API-Promise化" class="headerlink" title="API Promise化"></a>API Promise化</h1><p>小程序异步的API都是基于回调函数实现的，容易造成回调地狱的问题。我们需要将这些API转为Promise，就可以使用async await了。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>1、安装miniprogram-api-promise<br>npm install –save <a href="mailto:&#x6d;&#x69;&#110;&#105;&#x70;&#114;&#111;&#103;&#x72;&#97;&#x6d;&#45;&#x61;&#x70;&#105;&#x2d;&#x70;&#114;&#x6f;&#109;&#105;&#x73;&#x65;&#x40;&#x31;&#46;&#x30;&#x2e;&#52;">&#x6d;&#x69;&#110;&#105;&#x70;&#114;&#111;&#103;&#x72;&#97;&#x6d;&#45;&#x61;&#x70;&#105;&#x2d;&#x70;&#114;&#x6f;&#109;&#105;&#x73;&#x65;&#x40;&#x31;&#46;&#x30;&#x2e;&#52;</a><br>2、构建npm<br>3、在app.js中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//引入</span><br><span class="line">import &#123; promisifyAll &#125; from &#x27;miniprogram-api-promise&#x27;;</span><br><span class="line">//自定义p属性和wxp变量，这个p变量可以在每个页面访问到</span><br><span class="line">const wxp = wx.p=&#123;&#125;;</span><br><span class="line">//将wx的API挂载到wxp上</span><br><span class="line">promisifyAll(wx,wxp);</span><br></pre></td></tr></table></figure><p>4、使用<br>在需要的地方，比如获取用户列表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async getUserListAsync()&#123;</span><br><span class="line">  let &#123;data:res&#125; = await wx.pwx.request(&#123;</span><br><span class="line">    url: &#x27;https://xxx.com/get/userList&#x27;,</span><br><span class="line">    method:&quot;GET&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        page:1,</span><br><span class="line">        size:10</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(res)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h1 id="全局数据共享"><a href="#全局数据共享" class="headerlink" title="全局数据共享"></a>全局数据共享</h1><p>类似Vuex。<br>微信小程序里可以使用mobx-miniprogram配合mobx-miniprogram-bindings实现数据共享。<br>mobx-miniprogram用来创建Store实例对象<br>mobx-miniprogram-bindings用来把Store中的共享数据或方法，绑定到组件或页面中使用。</p><h2 id="创建store实例"><a href="#创建store实例" class="headerlink" title="创建store实例"></a>创建store实例</h2><p>创建store文件夹，在文件夹内创建store.js文件<br>store.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123;action, observable&#125; from &quot;mobx-miniprogram&quot;</span><br><span class="line">export const store = observable(&#123;</span><br><span class="line">  numA:1,</span><br><span class="line">  numB:2,</span><br><span class="line">  //计算属性，类似于vuex的getter</span><br><span class="line">  get sum()&#123;</span><br><span class="line">    return this.numA+this.numB</span><br><span class="line">  &#125;,</span><br><span class="line">  //函数需要用action创建</span><br><span class="line">  updataNumA:action(function(step)&#123;</span><br><span class="line">    this.numA += step;</span><br><span class="line">  &#125;),</span><br><span class="line">  updataNumB:action(function(step)&#123;</span><br><span class="line">    this.numB += step;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="绑定到页面"><a href="#绑定到页面" class="headerlink" title="绑定到页面"></a>绑定到页面</h2><p>1、在需要用store的页面导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStoreBindings&#125; from &quot;mobx-miniprogram-bindings&quot;</span><br><span class="line">import &#123;store&#125; from &#x27;../../store/store&#x27;</span><br></pre></td></tr></table></figure><p>2、在onLoad的时候通过createStoreBindings函数将store绑定到页面上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onLoad(options) &#123;</span><br><span class="line">    //将需要使用的store的数据绑定到this身上</span><br><span class="line">    //返回值可以用来在销毁页面时做清理工作</span><br><span class="line">    this.storeBindings = createStoreBindings(this,&#123;</span><br><span class="line">      store,</span><br><span class="line">      //指定使用的数据</span><br><span class="line">      fields:[&quot;numA&quot;,&quot;numB&quot;,&quot;sum&quot;],</span><br><span class="line">      //指定使用的函数</span><br><span class="line">      actions:[&#x27;updateNumA&#x27;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、在onUnload的时候做清理工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onUnload() &#123;</span><br><span class="line">    this.storeBindings.destroyStoreBindings();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>4、使用store内的数据与函数<br>.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;van-button type=&quot;info&quot;&gt;&#123;&#123;numB&#125;&#125;&lt;/van-button&gt;</span><br><span class="line">&lt;van-button type=&quot;warning&quot;&gt;&#123;&#123;numA&#125;&#125;&lt;/van-button&gt;</span><br></pre></td></tr></table></figure><p>由于都绑定到了this上，所以直接使用就行。</p><h2 id="绑定到组件"><a href="#绑定到组件" class="headerlink" title="绑定到组件"></a>绑定到组件</h2><p>1、在需要用store的页面导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;storeBindingsBehavior&#125; from &quot;mobx-miniprogram-bindings&quot;</span><br><span class="line">import &#123;store&#125; from &#x27;../../store/store&#x27;</span><br></pre></td></tr></table></figure><p>2、提供behaviors数组<br>在Component配置对象中，通过behaviors配置项实现自动绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">behaviors:[storeBindingsBehavior]</span><br></pre></td></tr></table></figure><p>3、提供storeBindings配置项<br>在Component配置对象中，通过storeBindings配置项指定需要的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">storeBindings:&#123;</span><br><span class="line">  store,</span><br><span class="line">  //指定使用的数据</span><br><span class="line">  fields:&#123;</span><br><span class="line">    numA:()=&gt;store.numA,</span><br><span class="line">    numB:(store)=&gt;store.numB,</span><br><span class="line">    sum:&quot;sum&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  //指定使用的函数</span><br><span class="line">  actions:&#123;</span><br><span class="line">    updateNumB:&quot;updataNumB&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> npm </tag>
            
            <tag> Vant </tag>
            
            <tag> Promise化 </tag>
            
            <tag> 全局数据共享 </tag>
            
            <tag> mobx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-组件通信</title>
      <link href="/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>在自定义组件中可以使用&lt;slot&gt;节点，用于承载组件使用者提供的wxml结构</p><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><p>自定义组件.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;view&gt;默认插槽：&lt;/view&gt;</span><br><span class="line">&lt;view&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>父组件.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;test1&gt;</span><br><span class="line">&lt;text&gt;你好&lt;/text&gt;</span><br><span class="line">&lt;/test1&gt;</span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>1、插槽默认不支持多个，如果想有多个插槽需要在自定义组件Component配置对象的options属性中配置”multipleSlots”:true。<br>2、自定义组件的&lt;slot&gt;标签指定name。<br>3、组件使用者通过slot属性，选择插入内容对应的插槽。（与vue不同，不用包在template中）<br>自定义组件.js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  options:&#123;</span><br><span class="line">    multipleSlots:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>自定义组件.wxml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;view&gt;before插槽：&lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt;&lt;/view&gt;</span><br><span class="line">&lt;view&gt;after插槽：&lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>父组件.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;test1&gt;</span><br><span class="line">&lt;text slot=&quot;after&quot;&gt;你好&lt;/text&gt;</span><br><span class="line">&lt;text slot=&quot;before&quot;&gt;世界&lt;/text&gt;</span><br><span class="line">&lt;/test1&gt;</span><br></pre></td></tr></table></figure><h1 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h1><h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h2><p>用于父组件向子组建的指定属性设置数据，仅能支持JSON兼容的数据<br>子组件在properties节点中声明对应的属性并使用：<br>自定义组件.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties:&#123;</span><br><span class="line">    age:&#123;</span><br><span class="line">      type:Number,</span><br><span class="line">      value:0</span><br><span class="line">    &#125;,</span><br><span class="line">    school:String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件使用者.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;test1 age=&quot;10&quot; school=&quot;青岛科技大学&quot;&gt;&lt;/test1&gt;</span><br></pre></td></tr></table></figure><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>用于子组件向父组件传递数据，可以传递任意数据：<br>1、在父组件js中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。<br>2、在父组件的wxml中，通过自定义事件的形式，将步骤1中定义的函数引用传递给子组件。<br>3、在子组件的js中，通过调用this.triggerEvent(“自定义事件名称”,{&#x2F;*参数对象 *&#x2F;})，将数据发送到父组件（类似vue中的emit）。<br>4、在父组件的js中，通过e.detail获取到子组件传递过来的数据（类似$on）。<br>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//.wxml</span><br><span class="line">&lt;test1 bind:doSomething=&quot;doSomething&quot;&gt;&lt;/test1&gt;</span><br><span class="line">//.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  doSomething(e)&#123;</span><br><span class="line">    console.log(e.detail)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>自定义组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//.wxml</span><br><span class="line">&lt;button bind:tap=&quot;chufa&quot;&gt;触发&lt;/button&gt;</span><br><span class="line">//.js</span><br><span class="line">Component(&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    chufa:function()&#123;</span><br><span class="line">      this.triggerEvent(&#x27;doSomething&#x27;,&#123;</span><br><span class="line">        text:&quot;做点什么&quot;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取组件实例"><a href="#获取组件实例" class="headerlink" title="获取组件实例"></a>获取组件实例</h2><p>父组件通过this.selectComponent(“id或class选择器”)获取子组件实例对象，可以直接访问子组件的任意数据和方法<br>1、在自定义组件身上添加class属性或者id属性<br>组件使用者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//.wxml</span><br><span class="line">&lt;test1 class=&quot;test1Class&quot; id=&quot;test1Id&quot;&gt;&lt;/test1&gt;</span><br><span class="line">&lt;button bind:tap=&quot;clickHandle&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">//.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  clickHandle(e)&#123;</span><br><span class="line">    let childs=this.selectAllComponents(&quot;.test1Class&quot;);</span><br><span class="line">    let child=this.selectComponent(&quot;#test1Id&quot;)</span><br><span class="line">    console.log(child.data.value)</span><br><span class="line">    child.chufa();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>自定义组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//.js</span><br><span class="line">Component(&#123;</span><br><span class="line">  methods:&#123;</span><br><span class="line">    chufa:function()&#123;</span><br><span class="line">      console.log(&quot;触发了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    value:100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="behaviors"><a href="#behaviors" class="headerlink" title="behaviors"></a>behaviors</h1><p>behaviors是小程序中用于实现组建件代码共享的特性，类似于Vue的mixins。<br>每一个behavior可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中。<br>每个组件可以引用多个behavior，behavior也可以引用其他behavior。</p><h2 id="创建behavior"><a href="#创建behavior" class="headerlink" title="创建behavior"></a>创建behavior</h2><p>调用Behavior(Object object)方法即可创建一个共享的behavior实例对象，供所有的组件使用。<br>在项目根目录创建behaviors文件夹，在这个文件夹下创建myBehavior.js文件<br>myBehavior.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = Behavior(&#123;</span><br><span class="line">data:&#123;</span><br><span class="line">  userName:&quot;张三&quot;</span><br><span class="line">&#125;,</span><br><span class="line">properties:&#123;&#125;,</span><br><span class="line">methods:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="导入behavior"><a href="#导入behavior" class="headerlink" title="导入behavior"></a>导入behavior</h2><p>在组件中使用require()方法导入需要的behavior，挂载后即可访问behavior中的数据或方法<br>自定义组件或页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//.wxml</span><br><span class="line">&lt;button bind:tap=&quot;chufa&quot;&gt;触发&lt;/button&gt;</span><br><span class="line">//.js</span><br><span class="line">const myBehavior=require(&#x27;../../behaviors/myBehaviors&#x27;)</span><br><span class="line">Component(&#123;</span><br><span class="line">  behaviors:[myBehavior],</span><br><span class="line">  methods:&#123;</span><br><span class="line">    chufa:function()&#123;</span><br><span class="line">      console.log(this.data.userName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    value:100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="behavior中所有可用的节点"><a href="#behavior中所有可用的节点" class="headerlink" title="behavior中所有可用的节点"></a>behavior中所有可用的节点</h2><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/1.jpg"></p><h2 id="同名字段的覆盖和组合规则"><a href="#同名字段的覆盖和组合规则" class="headerlink" title="同名字段的覆盖和组合规则"></a>同名字段的覆盖和组合规则</h2><p>请查阅文档。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 插槽 </tag>
            
            <tag> 组件通信 </tag>
            
            <tag> behaviors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-自定义组件</title>
      <link href="/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
      <url>/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="组件基本使用"><a href="#组件基本使用" class="headerlink" title="组件基本使用"></a>组件基本使用</h1><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>1、在项目的根目录下创建components文件夹，在components文件中定义所有自定义组件。<br>2、右键点击“新建Component”<br>3、输入组件名称之后回车，会生成4个文件：.js、.json、.wxml、.wxss</p><h2 id="引用组件"><a href="#引用组件" class="headerlink" title="引用组件"></a>引用组件</h2><h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>1、在需要使用组件的页面.json配置文件中的”usingComponents”节点中声明要引入的组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;test1&quot;:&quot;/components/test1/test1&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="全局引用组件"><a href="#全局引用组件" class="headerlink" title="全局引用组件"></a>全局引用组件</h3><p>在app.json中和window节点平级声明”usingComponents”节点，该节点以对象的形式呈现，内部写法同上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;test1&quot;:&quot;/components/test1/test1&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="组件和页面的区别"><a href="#组件和页面的区别" class="headerlink" title="组件和页面的区别"></a>组件和页面的区别</h2><p>1、组件的.json文件中需要声明”component”:true属性。<br>2、组件的.js文件中调用的是Component()函数而非Page()函数。<br>3、组件的事件处理函数需要定义到methods节点中。</p><h1 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h1><h2 id="隔离特性"><a href="#隔离特性" class="headerlink" title="隔离特性"></a>隔离特性</h2><p>1、两个组件的样式不会相互影响<br>2、小程序页面的样式不会影响组件的样式<br>3、组件的样式也不会影响小程序的样式<br>注意：app.wxss的全局样式对组件无效；只用class选择器会有样式隔离，id选择器、属性选择器、标签选择器不受样式隔离的影响。</p><h2 id="修改组件的样式隔离选项"><a href="#修改组件的样式隔离选项" class="headerlink" title="修改组件的样式隔离选项"></a>修改组件的样式隔离选项</h2><p>有时候我们希望在外界能控制组件内部的样式，这时可以通过组件options选项中的stylesolation属性修改组件的样式隔离选项。<br>组件.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  options:&#123;</span><br><span class="line">    styleIsolation:&quot;apply-shared&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>styleIsolation有以下可选参数：<br>1、isolated 默认值 启用样式隔离，class指定的样式将不会互相影响。<br>2、apply-shared 页面wxss样式将影响到自定义组件，但组件wxss中指定的样式不会影响页面。<br>3、shared 表示页面wxss将影响到自定义组件，自定义组件wxss中指定的样式也会影响页面和其他设置了apply-shared或shared的自定义组件。</p><h1 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h1><p>用于父组件向子组件传递数据</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;test1 max=&quot;10&quot;&gt;&lt;/test1&gt;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    //完整写法</span><br><span class="line">    max:&#123;</span><br><span class="line">      type:Number,//数据类型</span><br><span class="line">      value:0//默认值</span><br><span class="line">    &#125;,</span><br><span class="line">    max:Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在小程序组建中，properties属性是可读写的，data和properties指向了同一对象，所以想要修改properties属性的值也可以使用this.setData()函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.properties===this.data;//true</span><br></pre></td></tr></table></figure><h1 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a>数据监听器</h1><p>相当于VUE的watch。</p><h2 id="监听多个数据"><a href="#监听多个数据" class="headerlink" title="监听多个数据"></a>监听多个数据</h2><p>写在组件配置对象的observers属性上，以函数的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    val1:0,</span><br><span class="line">    val2:100,</span><br><span class="line">    sum:0</span><br><span class="line">  &#125;,</span><br><span class="line">  observers:&#123;</span><br><span class="line">    &quot;val1,val2&quot;:function(newVAL1,newVAL2)&#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        sum:newVAL1+newVAL2</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="监听对象的属性"><a href="#监听对象的属性" class="headerlink" title="监听对象的属性"></a>监听对象的属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    user:&#123;</span><br><span class="line">      userName:&quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  observers:&#123;</span><br><span class="line">    &quot;user.张三&quot;:(newUser)=&gt;&#123;</span><br><span class="line">      console.log(&quot;有属性变化&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="监听对象所有属性"><a href="#监听对象所有属性" class="headerlink" title="监听对象所有属性"></a>监听对象所有属性</h2><p>可以使用通配符**来监听对象中所有属性的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    user:&#123;</span><br><span class="line">      userName:&quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  observers:&#123;</span><br><span class="line">    &quot;user.**&quot;:()=&gt;&#123;</span><br><span class="line">      console.log(&quot;有属性变化&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="给某数据的某一属性赋值"><a href="#给某数据的某一属性赋值" class="headerlink" title="给某数据的某一属性赋值"></a>给某数据的某一属性赋值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    user:&#123;</span><br><span class="line">      userName:&quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeVal:function()&#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        &#x27;user.userName&#x27;:&quot;李四&quot;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="纯数据字段"><a href="#纯数据字段" class="headerlink" title="纯数据字段"></a>纯数据字段</h1><p>纯数据字段指的是哪些不用于页面渲染的data字段，该字段不会展示在页面上也不会传递给其他组件，设置为纯数据字段有利于提升页面更新的性能。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在Component构造器的options节点中，指定pureDataPattern为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  options:&#123;</span><br><span class="line">    pureDataPattern:/^_/</span><br><span class="line">  &#125;,</span><br><span class="line">  data:&#123;</span><br><span class="line">    a:true,</span><br><span class="line">    _a:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><h2 id="主要的生命周期钩子"><a href="#主要的生命周期钩子" class="headerlink" title="主要的生命周期钩子"></a>主要的生命周期钩子</h2><p>小程序组件的生命周期如下：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/1.jpg" alt="img"><br>生命周期钩子写在Component配置对象的lifetimes属性中，以对象的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  lifetimes:&#123;</span><br><span class="line">    created:function()&#123;</span><br><span class="line">      console.log(&quot;created&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    attached:function()&#123;</span><br><span class="line">      console.log(&quot;attached&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中最重要的生命周期有：<br>1、created<br>组件实例刚创建好会触发，此时不能调用setData()，一般在这个生命周期钩子中给this添加一些自定义的属性。<br>2、attached<br>组件完全初始化完毕进入页面节点树后会触发，绝大多数初始化在这时候进行。<br>3、detached<br>离开页面节点树后触发，一般在这里做清除事件监听等任务。</p><h2 id="组件所在页面的生命周期"><a href="#组件所在页面的生命周期" class="headerlink" title="组件所在页面的生命周期"></a>组件所在页面的生命周期</h2><p>当自定义组件行为依赖于页面状态时使用。<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/2.jpg"><br>组件所在页面的生命周期写在Component配置对象的pageLifeTimes属性中，以对象的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  pageLifetimes:&#123;</span><br><span class="line">    //可以在生命周期钩子里面通过this.xxx()调用methods的函数等操作</span><br><span class="line">    show:()=&gt;&#123;&#125;,</span><br><span class="line">    hide:()=&gt;&#123;&#125;,</span><br><span class="line">    resize:()=&gt;&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 自定义组件 </tag>
            
            <tag> 样式隔离 </tag>
            
            <tag> properties </tag>
            
            <tag> 数据监听器 </tag>
            
            <tag> 纯数据字段 </tag>
            
            <tag> 组件生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-WXS脚本</title>
      <link href="/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-WXS%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-WXS%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="WXS"><a href="#WXS" class="headerlink" title="WXS"></a>WXS</h1><p>WXS相当于VUE的过滤器<br>WXS语法类似JavaScript，但是两个不是一种语言<br>1、wxs有自己的数据类型<br>2、wxs不支持ES6及以上的语法<br>3、wxs遵循CommonJS规范</p><h2 id="内嵌WXS"><a href="#内嵌WXS" class="headerlink" title="内嵌WXS"></a>内嵌WXS</h2><p>编写在wxml文件中的&lt;wxs&gt;标签，必须提供module属性，指定当前wxs的模块名称，方便在wxml中访问模块中的成员。<br>js文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  /**</span><br><span class="line">   * 页面的初始数据</span><br><span class="line">   */</span><br><span class="line">  data: &#123;</span><br><span class="line">    word:&quot;hello world&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>wxml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;&#123;&#123;m1.toUpper(&quot;hello&quot;)&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view&gt;&#123;&#123;m1.toUpper(word)&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;wxs module=&quot;m1&quot;&gt;</span><br><span class="line">  module.exports.toUpper=function(str)&#123;</span><br><span class="line">    return str.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br></pre></td></tr></table></figure><h2 id="外联wxs脚本"><a href="#外联wxs脚本" class="headerlink" title="外联wxs脚本"></a>外联wxs脚本</h2><p>1、编写在.wxs文件内，我在utils文件夹下创建了tools.wxs文件<br>tools.wxs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toLower(str)&#123;</span><br><span class="line">  return str.toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">module.exports=&#123;</span><br><span class="line">  toLower:toLower</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、引入脚本<br>必须为&lt;wxs&gt;标签添加module和src属性，module指定模块名称，src指定模块路径<br>.wxml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;&#123;&#123;m2.toLower(word)&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;wxs src=&quot;../../utils/tools.wxs&quot; module=&quot;m2&quot;/&gt;</span><br></pre></td></tr></table></figure><p>.js文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  /**</span><br><span class="line">   * 页面的初始数据</span><br><span class="line">   */</span><br><span class="line">  data: &#123;</span><br><span class="line">    word:&quot;Hello World&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="wxs注意事项"><a href="#wxs注意事项" class="headerlink" title="wxs注意事项"></a>wxs注意事项</h1><p>1、wxs中定义的函数不能作为组件的事件回调函数，下面的写法是错误的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bind:tap=&quot;m2.toLower&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;wxs src=&quot;../../utils/tools.wxs&quot; module=&quot;m2&quot;/&gt;</span><br></pre></td></tr></table></figure><p>2、wxs不能调用js文件中的方法<br>3、wxs不能调用小程序提供的API函数<br>4、在IOS设备上，wxs会比js代码快2~20倍</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> WXS脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-生命周期</title>
      <link href="/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2024/02/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1、应用生命周期<br>指小程序从启动——&gt;运行——&gt;销毁的过程<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1.jpg"><br>2、页面生命周期<br>每个页面的加载——&gt;渲染——&gt;销毁的过程<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/2.jpg"></p><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><h2 id="应用的声明周期钩子"><a href="#应用的声明周期钩子" class="headerlink" title="应用的声明周期钩子"></a>应用的声明周期钩子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    //小程序初始化完成时，执行此函数，全局只触发一次，可以做一些初始化的工作</span><br><span class="line">    onLaunch:function(opt)&#123;&#125;,</span><br><span class="line">    //小程序启动，或从后台进入前台显示时触发</span><br><span class="line">    onShow:function(opt)&#123;&#125;,</span><br><span class="line">    //小程序从前台进入后台时触发</span><br><span class="line">    onHide:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3.jpg"></p><h2 id="页面的生命周期钩子"><a href="#页面的生命周期钩子" class="headerlink" title="页面的生命周期钩子"></a>页面的生命周期钩子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    onLoad:function(opt)&#123;&#125;,//监听页面加载，一个页面只调用一次</span><br><span class="line">    onShow:function()&#123;&#125;,//监听页面显示</span><br><span class="line">    onReady:function()&#123;&#125;,//监听页面初次渲染完成，一个页面只调用一次</span><br><span class="line">    onHide:function()&#123;&#125;,//监听页面隐藏</span><br><span class="line">    onUnLoad:function()&#123;&#125;,//监听页面写在，一个页面只调用一次</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 页面生命周期 </tag>
            
            <tag> 小程序生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-页面事件</title>
      <link href="/2024/02/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/"/>
      <url>/2024/02/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h1><h2 id="开启下拉刷新"><a href="#开启下拉刷新" class="headerlink" title="开启下拉刷新"></a>开启下拉刷新</h2><p>app.json中的window属性中，或者页面级别的.json文件中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;enablePullDownRefresh&quot;: true</span><br></pre></td></tr></table></figure><p>推荐为需要下拉刷新的页面单独配置。</p><h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>下拉刷新会触发onPullDownRefresh事件处理函数，可以在函数中进行下拉之后的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onPullDownRefresh() &#123;</span><br><span class="line">    console.log(&quot;用户触发了下拉刷新的操作&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用wx.stopPullDownRefresh()函数可以取消下拉状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onPullDownRefresh() &#123;</span><br><span class="line">    console.log(&quot;用户触发了下拉刷新的操作&quot;);</span><br><span class="line">    wx.stopPullDownRefresh();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="上拉触顶"><a href="#上拉触顶" class="headerlink" title="上拉触顶"></a>上拉触顶</h1><h2 id="上拉触顶距离"><a href="#上拉触顶距离" class="headerlink" title="上拉触顶距离"></a>上拉触顶距离</h2><p>app.json中的window属性中，或者页面级别的.json文件中配置上拉触顶触发距离，距离默认为50px：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;onReachBottomDistance&quot;: 100</span><br></pre></td></tr></table></figure><p>单位默认为px，可以省略。</p><h2 id="事件处理函数-1"><a href="#事件处理函数-1" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>上拉触顶会触发onReachBottom事件处理函数，可以在函数中进行上拉触顶的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onReachBottom() &#123;</span><br><span class="line">    console.log(&quot;触发了上拉触顶事件&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意：需要自己处理节流、防抖的问题</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 下拉刷新 </tag>
            
            <tag> 上拉触顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-页面导航</title>
      <link href="/2024/02/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/"/>
      <url>/2024/02/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h1><h2 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h2><p>在页面上声明一个&lt;navigator&gt;导航组件(类似router-link)，点击跳转</p><h3 id="导航到tabBar页面"><a href="#导航到tabBar页面" class="headerlink" title="导航到tabBar页面"></a>导航到tabBar页面</h3><p>使用&lt;navigator&gt;组件，必须指定url属性和open-type属性，其中url表示要跳转的页面的地址，必须以”&#x2F;“开头。open-type表示跳转方式，必须为switchTab。<br>home.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator url=&quot;/pages/order/order&quot; open-type=&quot;switchTab&quot;&gt;导航到tabBar页面&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><h3 id="导航到非tabBar页面"><a href="#导航到非tabBar页面" class="headerlink" title="导航到非tabBar页面"></a>导航到非tabBar页面</h3><p>跳转到非tabBar页面可以省略open-type属性。<br>home.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator url=&quot;/pages/merchant/merchant&quot; open-type=&quot;navigate&quot;&gt;导航到非tabBar页面&lt;/navigator&gt;</span><br><span class="line">&lt;!-- 到非tabBar页面可以省略open-type属性 --&gt;</span><br><span class="line">&lt;navigator url=&quot;/pages/merchant/merchant&quot;&gt;导航到非tabBar页面&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><h3 id="后退导航"><a href="#后退导航" class="headerlink" title="后退导航"></a>后退导航</h3><p>后退到上一页面或多级页面，则需要指定open-type属性为navigateBack，指定delta属性为数字，表示后退的层级。<br>merchant.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;返回上一页&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><p>如果delta为1，则可以省略该属性。</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>调用小程序的导航API实现页面的跳转</p><h3 id="导航到tabBar页面-1"><a href="#导航到tabBar页面-1" class="headerlink" title="导航到tabBar页面"></a>导航到tabBar页面</h3><p>wx.switchTab(Object object)：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/1.jpg"></p><h3 id="导航到非tabBar页面-1"><a href="#导航到非tabBar页面-1" class="headerlink" title="导航到非tabBar页面"></a>导航到非tabBar页面</h3><p>wx.navigateTo(Object object)：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/2.jpg"></p><h2 id="后退导航-1"><a href="#后退导航-1" class="headerlink" title="后退导航"></a>后退导航</h2><p>wx.navigateBack(Object object)：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/3.jpg"></p><h1 id="导航传参"><a href="#导航传参" class="headerlink" title="导航传参"></a>导航传参</h1><h2 id="声明式导航传参"><a href="#声明式导航传参" class="headerlink" title="声明式导航传参"></a>声明式导航传参</h2><p>home.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator url=&quot;/pages/merchant/merchant?id=1&amp;name=张三&quot; open-type=&quot;navigate&quot;&gt;导航到非tabBar页面&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><p>跳转到tabBar页面时url不支持queryString传参。</p><h2 id="编程式导航传参"><a href="#编程式导航传参" class="headerlink" title="编程式导航传参"></a>编程式导航传参</h2><p>home.wxml：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">      url: &#x27;/order/order?id=1,name=张三&#x27;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="接收传参"><a href="#接收传参" class="headerlink" title="接收传参"></a>接收传参</h2><p>页面的onLoad事件处理函数中有一个object类型的形参，这个参数记录着页面传参。<br>merchant.js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onLoad(options) &#123;</span><br><span class="line">   console.log(options)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 页面导航 </tag>
            
            <tag> 导航传参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-网络请求</title>
      <link href="/2024/02/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
      <url>/2024/02/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><h2 id="信任列表"><a href="#信任列表" class="headerlink" title="信任列表"></a>信任列表</h2><p>出于安全性考虑，小程序只能请求https类型的接口，必须将接口的域名添加到信任列表中。<br>在微信小程序管理后台——&gt;开发——&gt;开发设置——&gt;服务器域名——&gt;修改request合法域名，中添加合法域名。<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/1.jpg"></p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>wxml代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button bind:tap=&quot;getInfo&quot;&gt;发起get请求&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button bind:tap=&quot;postInfo&quot;&gt;发起post请求&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>js代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//发起get请求</span><br><span class="line">getInfo()&#123;</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: &#x27;https://www.XXX.com/api/get&#x27;,</span><br><span class="line">    method:&quot;GET&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">      name:&quot;张三&quot;,</span><br><span class="line">      age:80</span><br><span class="line">    &#125;,</span><br><span class="line">    success:(res)=&gt;&#123;</span><br><span class="line">      console.log(res.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">//发起post请求</span><br><span class="line">postInfo()&#123;</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: &#x27;https://www.XXX.com/api/post&#x27;,</span><br><span class="line">    method:&quot;POST&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">      name:&quot;张三&quot;,</span><br><span class="line">      age:80</span><br><span class="line">    &#125;,</span><br><span class="line">    success:(res)=&gt;&#123;</span><br><span class="line">      console.log(res.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在页面加载时发送请求，只需要在页面的onLoad事件中调用获取数据的函数即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onLoad(options) &#123;</span><br><span class="line">    this.getInfo();</span><br><span class="line">    this.postInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳过验证"><a href="#跳过验证" class="headerlink" title="跳过验证"></a>跳过验证</h2><p>如果后端程序员没有提供https协议的接口，为了不耽误开发的进度，我们可以在微信开发者工具中开启“开发环境不校验请求域名、TLS版本及HTTPS证书”选项，可以跳过request合法域名检测（仅限于开发环境）。<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 网络请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-配置</title>
      <link href="/2024/02/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/02/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><p>根目录app.json是全局配置文件，常用配置如下<br>1、pages：记录当前小程序所有页面的存放路径<br>2、window：全局设置小程序窗口的外观<br>3、tabBar：设置小程序底部的tabBar效果<br>4、style：是否启用新版的组件样式</p><h2 id="小程序窗口组成部分"><a href="#小程序窗口组成部分" class="headerlink" title="小程序窗口组成部分"></a>小程序窗口组成部分</h2><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/1.jpg"></p><h2 id="window配置"><a href="#window配置" class="headerlink" title="window配置"></a>window配置</h2><p>navigationBarTextStyle目前只支持black和white。<br>注意：在真正的手机上，开启下拉刷新下后无法合上，这点和模拟器上不一样，如果想实现真正的下拉刷新还需要一些配置。<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/2.jpg"></p><h2 id="tabBar配置"><a href="#tabBar配置" class="headerlink" title="tabBar配置"></a>tabBar配置</h2><p><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/3.jpg"><br>tabBar用于实现多页面的快速切换，小程序通常将其分为底部tabBar和顶部tabBar<br>注意：tabBar中只能配置最少两个最多五个的tab页签，当渲染顶部tabBar时不显示icon只显示文本。<br>tabBar的配置：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/4.jpg"><br>每个tab项的配置：<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/5.jpg"></p><h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h2><p>小程序中，app.json的window节点可以全部配置小程序中每个页面的窗口表现。<br>如果某些小程序页面想要拥有特殊的窗口表现，此时“页面级别的.json配置文件”就可以实现这种需求。<br>注意：当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准。<br><img src="/images/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/6.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 全局配置 </tag>
            
            <tag> 局部配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序-基本使用</title>
      <link href="/2024/02/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/02/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="小程序代码的构成"><a href="#小程序代码的构成" class="headerlink" title="小程序代码的构成"></a>小程序代码的构成</h1><h2 id="JSON配置文件"><a href="#JSON配置文件" class="headerlink" title="JSON配置文件"></a>JSON配置文件</h2><p>1、项目根目录的app.json<br>是当前小程序的全局配置，包含了小程序的所有页面路径、窗口外观、界面表现、底部tab等</p><table><thead><tr><th>配置项</th><th>作用</th></tr></thead><tbody><tr><td>pages</td><td>记录当前小程序所有页面的路径</td></tr><tr><td>window</td><td>全局定义小程序所有页面的背景色、文字颜色等</td></tr><tr><td>style</td><td>全局定义小程序组件所使用的样式版本</td></tr><tr><td>sitemapLocation</td><td>用来指明sitemap.json的位置</td></tr><tr><td>2、project.config.json文件</td><td></td></tr><tr><td>用来记录我们对小程序开发工具所做的个性化配置</td><td></td></tr><tr><td>配置项</td><td>作用</td></tr><tr><td>–</td><td>–</td></tr><tr><td>setting</td><td>保存了编译相关的配置</td></tr><tr><td>projectname</td><td>保存的是项目名称</td></tr><tr><td>appid</td><td>保存的是小程序的账号ID</td></tr><tr><td>3、sitemap.json文件</td><td></td></tr><tr><td>微信开开放了小程序内搜索，效果类似于PC网页的SEO。该文件用来配置小程序页面是否允许微信索引，可以修改aciton配置为disallow修改为不允许索引。</td><td></td></tr><tr><td>4、页面的.json配置文件</td><td></td></tr><tr><td>可以使用每个页面的.json文件对本页面的窗口外观进行配置，页面中的配置会覆盖app.json的window中相同的配置项</td><td></td></tr></tbody></table><h2 id="WXSS文件"><a href="#WXSS文件" class="headerlink" title="WXSS文件"></a>WXSS文件</h2><p>1、新增了rpx尺寸单位<br>2、app.wxss是全局小程序样式，页面的.wxss是页面自己的样式</p><h2 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h2><p>1、项目根目录的app.js是小程序的入口文件，通过调用App()函数来启动整个小程序。<br>2、页面的js文件通过调用Page()函数来创建并运行页面</p><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>wxml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//内容</span><br><span class="line">&lt;view&gt;&#123;&#123;value&#125;&#125;&lt;/view&gt;</span><br><span class="line">//属性</span><br><span class="line">&lt;view class=&quot;&#123;&#123;active&#125;&#125;&quot;&gt;选中&lt;/view&gt;</span><br><span class="line">/*tap事件相当于电脑的click</span><br><span class="line">需要传递的参数不能像vue一样@click=&quot;clickHandle(3)&quot;</span><br><span class="line">而是使用data-xxx属性传递，在事件对象的target.dataset.xxx可获取到*/</span><br><span class="line">&lt;button bind:tap=&quot;clickHandle&quot; data-add=&quot;&#123;&#123;3&#125;&#125;&quot;&gt;触发isClick函数&lt;/button&gt;</span><br><span class="line">&lt;button bindtap=&quot;clickHandle&quot; data-add=&quot;&#123;&#123;3&#125;&#125;&quot;&gt;同上&lt;/button&gt;</span><br><span class="line">//input事件</span><br><span class="line">&lt;input type=&quot;text&quot; bindinput=&quot;inputHandle&quot;/&gt;</span><br></pre></td></tr></table></figure><p>js文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">//data同vue2的data</span><br><span class="line">data: &#123;</span><br><span class="line">value:0</span><br><span class="line">&#125;,</span><br><span class="line">//事件处理函数写在和生命周期钩子同级的位置就行</span><br><span class="line">clickHandle(e)&#123;</span><br><span class="line">//通过this.setData修改data中的数据，简单使用实例传入一个对象，这个对象中的属性名因为data中需要被修改的属性名</span><br><span class="line">this.setData(&#123;</span><br><span class="line">value:this.data.value+e.target.dataset.add;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">inputHandle(e)&#123;</span><br><span class="line">//可以通过e.detail.value获取文本框的内容</span><br><span class="line">console.log(e.detail.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="条件渲染-wx-if"><a href="#条件渲染-wx-if" class="headerlink" title="条件渲染 wx:if"></a>条件渲染 wx:if</h2><p>JS文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line"></span><br><span class="line">isShow:true,</span><br><span class="line"></span><br><span class="line">val:2,</span><br><span class="line"></span><br><span class="line">userList:[</span><br><span class="line"></span><br><span class="line">&#123;id:1,name:&quot;张三&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#123;id:2,name:&quot;李四&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#123;id:3,name:&quot;王五&quot;&#125;,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>WXML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;isShow&#125;&#125;&quot;&gt;展示&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:else&gt;隐藏&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- else if --&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:if=&quot;&#123;&#123;val==1&#125;&#125;&quot;&gt;val=1&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;val==2&#125;&#125;&quot;&gt;val=2&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:else&gt;val=3&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- hidden --&gt;</span><br><span class="line"></span><br><span class="line">&lt;view hidden=&quot;&#123;&#123;!isShow&#125;&#125;&quot;&gt;条件为true时隐藏&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>wx:if会删除元素，hidden会修改元素样式为display:none，所以在需要频繁切换的时候建议时候用hidden减少性能消耗</p><h2 id="列表渲染-wx-for"><a href="#列表渲染-wx-for" class="headerlink" title="列表渲染 wx:for"></a>列表渲染 wx:for</h2><p>JS文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line"></span><br><span class="line">isShow:true,</span><br><span class="line"></span><br><span class="line">val:2,</span><br><span class="line"></span><br><span class="line">userList:[</span><br><span class="line"></span><br><span class="line">&#123;id:1,name:&quot;张三&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#123;id:2,name:&quot;李四&quot;&#125;,</span><br><span class="line"></span><br><span class="line">&#123;id:3,name:&quot;王五&quot;&#125;,</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>WXML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其中index默认为索引，item默认为成员 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;userList&#125;&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123;index&#125;&#125;：&#123;&#123;item.name&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 可以通过wx:for-index和wx:for-item指定索引和成员的名字 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;userList&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;user&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123;idx&#125;&#125;：&#123;&#123;user.name&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 可以像vue一样指定key，如果不指定会有一个警告，指定key的时候不能用&#123;&#123;&#125;&#125; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;userList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123;index&#125;&#125;：&#123;&#123;item.id&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h1 id="WXSS模板样式"><a href="#WXSS模板样式" class="headerlink" title="WXSS模板样式"></a>WXSS模板样式</h1><p>wxss支持rpx单位和@import样式引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//common.wxss</span><br><span class="line">.header&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">//index.wxss</span><br><span class="line">@import &quot;/common/common.wxss&quot;</span><br></pre></td></tr></table></figure><p>wxss分为全局样式和局部样式<br>当局部样式和全局样式冲突时，局部样式会覆盖全局样式<br>当局部样式的权重大于或等于全局样式的权重时才会覆盖全局的样式</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 条件渲染 </tag>
            
            <tag> 列表渲染 </tag>
            
            <tag> 模板语法 </tag>
            
            <tag> 事件绑定 </tag>
            
            <tag> 数据绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#新语法</title>
      <link href="/2024/01/03/C#-%E6%96%B0%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/01/03/C#-%E6%96%B0%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="顶级语句"><a href="#顶级语句" class="headerlink" title="顶级语句"></a>顶级语句</h1><p>1、直接在C#文件中直接编写入口方法的代码，不用类，不用Main。经典写法仍然支持。<br>2、同一个项目中只能有一个文件具有顶级语句。<br>3、顶级语句中可以直接使用await语法，也可以声明函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello, World!&quot;);</span><br><span class="line">string res = await File.ReadAllTextAsync(&quot;d:/1.txt&quot;);</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">static void test1() &#123;</span><br><span class="line">    Console.WriteLine(1);</span><br><span class="line">&#125;</span><br><span class="line">void test2() &#123;</span><br><span class="line">    Console.WriteLine(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全局using指令"><a href="#全局using指令" class="headerlink" title="全局using指令"></a>全局using指令</h1><p>1、将global修饰符添加到using前，这个命名空间就应用到整个项目，不用重复using。<br>2、通常穿件一个专门用来编写全局using代码的C#文件。<br>3、如果csproj中启用了&lt;ImplicitUsings&gt;enable&lt;&#x2F;ImplicitUsings&gt;，编译器会自动隐式增加对于System、System.Linq等常用命名空间的引入，不同各类型引入的命名空间也不一样。</p><h1 id="Using声明"><a href="#Using声明" class="headerlink" title="Using声明"></a>Using声明</h1><p>问题：<br>实现IDisposable接口的对象可以用using进行管理，如果一段代码中有很多非托管资源需要被释放的话，代码中就会存在着多个嵌套的using语句</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><p>当实现了IDisposable&#x2F;IAsyncDisposable接口的类型的变量声明前加上using，当代码执行离开变量的作用域时，对象就会被释放。<br>新建一个继承IDisposable的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace C_新语法 &#123;</span><br><span class="line">    internal class MyFIle : IDisposable &#123;</span><br><span class="line">        public void Dispose() &#123;</span><br><span class="line">            Console.WriteLine(&quot;MyFile Dispose&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using C_新语法;</span><br><span class="line">test();</span><br><span class="line">static void test() &#123;</span><br><span class="line">    using var myFile = new MyFIle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="using声明的陷阱"><a href="#using声明的陷阱" class="headerlink" title="using声明的陷阱"></a>using声明的陷阱</h2><p>以下代码会报错，因为在写文件的过程中没有关闭文件就要读文件内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using var fs = File.OpenWrite(&quot;d:/1.txt&quot;);</span><br><span class="line">using var writer = new StreamWriter(fs);</span><br><span class="line">writer.WriteLine(&quot;Hello&quot;);</span><br><span class="line">string s = File.ReadAllText(&quot;d:/1.txt&quot;);</span><br><span class="line">Console.WriteLine(s);</span><br></pre></td></tr></table></figure><h1 id="文件范围的命名空间声明"><a href="#文件范围的命名空间声明" class="headerlink" title="文件范围的命名空间声明"></a>文件范围的命名空间声明</h1><p>1、之前版本的C#中，类型必须定义在namespace中<br>2、可以改成以下写法，少用了一个大括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace C_新语法;</span><br><span class="line">internal class MyFIle : IDisposable &#123;</span><br><span class="line">    public void Dispose() &#123;</span><br><span class="line">        Console.WriteLine(&quot;MyFile Dispose&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候依然需要引入名称空间。</p><h1 id="可空引用类型"><a href="#可空引用类型" class="headerlink" title="可空引用类型"></a>可空引用类型</h1><p>1、csproj中&lt;Nullable&gt;enable&lt;Nullable&gt;启用可空引用类型检查。<br>2、在引用类型后添加”?”修饰符来声明这个类型是可空的。对于没有添加”?”修饰符的引用类型的变量，如果编译器发现存在为这个变量赋值null的可能性的时候，编译器会给出警告信息。</p><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><p>如果想让一个属性只能在构造函数中赋值，可以将set改成init，这样在类中的其他函数也不能给这个属性赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">internal class dog &#123;</span><br><span class="line">     public int Id &#123; get; private set; &#125;</span><br><span class="line">     public string Name &#123; get; init; &#125;</span><br><span class="line">     public dog(int id, string name) &#123;</span><br><span class="line">         this.Id = id;</span><br><span class="line">         this.Name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     public void SetName() &#123;</span><br><span class="line">         this.Name = &quot;aaa&quot;;//报错</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="record类型"><a href="#record类型" class="headerlink" title="record类型"></a>record类型</h1><p>record类型自动生成构造函数。<br>record类型使用Equals和&#x3D;&#x3D;会比较两个对象的内容而非地址。<br>record所有的属性都是只读的。<br>1、C#中的&#x3D;&#x3D;运算符默认是判断两个变量指向的是否是同一个对象，即使两个对象内容完全一样，也不相等。可以通过重写Equals方法、重写&#x3D;&#x3D;运算符等来解决这个问题，不过需要开发人员编写很多额外的代码。<br>2、在C#9中增加了记录（record）类型的语法，编译器会为我们自动生成Equals、GetHashcode等方法。<br>可以把record当成class来用：</p><h2 id="简单示范"><a href="#简单示范" class="headerlink" title="简单示范"></a>简单示范</h2><p>Person类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace C_新语法 &#123;</span><br><span class="line">    internal record Person(string FirstName,string LastName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = new Person(&quot;张&quot;,&quot;三&quot;);</span><br><span class="line">Person person2 = new Person(&quot;张&quot;, &quot;三&quot;);</span><br><span class="line">Console.WriteLine(person1.ToString());</span><br><span class="line">Console.WriteLine(person1==person2);//true</span><br><span class="line">Console.WriteLine(person1.Equals(person2));//true</span><br><span class="line">Console.WriteLine(Object.ReferenceEquals(person1,person2));//false，比较地址则为false</span><br></pre></td></tr></table></figure><h2 id="record深入理解"><a href="#record深入理解" class="headerlink" title="record深入理解"></a>record深入理解</h2><p>1、可以将record的部分属性设为可写的，可以使用以下方法，我们可以把普通的类改成record类，就可以让它自动生成ToString之类的方法了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">internal record Person(string FirstName,string LastName) &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样age属性就是可读可写的了<br>2、默认生成的构造函数的行为不能修改，我们可以为类型提供多个构造方法，然后其他构造方法通过this调用默认的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal record Person(string FirstName,string LastName) &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public Person(string FirstName, string LastName,int age):this(FirstName,LastName) &#123; </span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、推荐使用只读属性的类型。这样的所有属性都为只读的类型叫做“不可变类型”，可以让程序逻辑简单，减少并发访问、状态管理等麻烦。</p><h2 id="对象的副本（with写法）"><a href="#对象的副本（with写法）" class="headerlink" title="对象的副本（with写法）"></a>对象的副本（with写法）</h2><p>1、record也是普通类，变量的赋值是引用的传递。这是和结构体不同之处。<br>2、生成一个对象的副本，这个对象的其他属性值与原对象的相同，只有一个或者少数几个属性改变。<br>麻烦的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person(&quot;张&quot;, &quot;三&quot;);</span><br><span class="line">Person p2 = new Person(p1.FirstName, p1.LastName);</span><br></pre></td></tr></table></figure><p>with写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person(&quot;张&quot;, &quot;三&quot;);</span><br><span class="line">Person p2 = p1 with &#123; &#125;;//创建了p1的副本，地址不一样，内容完全一样</span><br><span class="line">Person p3 = p1 with &#123;LastName=&quot;四&quot;&#125;;//先创建p1的副本，然后修改了LastName属性，可以让部分属性不相同</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> C#新语法 </tag>
            
            <tag> using </tag>
            
            <tag> namespace </tag>
            
            <tag> init </tag>
            
            <tag> record </tag>
            
            <tag> with </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>停更一段时间</title>
      <link href="/2023/12/22/%E5%81%9C%E6%9B%B4%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4/"/>
      <url>/2023/12/22/%E5%81%9C%E6%9B%B4%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>亲爱的小伙伴们，今天是冬至啦，不知道大家有没有吃饺子。<br>由于本人面临期末考试和毕业设计等原因，技术博客不得不暂停更新一段时间，具体需要多久还不太清楚大概率年后会进行大量的更新，不过有一点可以肯定的是，我尽量在一月份的时候将之前EFCore和ASP.Net Core的坑填完，目前还有：</p><table><thead><tr><th>文章</th><th>进度</th></tr></thead><tbody><tr><td>Asp.Net Core_SignalR</td><td>未写完</td></tr></tbody></table><p>在这里想先给自己留几个坑等日后填上，之后打算做一点偏物联网和工控的内容，会涉及到Python、SQLite、modbus、mqtt、Linux之类的，我会一点一点将我学到的东西记录下来，在这里先开几个坑：</p><table><thead><tr><th>科目</th><th>内容</th></tr></thead><tbody><tr><td>Python</td><td>基本语法、多线程、File、操作数据库、网络编程</td></tr><tr><td>SQLite</td><td>数据库基本操作、索引、事务、锁等</td></tr><tr><td>Linux</td><td>Linux基本使用，借鉴韩顺平老师Linux教程</td></tr></tbody></table><p>之前的Asp.Net Core教学只涉及到Web Api，并没有用到MVC。我对MVC了解不多，要是工作不忙的话，我会从头翻一遍文档，尽量把文档中比较难理解的地方转成大白话来写几篇文章。</p><p>祝各位前程似锦！</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 停更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_表达式树</title>
      <link href="/2023/12/22/EFCore-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
      <url>/2023/12/22/EFCore-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是表达式树"><a href="#什么是表达式树" class="headerlink" title="什么是表达式树"></a>什么是表达式树</h1><p>在之前的章节中，我们用委托的形式生成了SQL语句，但是这个生成SQL语句的过程是怎么进行的呢？<br>在编译原理这门课中会讲到表达式树：<br>将一个表达式比如b.Price&gt;5，转为一个树，这棵树的根节点是大于号，左节点是成员访问符，右节点是5，根节点的左节点的左节点是b，根节点的左节点的右节点是Price，EFCore可以通过遍历这样的表达式树生成对应的SQL语句。</p><h2 id="表达式树（Expression）和委托的不同"><a href="#表达式树（Expression）和委托的不同" class="headerlink" title="表达式树（Expression）和委托的不同"></a>表达式树（Expression）和委托的不同</h2><p>我们用Expression&lt;TDelegate&gt;类型表示表达式树，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    Expression&lt;Func&lt;Article, bool&gt;&gt; e1 = a =&gt; a.Id &gt; 5;</span><br><span class="line">    //Expression&lt;Func&lt;Article,bool&gt;&gt; f2= a =&gt; &#123; a.Id &lt; 3&#125;;注意，这样的写法不被允许，因为在语句体写法中可能夹杂其他语句导致无法翻译成表达式树</span><br><span class="line">    Func&lt;Article,bool&gt; f1=a=&gt;a.Id &gt; 5;</span><br><span class="line">    using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">        ctx.Articles.Where(e1).ToArray();</span><br><span class="line">        ctx.Articles.Where(f1).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过表达式树生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT `t`.`Id`, `t`.`IsDeleted`, `t`.`Message`, `t`.`Title`</span><br><span class="line">      FROM `T_Articles` AS `t`</span><br><span class="line">      WHERE `t`.`Id` &gt; 5</span><br></pre></td></tr></table></figure><p>通过委托生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT `t`.`Id`, `t`.`IsDeleted`, `t`.`Message`, `t`.`Title`</span><br><span class="line">      FROM `T_Articles` AS `t`</span><br></pre></td></tr></table></figure><p>Expression对象储存了运算逻辑，它把对象逻辑保存成抽象语法树，可以在运行时动态获取运算逻辑，而普通的委托则没有。</p><h1 id="通过代码查看表达式树结构"><a href="#通过代码查看表达式树结构" class="headerlink" title="通过代码查看表达式树结构"></a>通过代码查看表达式树结构</h1><p>安装ExpressionTreeToString包，它给Expression对象扩展了ToString方法，可以看到所构建的表达式树。</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    Expression&lt;Func&lt;Article, bool&gt;&gt; e1 = a =&gt; a.Id &gt; 5;</span><br><span class="line">    Console.WriteLine(e1.ToString(&quot;Object notation&quot;,&quot;C#&quot;));</span><br><span class="line">    using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">        ctx.Articles.Where(e1).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var a = new ParameterExpression &#123;</span><br><span class="line">    Type = typeof(Article),</span><br><span class="line">    IsByRef = false,</span><br><span class="line">    Name = &quot;a&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Expression&lt;Func&lt;Article, bool&gt;&gt; &#123;</span><br><span class="line">    NodeType = ExpressionType.Lambda,</span><br><span class="line">    Type = typeof(Func&lt;Article, bool&gt;),</span><br><span class="line">    Parameters = new ReadOnlyCollection&lt;ParameterExpression&gt; &#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;,</span><br><span class="line">    Body = new BinaryExpression &#123;</span><br><span class="line">        NodeType = ExpressionType.GreaterThan,</span><br><span class="line">        Type = typeof(bool),</span><br><span class="line">        Left = new MemberExpression &#123;</span><br><span class="line">            Type = typeof(int),</span><br><span class="line">            Expression = a,</span><br><span class="line">            Member = typeof(Article).GetProperty(&quot;Id&quot;)</span><br><span class="line">        &#125;,</span><br><span class="line">        Right = new ConstantExpression &#123;</span><br><span class="line">            Type = typeof(int),</span><br><span class="line">            Value = 5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ReturnType = typeof(bool)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过代码动态构造表达式树"><a href="#通过代码动态构造表达式树" class="headerlink" title="通过代码动态构造表达式树"></a>通过代码动态构造表达式树</h1><p>创建出每个节点的类型，然后再给它赋值。<br>ParameterExpression、BinaryExpression、MethodCallExpression、ConstantExpression等类几乎没有提供构造函数，而且所有属性也几乎都是只读的，因此我们一般不会直接创建这些类的实例，而是调用Expression类的Parameter、MakeBinary、Call、Constant等静态方法来生成，这些静态方法我们一般称作创建表达式树的工厂方法，而属性则通过方法参数类设置。</p><h2 id="代码展示-1"><a href="#代码展示-1" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    ParameterExpression paramExprA = Expression.Parameter(typeof(Article), &quot;a&quot;);</span><br><span class="line">    ConstantExpression constExpr5 = Expression.Constant(5);//如果是布尔类型则需要用函数重载，显示指定它的类型</span><br><span class="line">    MemberExpression memExprId = Expression.MakeMemberAccess(paramExprA, typeof(Article).GetProperty(&quot;Id&quot;));</span><br><span class="line">    BinaryExpression binExpGreaterThan = Expression.GreaterThan(memExprId, constExpr5);</span><br><span class="line">    Expression&lt;Func&lt;Article,bool&gt;&gt; exprRoot = Expression.Lambda&lt;Func&lt;Article,bool&gt;&gt;(binExpGreaterThan, paramExprA);</span><br><span class="line">    using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">        ctx.Articles.Where(exprRoot).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见工厂方法请自行查找。</p><h2 id="让构建表达式树更简单"><a href="#让构建表达式树更简单" class="headerlink" title="让构建表达式树更简单"></a>让构建表达式树更简单</h2><p>我们可以使用ExpressionTreeToString包提供的ToString方法，只要将ToString方法的参数写成以下形式就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    Expression&lt;Func&lt;Article, bool&gt;&gt; e1 = a =&gt; a.Id &gt; 5;</span><br><span class="line">    Console.WriteLine(e1.ToString(&quot;Factory methods&quot;,&quot;C#&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码生成如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// using static System.Linq.Expressions.Expression</span><br><span class="line"></span><br><span class="line">var a = Parameter(</span><br><span class="line">    typeof(Article),</span><br><span class="line">    &quot;a&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Lambda(</span><br><span class="line">    GreaterThan(</span><br><span class="line">        MakeMemberAccess(a,</span><br><span class="line">            typeof(Article).GetProperty(&quot;Id&quot;)</span><br><span class="line">        ),</span><br><span class="line">        Constant(5)</span><br><span class="line">    ),</span><br><span class="line">    a</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>只需将它粘贴到代码中稍作修改即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    Console.WriteLine(&quot;请输入 1：小于，2：大于&quot;);</span><br><span class="line">    string s = Console.ReadLine();</span><br><span class="line">    var a = Parameter(typeof(Article),&quot;a&quot; );</span><br><span class="line">    BinaryExpression binaryCompare;</span><br><span class="line">    if (s == &quot;1&quot;) &#123;</span><br><span class="line">        binaryCompare = LessThan(MakeMemberAccess(a,typeof(Article).GetProperty(&quot;Id&quot;)), Constant(5));</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        binaryCompare = GreaterThan(MakeMemberAccess(a, typeof(Article).GetProperty(&quot;Id&quot;)), Constant(5));</span><br><span class="line">    &#125;</span><br><span class="line">    var expr = Lambda&lt;Func&lt;Article,bool&gt;&gt;(binaryCompare, a);</span><br><span class="line">    using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">        ctx.Articles.Where(expr).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态构建表达式树代码举例"><a href="#动态构建表达式树代码举例" class="headerlink" title="动态构建表达式树代码举例"></a>动态构建表达式树代码举例</h2><p>修改Article类，override ToString方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Article</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Title &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Comment&gt; Comments = new List&lt;Comment&gt;();//实体类中关系属性</span><br><span class="line">    public bool IsDeleted &#123; get; set; &#125;</span><br><span class="line">    public override string ToString() &#123;</span><br><span class="line">        return $&quot;ID：&#123;Id&#125;，Title：&#123;Title&#125;，Message：&#123;Message&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">using ExpressionTreeToString;</span><br><span class="line">using Interview.一对多;</span><br><span class="line">using System.Linq.Expressions;</span><br><span class="line">using static System.Linq.Expressions.Expression;</span><br><span class="line">namespace Interview</span><br><span class="line">&#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var aritcles1 = QueryAritcles(&quot;Id&quot;, 8.0);</span><br><span class="line">            foreach(var aritcle in aritcles1) &#123;</span><br><span class="line">                Console.WriteLine(&quot;====================================&quot;);</span><br><span class="line">                Console.WriteLine(aritcle);</span><br><span class="line">            &#125;</span><br><span class="line">            var aritcles2 = QueryAritcles(&quot;Title&quot;, &quot;T1&quot;);</span><br><span class="line">            foreach (var aritcle in aritcles2) &#123;</span><br><span class="line">                Console.WriteLine(&quot;====================================&quot;);</span><br><span class="line">                Console.WriteLine(aritcle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static IEnumerable&lt;Article&gt; QueryAritcles(string property,object value) &#123;</span><br><span class="line">            var a = Parameter(</span><br><span class="line">                typeof(Article),</span><br><span class="line">                &quot;a&quot;</span><br><span class="line">            );</span><br><span class="line">            var proType = typeof(Article).GetProperty(property);</span><br><span class="line">            var valType = proType.PropertyType;</span><br><span class="line">            Expression&lt;Func&lt;Article, bool&gt;&gt; expr;</span><br><span class="line">            if (value.GetType().IsPrimitive) &#123;</span><br><span class="line">                //如果是原始数据类型</span><br><span class="line">                expr = Lambda&lt;Func&lt;Article, bool&gt;&gt;(</span><br><span class="line">                    Equal(</span><br><span class="line">                        MakeMemberAccess(a, proType),</span><br><span class="line">                        Constant(System.Convert.ChangeType(value,valType))</span><br><span class="line">                    ),</span><br><span class="line">                    a</span><br><span class="line">                );</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果是复杂数据类型</span><br><span class="line">                expr = Lambda&lt;Func&lt;Article,bool&gt;&gt;(</span><br><span class="line">                    Call(</span><br><span class="line">                        MakeMemberAccess(a,proType),</span><br><span class="line">                        value.GetType().GetMethod(&quot;Contains&quot;, new[] &#123; value.GetType() &#125;),</span><br><span class="line">                        Constant(System.Convert.ChangeType(value, valType))</span><br><span class="line">                    ),</span><br><span class="line">                    a</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                return ctx.Articles.Where(expr).ToList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不用Emit生成IL代码实现Select的动态化"><a href="#不用Emit生成IL代码实现Select的动态化" class="headerlink" title="不用Emit生成IL代码实现Select的动态化"></a>不用Emit生成IL代码实现Select的动态化</h1><p>如果我们想生成只查询xxx字段的SQL语句，那么就需要使用Select()方法比如以下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.Article.Select(a=&gt;new&#123;a.Title,a.Id&#125;);</span><br><span class="line">ctx.Article.Select(a=&gt;new object[]&#123;a.Title,a.Id&#125;);</span><br></pre></td></tr></table></figure><p>运行时动态设定Select查询出来的属性，需要使用Emit技术来采用动态生成IL的技术来在运行时创建一个类。难度大！<br>我们可以使用向Select函数传递object数组的方式来实现动态创建表达式树。<br>方法：<br>把列对应的属性的访问表达式放到一个Expression数组中，然后使用Expression.NewArrayInit构建一个代表数组的NewArrayExpression表达式对象，然后就可以用这个NewArrayExpression对象供Select调用来执行了<br>具体代码如下：<br>说实话，我没太学明白怕误导大家，大家还是请看杨中科老师的视频吧。</p><h1 id="尽量避免使用动态构建表达式树"><a href="#尽量避免使用动态构建表达式树" class="headerlink" title="尽量避免使用动态构建表达式树"></a>尽量避免使用动态构建表达式树</h1><p>1、动态构建表达式树易读性差，维护麻烦。<br>2、一般只有在编写不特定于某个实体类的通用框架的时候，由于无法在编译器确定要操作的类名、属性等，所以才需要编写动态构建表达式树的代码。否则为了提高代码可读性和维护性，要尽量避免动态构建表达式树。而是用IQueryable的延迟执行特性来动态构造。</p><h2 id="System-Linq-Dynamic-Core"><a href="#System-Linq-Dynamic-Core" class="headerlink" title="System.Linq.Dynamic.Core"></a>System.Linq.Dynamic.Core</h2><p>1、安装Nuget包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package System.Linq.Dynamic.Core</span><br></pre></td></tr></table></figure><p>2、使用字符串格式的语法进行数据操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq.Dynamic.Core;</span><br><span class="line">namespace Interview</span><br><span class="line">&#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var res = ctx.Articles.Where(&quot;Id&gt;=5&quot;).Select(&quot;new(Id,Title)&quot;).ToDynamicArray();</span><br><span class="line">                foreach(var item in res) &#123;</span><br><span class="line">                    Console.WriteLine(item.Id+&quot;,&quot;+item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 表达式树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_并发控制</title>
      <link href="/2023/11/29/EFCore-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/11/29/EFCore-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="并发控制概念"><a href="#并发控制概念" class="headerlink" title="并发控制概念"></a>并发控制概念</h1><p>避免多个用户同时操作资源造成的并发冲突问题。<br>最好的解决方案：非数据库解决方案<br>数据库层面的两种策略：悲观、乐观。</p><h1 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h1><p>1、悲观并发控制一般采用行锁、表锁等排他锁对资源进行锁定，确保同时只有一个使用者操作被锁定的资源。<br>2、EF Core没有封装悲观并发控制的的使用，需要编写原生SQL语句来使用悲观并发控制。不同数据库的语法不一样。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>1、实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class House&#123;</span><br><span class="line">public long Id &#123;get;set;&#125;</span><br><span class="line">public string Name &#123;get;set;&#125;</span><br><span class="line">public string Owner &#123;get;set;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、MySql方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_Houses where Id=1 for update</span><br></pre></td></tr></table></figure><p>如果有其他的查询操作也使用for update来查询Id&#x3D;1的数据的话，那些查询会被挂起，一直到针对这条数据的更新操作完成从而释放这个行锁，代码才会继续执行。<br>3、事务：<br>锁是和事务相关的，因此通过BeginTransactionAsync()创建一个事务，并且在所有操作完成后调用CommitAsync()提交事务。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下代码会有并发冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入参赛者&quot;);</span><br><span class="line">            var o = Console.ReadLine();</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123; </span><br><span class="line">                var house = ctx.Houses.Single(h=&gt;h.Id==1);</span><br><span class="line">                if(!string.IsNullOrEmpty(house.Owner)) &#123;</span><br><span class="line">                    if (house.Owner == o) &#123;</span><br><span class="line">                        Console.WriteLine(&quot;房子已经被你抢到了&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Console.WriteLine($&quot;房子已被&#123;house.Owner&#125;占领&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                house.Owner = o;</span><br><span class="line">                Thread.Sleep(10000);</span><br><span class="line">                Console.WriteLine($&quot;恭喜&#123;o&#125;抢占成功&quot;);</span><br><span class="line">                ctx.SaveChanges();                </span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/EFCore_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/1.jpg"><br><img src="/images/EFCore_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/2.jpg"><br>更改后无并发冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入参赛者&quot;);</span><br><span class="line">            var o = Console.ReadLine();</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123; </span><br><span class="line">                using(var tx = ctx.Database.BeginTransaction()) &#123;</span><br><span class="line">                    var house = ctx.Houses.FromSqlInterpolated($&quot;select * from T_Houses where Id=1 for update&quot;).Single();//设锁</span><br><span class="line">                    if (!string.IsNullOrEmpty(house.Owner)) &#123;</span><br><span class="line">                        if (house.Owner == o) &#123;</span><br><span class="line">                            Console.WriteLine(&quot;房子已经被你抢到了&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Console.WriteLine($&quot;房子已经被【&#123;house.Owner&#125;】占了&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Console.ReadLine();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    house.Owner = o;</span><br><span class="line">                    Thread.Sleep(10000);</span><br><span class="line">                    ctx.SaveChanges();//在这里保存完成后才解锁</span><br><span class="line">                    Console.WriteLine(&quot;恭喜你抢占成功&quot;);</span><br><span class="line">                    tx.Commit();</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>悲观并发控制的使用比较简单，不同数据库的语法不一样，并且锁是独占、排他的，如果系统并发量很大的话，会严重影响性能，如果使用不当的话，甚至会导致死锁。</p><h1 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h1><h2 id="乐观并发原理"><a href="#乐观并发原理" class="headerlink" title="乐观并发原理"></a>乐观并发原理</h2><p>Update T_Houses set Owner&#x3D;新值 where Id&#x3D;1 and Owner&#x3D;旧值<br>当Update时，如果数据库中的Owner值已经被其他操作者更新为其他值，那么where语句的值就会为false，因此这个Update语句影响的行数就是0，EFCore就知道“发生并发冲突”了，因此SaveChanges()方法会抛出DbUpdateConcurrencyException异常</p><h2 id="并发令牌"><a href="#并发令牌" class="headerlink" title="并发令牌"></a>并发令牌</h2><p>如上述，关于Owner的并发操作需要进行并发控制，Owner就被称为并发令牌。<br>具体配置如下：<br>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HouseConfig : IEntityTypeConfiguration&lt;House&gt; &#123;</span><br><span class="line">        public void Configure(EntityTypeBuilder&lt;House&gt; builder) &#123;</span><br><span class="line">            builder.ToTable(&quot;T_Houses&quot;);</span><br><span class="line">            builder.Property(h=&gt;h.Owner).IsConcurrencyToken();//配置为并发令牌</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入参赛者&quot;);</span><br><span class="line">            var o = Console.ReadLine();</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var house = ctx.Houses.Single(h =&gt; h.Id == 1);</span><br><span class="line">                if (!string.IsNullOrEmpty(house.Owner)) &#123;</span><br><span class="line">                    if (house.Owner == o) &#123;</span><br><span class="line">                        Console.WriteLine(&quot;房子已经被你抢到了&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Console.WriteLine($&quot;房子已被&#123;house.Owner&#125;占领&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                house.Owner = o;</span><br><span class="line">                Thread.Sleep(10000);</span><br><span class="line">                Console.WriteLine($&quot;恭喜&#123;o&#125;抢占成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    ctx.SaveChanges();</span><br><span class="line">                &#125;catch(DbUpdateConcurrencyException ex) &#123;</span><br><span class="line">                    var entry = ex.Entries.First();</span><br><span class="line">                    var dbValues = entry.GetDatabaseValues();</span><br><span class="line">                    string newOwner = dbValues.GetValue&lt;string&gt;(nameof(house.Owner));</span><br><span class="line">                    Console.WriteLine($&quot;出现了并发冲突，被&#123;newOwner&#125;提前抢走了&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>因为悲观并发控制可能会导致数据库死锁，所以更推荐使用乐观并发控制。</p><h1 id="RowVersion"><a href="#RowVersion" class="headerlink" title="RowVersion"></a>RowVersion</h1><p>上面的例子只能给Owner这一个字段添加并发控制令牌，如果想让一个数据除了Owner字段之外的数据发生变化依然采用乐观并发控制应该怎么办，为此产生了新的方式——RowVersion</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1、对于SQLServer数据库可以在实体类中用一个byte[]类型的属性做并发令牌，然后使用IsRowVersion()把这个属性设置为RowVersion类型，这样这个属性对应的数据库列就会被设置为RowVersion类型。对于RowVersion类型的列，在每次插入或更新行时，数据库会自动为这一行的RowVersion类型的列生成新的值。<br>说简单点就是在数据库中用一个名为RowVersion的字段记录这条数据更新的版本，每次有更新这个数据的值都会不一样，在对数据进行操作的时候会使用这个字段的数据与该字段原数据进行对比，实现乐观并发控制。<br>2、在SQLServer中，timestamp和rowversion是同一种类型的不同别名，实体类byte[]——&gt;数据库rowversion或timestamp。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class House &#123;</span><br><span class="line">        public long Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public string? Owner &#123; get; set; &#125;</span><br><span class="line">        public byte[] RowVer &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HouseConfig : IEntityTypeConfiguration&lt;House&gt; &#123;</span><br><span class="line">       public void Configure(EntityTypeBuilder&lt;House&gt; builder) &#123;</span><br><span class="line">           builder.ToTable(&quot;T_Houses&quot;);</span><br><span class="line">           builder.Property(h =&gt; h.RowVer).IsRowVersion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Program.cs和以前一样。</p><h2 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h2><p>1、在MySql等数据库中虽然也有类似的timestamp类型，但是旧版MySql的timestamp类型的精度不够，并不适合在高并发的系统。<br>2、非SQLServer中，可以将并发令牌列的值更新为Guid的值。<br>3、修改其他属性值的同时，使用h1.RowVer&#x3D;Guid.NewGuid()手动更新并发令牌属性的值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、乐观并发控制能够避免悲观锁带来的性能、死锁等问题，因此推荐使用乐观并发控制而不是悲观锁。<br>2、如果有一个确定的字段要被进行并发控制，那么使用IsConcurrencyToken()把这个字段设置为并发令牌即可。<br>3、如果无法确定一个唯一的并发令牌列，那么就可以引入一个额外的属性设置为并发令牌，并且在每次更新数据的时候，手动更新这一列的值。如果用的是SQLServer数据库，那么也可以采用RowVersion列，这样就不用开发者手动在每次更新数据的时候，手动更新并发令牌的值了。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 并发控制 </tag>
            
            <tag> 乐观并发 </tag>
            
            <tag> 悲观并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_全局查询筛选器</title>
      <link href="/2023/11/20/EFCore-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E7%AD%9B%E9%80%89%E5%99%A8/"/>
      <url>/2023/11/20/EFCore-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E7%AD%9B%E9%80%89%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="全局查询筛选器"><a href="#全局查询筛选器" class="headerlink" title="全局查询筛选器"></a>全局查询筛选器</h1><p>全局查询筛选器：EF Core会自动将这个查询筛选器应用于涉及这个实体类型的所有LINQ查询。<br>场景：软删除、多租户。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>向配置类添加<br>builder.HasQueryFilter(b&#x3D;&gt;b.IsDeleted&#x3D;&#x3D;false);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ArticleConfig : IEntityTypeConfiguration&lt;Article&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Article&gt; builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Articles&quot;);</span><br><span class="line">        builder.HasQueryFilter(a =&gt; a.IsDeleted==false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="忽略全局筛选器"><a href="#忽略全局筛选器" class="headerlink" title="忽略全局筛选器"></a>忽略全局筛选器</h2><p>ctx.Articles.IgnoreQueryFilters();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                foreach (var item in ctx.Articles.Where(a =&gt; a.Id &gt; 3)) &#123;</span><br><span class="line">                    Console.WriteLine(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">                foreach (var item in ctx.Articles.IgnoreQueryFilters().Where(a =&gt; a.Id &gt; 3)) &#123;</span><br><span class="line">                    Console.WriteLine(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>全局筛选器可能会有性能缺陷的陷阱。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 全局查询筛选器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_实体数据的状态</title>
      <link href="/2023/11/20/EFCore-%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8A%B6%E6%80%81/"/>
      <url>/2023/11/20/EFCore-%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="实体状态"><a href="#实体状态" class="headerlink" title="实体状态"></a>实体状态</h1><h2 id="快照更改跟踪"><a href="#快照更改跟踪" class="headerlink" title="快照更改跟踪"></a>快照更改跟踪</h2><p>首次跟踪一个实体的时候，EF Core会创建这个实体的快照。执行SaveChanges()等方法时，EF Core将会把存储在快照中的值与实体的当前值进行比较。<br>和DbContext有关系的实体、类都会生成快照。</p><h2 id="实体的状态"><a href="#实体的状态" class="headerlink" title="实体的状态"></a>实体的状态</h2><p>已添加（Added）：DbContext正在跟踪此实体，但数据库中尚不存在该实体。<br>未改变（Unchanged）：DbContext正在跟踪此实体，该实体存在于数据库中，其属性值和从数据库中读取到的值一致，未发生改变。<br>已修改（Modified）：DbContext正在跟踪此实体，并存在于数据库中，并且其部分或全部属性值已修改。<br>已删除（Deleted）：DbContext正在跟踪此实体，并存在于数据库中，但在下次调用SaveChanges时要从数据库中删除对应数据。<br>已分离（Detached）：DbContext未跟踪该实体。</p><h2 id="查询实体状态"><a href="#查询实体状态" class="headerlink" title="查询实体状态"></a>查询实体状态</h2><p>使用DbContext的Entry()方法来获取实体在EF Core的跟踪信息对象EntityEntry。EntityEntry类的State属性代表实体的状态，通过DebugView.LongView属性可以看到实体的变化信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var items = ctx.Articles.Take(5).ToArray();</span><br><span class="line">                var a1 = items[0];</span><br><span class="line">                var a2 = items[1];</span><br><span class="line">                var a3 = items[2];</span><br><span class="line"></span><br><span class="line">                var a4 = new Article() &#123; Title = &quot;ddd&quot;, Message = &quot;xxxxxxxxxxx&quot; &#125;;</span><br><span class="line">                var a5 = new Article() &#123; Title = &quot;阿斯拉达覅见哦&quot;, Message = &quot;送到哪给下次&quot; &#125;;</span><br><span class="line"></span><br><span class="line">                a2.Title = &quot;WBG 0:3 不敌 T1&quot;;</span><br><span class="line">                ctx.Articles.Remove(a3);</span><br><span class="line">                ctx.Articles.Add(a4);</span><br><span class="line"></span><br><span class="line">                EntityEntry e1 = ctx.Entry(a1);</span><br><span class="line">                EntityEntry e2 = ctx.Entry(a2);</span><br><span class="line">                EntityEntry e3= ctx.Entry(a3);</span><br><span class="line">                EntityEntry e4 = ctx.Entry(a4);</span><br><span class="line">                EntityEntry e5 = ctx.Entry(a5);</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(e1.State);</span><br><span class="line">                Console.WriteLine(e2.DebugView.LongView);</span><br><span class="line">                Console.WriteLine(e3.State);</span><br><span class="line">                Console.WriteLine(e4.State);</span><br><span class="line">                Console.WriteLine(e5.State);</span><br><span class="line"></span><br><span class="line">                ctx.SaveChanges();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>DbContext会根据跟踪的实体的状态，在SaveChanges()的时候，根据实体状态的不同，生成Update、Delete、Insert等SQL语句，来把内存中实体的变化更新到数据库。</p><h1 id="AsNoTracking"><a href="#AsNoTracking" class="headerlink" title="AsNoTracking"></a>AsNoTracking</h1><p>如果通过DbContext查询出来的对象只是用来展示，不会发生状态改变，则可以使用AsNoTracking()来“禁用跟踪”，可以降低内存占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var items = ctx.Articles.AsNoTracking().Take(5).ToArray();</span><br><span class="line">                foreach (var item in items) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 实体状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_原生SQL语句</title>
      <link href="/2023/11/18/EFCore-%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/11/18/EFCore-%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="执行原生非查询SQL语句"><a href="#执行原生非查询SQL语句" class="headerlink" title="执行原生非查询SQL语句"></a>执行原生非查询SQL语句</h1><p>可以自己写数据库语句而非使用linq进行转换。<br>由于数据库语法的差异，所以可能无法跨越数据库使用。<br>一般用于以下情况：非查询语句、实体查询、任意SQL查询。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>使用dbCtx.Database.ExecuteSqlInterpolated()、dbCtx.Database.ExecuteSqlInterpolatedAsync()执行原生的非查询SQL语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">           using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">               await ctx.Database.ExecuteSqlInterpolatedAsync(@$&quot;INSERT INTO t_articles (Title, Message) </span><br><span class="line">                VALUES (&#x27;WBG对战T1&#x27;, &#x27;WBG与T1将于11月19日下午四点进行比赛&#x27;);&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h2><p>我们必须使用插值语法作为dbCtx.Database.ExecuteSqlInterpolated()方法的参数，因此我们可以写出以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string title = &quot;WBG对战T1&quot;;</span><br><span class="line">            string message = &quot;WBG与T1将于11月19日下午四点进行比赛&quot;;</span><br><span class="line">           using (var ctx  = new MyDbContext()) &#123;</span><br><span class="line">               await ctx.Database.ExecuteSqlInterpolatedAsync(@$&quot;INSERT INTO t_articles (Title, Message) </span><br><span class="line">                VALUES (&#123;title&#125;, &#123;message&#125;);&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>上面的代码生成的SQL语句不会出现SQL注入，其生成语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_articles (Title, Message) VALUES (@p0, @p1);</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>1、字符串内插如果赋值给string变量就是字符串拼接；如果赋值给FormattableString变量，编译器就会构造FormattableString对象。该对象有很多方法可以通过F12键进行查看。<br>2、ExecuteSqlInterpolatedAsync()的参数是FormattableString类型。因此ExecuteSqlInterpolatedAsync()会进行参数化SQL的处理。<br>3、除了ExecuteSqlInterpolated()、ExecuteSqlInterpolatedAsync()以外还有ExecuteSqlRaw()、ExecuteSqlRawAsync()也可以执行原生SQL语句，但需要开发人员自己处理查询参数等了，因此不推荐使用。</p><h1 id="执行与实体相关原生SQL查询语句"><a href="#执行与实体相关原生SQL查询语句" class="headerlink" title="执行与实体相关原生SQL查询语句"></a>执行与实体相关原生SQL查询语句</h1><h2 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h2><p>1、如果要执行的原生SQL是一个查询语句，并且查询的结果也能对应一个实体，就可以调用对应实体的DbSet的FromSqlInterpolated()方法来执行一个查询SQL语句，同样使用字符串内插来传递参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string str = &quot;%T1%&quot;;</span><br><span class="line">            FormattableString fms = @$&quot;select * from t_articles where Title like &#123;str&#125;;&quot;;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var res = ctx.Articles.FromSqlInterpolated(fms);</span><br><span class="line">                foreach(var item in res) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(item.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>2、FromSqlInterpolated()方法的返回值是IQueryable类型的，因此可以在实际执行IQueryable之前，对IQueryable类型进行进一步处理。<br>3、可以把只能用原生SQL语句写的逻辑用FromSqlInterpolated()去执行，然后把分页、分组、二次过滤、排序、Include等其他逻辑尽可能仍然使用EF Core的标准去实现。</p><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>SQL必须返回实体类型对应数据库表的所有列；<br>结果集中的列名必须与属性映射到的列名称匹配；<br>只能单表查询，不能使用Join语句进行关联查询。但是可以在查询后面使用Include()来进行关联数据的获取。</p><h1 id="执行任意原生SQL查询语句"><a href="#执行任意原生SQL查询语句" class="headerlink" title="执行任意原生SQL查询语句"></a>执行任意原生SQL查询语句</h1><p>1、FromSqlInterpolated()只能单表查询，但是在实现报表查询等操作的时候，SQL语句通常是非常复杂的，不仅要多表Join而且返回的结果一般也都不会和一个实体类完整对应。因此需要一种执行任意SQL查询语句的机制。<br>2、EF Core中允许把视图或存储过程映射为实体，因此可以把复杂的查询语句写成视图或存储过程，然后再声明对应的实体类，并且在DbContext中配置对应的DbSet。<br>3、不推荐写存储过程；项目复杂查询很对，导致视图太对、DbSet膨胀。</p><h2 id="简单使用-2"><a href="#简单使用-2" class="headerlink" title="简单使用"></a>简单使用</h2><p>dbSet.Database.GetDbConnection()获得ADO.NET Core的数据库连接对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                DbConnection conn = ctx.Database.GetDbConnection();//拿到Context对应的底层Connection对象</span><br><span class="line">                if(conn.State !=System.Data.ConnectionState.Open ) &#123; </span><br><span class="line">                    await conn.OpenAsync();</span><br><span class="line">                &#125;</span><br><span class="line">                using(var cmd =  conn.CreateCommand()) &#123;</span><br><span class="line">                    cmd.CommandText=&quot;select Price,Count(*) from T_Articles group by Price&quot;;</span><br><span class="line">                    using (var reader = await cmd.ExecuteReaderAsync()) &#123;</span><br><span class="line">                        while(await reader.ReadAsync()) &#123;</span><br><span class="line">                            double price = reader.GetDouble(0);</span><br><span class="line">                            int count = reader.GetInt32(1);</span><br><span class="line">                            await Console.Out.WriteLineAsync($&quot;&#123;price&#125;:&#123;count&#125;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>不建议直接使用ADO.NET Core，可以使用Dapper写任意原生的SQL语句。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般Linq操作就够了，尽量不写原生SQL；<br>1、非查询SQL用ExecuteSqlInterpolated()；<br>2、针对实体的SQL查询用FromSqlInterpolated()；<br>3、复杂SQL查询用ADO.NET的方式或者Dapper等；</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 原生SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_IQueryable</title>
      <link href="/2023/11/16/EFCore-IQueryable/"/>
      <url>/2023/11/16/EFCore-IQueryable/</url>
      
        <content type="html"><![CDATA[<h1 id="IQueryable与IEnumerable"><a href="#IQueryable与IEnumerable" class="headerlink" title="IQueryable与IEnumerable"></a>IQueryable与IEnumerable</h1><h2 id="不同的Where方法"><a href="#不同的Where方法" class="headerlink" title="不同的Where方法"></a>不同的Where方法</h2><p>1、对于普通集合和DbSet调用的Where方法，虽然用起来一样，但是“转到定义”后看到的是不同的方法。<br>2、普通集合的版本（IEnumerable）是在内存中过滤（客户端评估），而IQueryable版本则是把查询操作翻译成SQL语句（服务器端评估）。<br>如果强制使用IEnumerable的版本，两个方式会生成不同的SQL语句。<br>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">            //IQueryable&lt;Comment&gt; comments = ctx.Comments;</span><br><span class="line">            //IQueryable&lt;Comment&gt; cmts = comments.Where(c =&gt; c.Message.Contains(&quot;人性&quot;));</span><br><span class="line">            IEnumerable&lt;Comment&gt; comments = ctx.Comments;</span><br><span class="line">            IEnumerable&lt;Comment&gt; cmts = comments.Where(c =&gt; c.Message.Contains(&quot;人性&quot;));</span><br><span class="line">            foreach (var c in cmts) &#123;</span><br><span class="line">                Console.WriteLine(c.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IEnumerable版本：<br>把所有数据放到客户端再进行筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT `t`.`Id`, `t`.`Message`, `t`.`TheArticleId`</span><br><span class="line">      FROM `T_Comments` AS `t`</span><br></pre></td></tr></table></figure><p>IQueryable版本：<br>数据在数据库进行筛选然后传给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT `t`.`Id`, `t`.`Message`, `t`.`TheArticleId`</span><br><span class="line">     FROM `T_Comments` AS `t`</span><br><span class="line">     WHERE `t`.`Message` LIKE &#x27;%人性%&#x27;</span><br></pre></td></tr></table></figure><h2 id="有时需要客户端评估（很少）"><a href="#有时需要客户端评估（很少）" class="headerlink" title="有时需要客户端评估（很少）"></a>有时需要客户端评估（很少）</h2><p>1、如果有些语句在服务器执行时占用资源特别多，可以考虑采用客户端评估。<br>2、如果有些语句特别复杂，无法转为SQL语句，可以考虑采用客户端评估。</p><h1 id="IQueryable延迟执行"><a href="#IQueryable延迟执行" class="headerlink" title="IQueryable延迟执行"></a>IQueryable延迟执行</h1><p>IQueryable只查询不遍历，就不会执行SQL语句。<br>IQueryable表示一个可以放到数据库执行的操作，它没有立即执行只是可以被执行。<br>对IQueryable接口调用非终结方法时不会执行查询，而调用终结方法时会立即执行查询。<br>终结方法：遍历、ToArray()、ToList()、Min()、Max()、Count()等。<br>非终结方法：GroupBy()、OrderBy()、Include()、Skip()、Take()等。<br>简单判断：如果一个方法的返回值为IQueryable那么这个操作一般为非终结方法，否则就是终结方法。<br>IQueryable是可以复用的，所以在实际执行终结方法之前可以分部构建IQueryable，常用于用户自定义动态查询规则。</p><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>通过Skip(3).Take(8)进行分页查询，最好显式指定排序规则。<br>需要知道满足条件的数据的总条数可以通过LongCount()，因为Count()返回的数据类型是int，数据过多的时候会超出int的最大值，而LongCount()获取的数据类型是long。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    PrintData(3, 3);</span><br><span class="line"> &#125;</span><br><span class="line">static void PrintData(int PageIndex,int PageSize) &#123;</span><br><span class="line">    using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">        var ctxs = ctx.OrgUnits.Where(o =&gt; o.Name.Contains(&quot;秋华&quot;));</span><br><span class="line">        var result = ctxs.Skip((PageIndex-1)*PageSize).Take(PageSize);</span><br><span class="line">        foreach (var res in result) &#123;</span><br><span class="line">            Console.WriteLine(res.Name);</span><br><span class="line">        &#125;</span><br><span class="line">        long PageLength = (long)Math.Ceiling(ctx.OrgUnits.LongCount()*1.0/PageSize);</span><br><span class="line">        Console.WriteLine($&quot;总页数：&#123;PageLength&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IQueryable一次性加载"><a href="#IQueryable一次性加载" class="headerlink" title="IQueryable一次性加载"></a>IQueryable一次性加载</h1><h2 id="DataReader与DataTable"><a href="#DataReader与DataTable" class="headerlink" title="DataReader与DataTable"></a>DataReader与DataTable</h2><p>DataReader：分批从数据库服务器读取数据。内存占用小、DB连接占用时间长；<br>DataTable：把所有数据都一次性从数据库服务器都加载到客户端内存中。内存占用大，节省DB连接；<br>IQueryable内部就是在调用DataReader进行数据读取。</p><h2 id="如何一次性加载"><a href="#如何一次性加载" class="headerlink" title="如何一次性加载"></a>如何一次性加载</h2><p>使用IQueryable的ToArray()、ToArrayAsync()、ToList()、ToListAsync()等方法可以一次性加载数据到内存中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                foreach (var item in ctx.OrgUnits.ToList()) &#123;</span><br><span class="line">                    Console.WriteLine(item.Name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="何时需要一次性加载"><a href="#何时需要一次性加载" class="headerlink" title="何时需要一次性加载"></a>何时需要一次性加载</h2><p>1：遍历IQueryable并且进行数据处理的过程很耗时，为了不占用服务器资源时可以使用。<br>2：如果方法需要返回查询结果，并且在方法里销毁DbContext的话，是不能返回IQueryable的。必须一次性加载返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           var res = GetOrgUnits();</span><br><span class="line">            foreach (var unit in res) &#123;</span><br><span class="line">                //由于IQueryable是延迟执行的，所以res并没有结果而是在遍历时去查询，但是查询时res对应的DB连接已经被断开</span><br><span class="line">                Console.WriteLine(unit.Name);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        static IQueryable&lt;OrgUnit&gt; GetOrgUnits() &#123;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                return ctx.OrgUnits.Where(o=&gt;o.Name.Contains(&quot;秋华&quot;));</span><br><span class="line">                //注意：出了using就会销毁MyDbContext实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>3：多个IQueryable的遍历嵌套。很多数据库的ADO.NET Core Provider是不支持多个DataReader同时执行的。<br>在SqlServer中可以通过在连接字符串中添加MultipleActiveResultSets&#x3D;true使其支持DataReader同时执行。对于别的数据库可以转换为DataTable模式再执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">          using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">               foreach (var item in ctx.Articles.ToList()) &#123;</span><br><span class="line">                   Console.WriteLine(item.Title);</span><br><span class="line">                   foreach(var item2 in ctx.Teachers.ToList()) &#123;</span><br><span class="line">                       Console.WriteLine(item2.Name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="EF-Core的异步方法"><a href="#EF-Core的异步方法" class="headerlink" title="EF Core的异步方法"></a>EF Core的异步方法</h1><h2 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h2><p>1、SaveChanges()、SaveChangesAsync()<br>2、异步方法大部分是定义在Microsoft.EntityFrameworkCore这个名称空间下EntityFrameworkQueryableExtensions等类中的拓展方法，记得using.。<br>3、一般终结方法都有对应的异步方法，而非终结方法如GroupBy、OrderBy、Join、Where等非终结方法没有异步方法。</p><h2 id="异步遍历IQueryable"><a href="#异步遍历IQueryable" class="headerlink" title="异步遍历IQueryable"></a>异步遍历IQueryable</h2><p>1、ToListAsync()、ToArrayAsync()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">           using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">                foreach (var item in await ctx.Articles.ToListAsync()) &#123;</span><br><span class="line">                    Console.WriteLine(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>2、await foreach+AsAsyncEnumerable()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">           using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">                await foreach (var item in ctx.Articles.AsAsyncEnumerable()) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>一般没必要异步遍历。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> IQueryable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_一对一与多对多</title>
      <link href="/2023/11/16/EFCore-%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A/"/>
      <url>/2023/11/16/EFCore-%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h1><p>采购申请订单——&gt;采购订单<br>订单——&gt;快递单<br>我将以订单——&gt;快递单为例进行讲解。<br>一对一关系必须显示地在其中一个实体类中声明一个外键属性。<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Delivery &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string CampanyName &#123; get; set; &#125;</span><br><span class="line">    public string Number &#123; get; set; &#125;</span><br><span class="line">    public Order Order &#123; get; set; &#125;</span><br><span class="line">    public long OrderId &#123; get; set; &#125;//显式建立外键</span><br><span class="line">&#125;</span><br><span class="line">public class Order &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public Delivery Delivery &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">internal class DeliveryConfig : IEntityTypeConfiguration&lt;Delivery&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Delivery&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Deliverys&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class OrderConfig : IEntityTypeConfiguration&lt;Order&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Order&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Orders&quot;);</span><br><span class="line">        builder.HasOne&lt;Delivery&gt;(o=&gt;o.Delivery).WithOne(d=&gt;d.Order).HasForeignKey&lt;Delivery&gt;(d=&gt;d.OrderId).IsRequired();//添加外键</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">            Order o1 = new Order &#123; Name = &quot;手机&quot; &#125;;</span><br><span class="line">            Delivery d1 = new Delivery &#123; Number=&quot;0001&quot;, CampanyName =&quot;顺丰快递&quot;,Order =  o1 &#125;;</span><br><span class="line">            ctx.Deliveries.Add(d1);</span><br><span class="line">            ctx.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><p>老师——学生<br>EF Core 5.0开始正式支持多对多。<br>多对多必然产生中间表。<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher</span><br><span class="line">&#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Student&gt; Student &#123; get; set; &#125; = new List&lt;Student&gt;();</span><br><span class="line">&#125;</span><br><span class="line">public class Student</span><br><span class="line">&#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Teacher&gt; Teachers &#123; get; set; &#125; = new List&lt;Teacher&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class TeacherConfig : IEntityTypeConfiguration&lt;Teacher&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Teacher&gt; builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Teachers&quot;);</span><br><span class="line">        builder.HasMany(t =&gt; t.Student).WithMany(s =&gt; s.Teachers).UsingEntity(j =&gt; j.ToTable(&quot;T_Teachers_Students&quot;));//最好指定一下中间表的表名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class StudentConfig : IEntityTypeConfiguration&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Student&gt; builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Students&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">            /*</span><br><span class="line">            var s1 = new Student &#123; Name = &quot;张三&quot; &#125;;</span><br><span class="line">            var s2 = new Student &#123; Name = &quot;李四&quot; &#125;;</span><br><span class="line">            var s3 = new Student &#123; Name = &quot;王五&quot; &#125;;</span><br><span class="line">            var t1 = new Teacher &#123; Name = &quot;刘老师&quot; &#125;;</span><br><span class="line">            var t2 = new Teacher &#123; Name = &quot;杨老师&quot; &#125;;</span><br><span class="line">            var t3 = new Teacher &#123; Name = &quot;高老师&quot; &#125;;</span><br><span class="line">            s1.Teachers.Add(t1);</span><br><span class="line">            s1.Teachers.Add(t2);</span><br><span class="line">            s2.Teachers.Add(t3);</span><br><span class="line">            s2.Teachers.Add(t1);</span><br><span class="line">            s3.Teachers.Add(t2);</span><br><span class="line">            ctx.Students.Add(s1);</span><br><span class="line">            ctx.Students.Add(s2);</span><br><span class="line">            ctx.Students.Add(s3);</span><br><span class="line">            ctx.SaveChanges();*/</span><br><span class="line">            var teachers = ctx.Teachers.Include(t =&gt; t.Student).ToList();</span><br><span class="line">            foreach (var teacher in teachers) &#123;</span><br><span class="line">                Console.WriteLine(teacher.Name);</span><br><span class="line">                foreach (var student in teacher.Student) &#123;</span><br><span class="line">                    Console.WriteLine(&#x27;\t&#x27;+student.Name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 一对一 </tag>
            
            <tag> 多对多 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_一对多</title>
      <link href="/2023/11/11/EFCore-%E4%B8%80%E5%AF%B9%E5%A4%9A/"/>
      <url>/2023/11/11/EFCore-%E4%B8%80%E5%AF%B9%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core一对多"><a href="#EF-Core一对多" class="headerlink" title="EF Core一对多"></a>EF Core一对多</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、实体类中关系属性<br>2、FluentAPI关系配置<br>3、使用关系操作</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>目的：数据库保存文章与评论，一篇文章对应多条评论<br>1、实体类中关系属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Article &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Title &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Comment&gt; Comments = new List&lt;Comment&gt; ();//实体类中关系属性</span><br><span class="line">&#125;</span><br><span class="line">public class Comment &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public Article TheArticle &#123; get; set; &#125;//实体类中关系属性</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、FluentAPI关系配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">internal class CommentConfig : IEntityTypeConfiguration&lt;Comment&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Comment&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Comments&quot;);</span><br><span class="line">        builder.HasOne&lt;Article&gt;(e =&gt; e.TheArticle).WithMany(e =&gt; e.Comments).IsRequired();//FluentAPI关系配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ArticleConfig : IEntityTypeConfiguration&lt;Article&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Article&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Articles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用关系操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        using(var db = new MyDbContext()) &#123;</span><br><span class="line">            Article article = new Article();</span><br><span class="line">            article.Title = &quot;震惊！母猪为何深夜惨叫&quot;;</span><br><span class="line">            article.Message = &quot;近日，家在石家庄村里的张老汉发现。。。。。。&quot;;</span><br><span class="line">            Comment com1 = new Comment();</span><br><span class="line">            Comment com2 = new Comment();</span><br><span class="line">            com1.Message = &quot;标题党真讨厌&quot;;</span><br><span class="line">            com2.Message = &quot;到底是人性的扭曲还是。。。。。。&quot;;</span><br><span class="line">            article.Comments.Add(com1);</span><br><span class="line">            article.Comments.Add(com2);</span><br><span class="line">            db.Articles.Add(article);</span><br><span class="line">            db.SaveChanges();</span><br><span class="line">            //有了HasXXX().WithXXX()，就相当于创建了外检关联，EF Core 会自动做好一些配置，不需要以下的写法了</span><br><span class="line">            //Article article = new Article();</span><br><span class="line">            //article.Title = &quot;震惊！母猪为何深夜惨叫&quot;;</span><br><span class="line">            //article.Message = &quot;近日，家在石家庄村里的张老汉发现。。。。。。&quot;;</span><br><span class="line">            //Comment com1 = new Comment();</span><br><span class="line">            //Comment com2 = new Comment();</span><br><span class="line">            //com1.Message = &quot;标题党真讨厌&quot;;</span><br><span class="line">            //com2.Message = &quot;到底是人性的扭曲还是。。。。。。&quot;;</span><br><span class="line">            //com1.TheArticle = article;</span><br><span class="line">            //com2.TheArticle= article;</span><br><span class="line">            //article.Comments.Add(com1);</span><br><span class="line">            //article.Comments.Add(com2);</span><br><span class="line">            //db.Articles.Add(article);</span><br><span class="line">            //db.Comments.Add(com1);</span><br><span class="line">            //db.Comments.Add(com2);</span><br><span class="line">            //db.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要显式为Comment对象的Article属性赋值（赋值也不会错），也不需要显示地把新创建的Comment类型的对象添加到DbContext中。EF Core会“顺杆爬”。</p><h2 id="一对多关系数据的获取"><a href="#一对多关系数据的获取" class="headerlink" title="一对多关系数据的获取"></a>一对多关系数据的获取</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using(var db = new MyDbContext()) &#123;</span><br><span class="line">            Article article1 = db.Articles.Single(e =&gt; e.Id == 1);</span><br><span class="line">            foreach (Comment cmt in article1.Comments) &#123;</span><br><span class="line">                Console.WriteLine(cmt.Message);//这句话没有输出评论，因为生成的Sql语句为以下内容</span><br><span class="line">                //SELECT `t`.`Id`, `t`.`Message`, `t`.`Title` FROM `T_Articles` AS `t` WHERE `t`.`Id` = 1 LIMIT 2</span><br><span class="line">                //没有去Comments表中查数据</span><br><span class="line">            &#125;</span><br><span class="line">            //解决方法如下，添加Include，表示与XXX表进行连接</span><br><span class="line">            Article article2 = db.Articles.Include(e =&gt; e.Comments).Single(e =&gt; e.Id == 1);</span><br><span class="line">            foreach (Comment cmt in article1.Comments) &#123;</span><br><span class="line">                Console.WriteLine(cmt.Message);</span><br><span class="line">            &#125;</span><br><span class="line">            Comment cmt1 = db.Comments.Single(e =&gt; e.Id == 2);</span><br><span class="line">            Console.WriteLine(cmt1.Message);</span><br><span class="line">            Console.WriteLine(cmt1.TheArticle.Id + &quot;,&quot; + cmt1.TheArticle.Title);//错误，与上面同理，没有查询Article表</span><br><span class="line">            Comment cmt2 = db.Comments.Include(e =&gt; e.TheArticle).Single(e =&gt; e.Id == 2);</span><br><span class="line">            Console.WriteLine(cmt2.TheArticle.Id + &quot;,&quot; + cmt2.TheArticle.Title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用Include则不会去关联的表中进行查询。</p><h2 id="额外的外键字段"><a href="#额外的外键字段" class="headerlink" title="额外的外键字段"></a>额外的外键字段</h2><p>EF Core会在数据表中建外键列，如果需要获取外键列的值，就需要做关联查询，效率低，因而需要一种不需要Join直接获取外键列的值的方法。<br>比如：<br>我就想获取评论对应文章的Id，但是我用了Include就会创建一个Join连接的Sql语句，这样没有必要。<br>解决方法：<br>1、在实体类中显示声明一个外键属性<br>2、关系配置中通过HasForeignKey(c&#x3D;&gt;c.ArticleId)显式指定该属性为外键。<br>3、除非必要，否则不用声明，因为会引入重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Comment &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public Article TheArticle &#123; get; set; &#125;//实体类中关系属性</span><br><span class="line">    public int TheArticleId &#123; get; set; &#125;//显式指定外键</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal class CommentConfig : IEntityTypeConfiguration&lt;Comment&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Comment&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Comments&quot;);</span><br><span class="line">        builder.HasOne&lt;Article&gt;(e =&gt; e.TheArticle).WithMany(e =&gt; e.Comments).HasForeignKey(e =&gt; e.TheArticleId).IsRequired();//FluentAPI关系配置，显式指定外键字段</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Select函数会在必要的情况下自动进行连接查询，所以有了Select就可以不用Include函数了。</p><h1 id="单向导航属性"><a href="#单向导航属性" class="headerlink" title="单向导航属性"></a>单向导航属性</h1><h2 id="双向导航属性的不足"><a href="#双向导航属性的不足" class="headerlink" title="双向导航属性的不足"></a>双向导航属性的不足</h2><p>如上文例子，每一条评论通过TheArticleId可以连接到T_Articles表，每一篇文章可以通过Comments连接到T_Commnets表，这样的导航称为单向导航。<br>如果有一个请假系统，有一个T_UserInfos表记录用户姓名、Id信息，有一个T_Leaves表记录用户请假信息比如：请假人、审批人1、审批人2、审批人3……我们就需要在T_UserInfos表中建立多个字段用来管理审批人123，这样很麻烦，为此我们需要单向导航属性</p><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>不设置反向的属性，在配置的时候WithMany()不设置参数即可<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Leave &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public DateTime Time &#123; get; set; &#125;</span><br><span class="line">    public User Requester &#123; get; set; &#125;//申请人</span><br><span class="line">    public User Approver1 &#123; get; set; &#125;//审批人1</span><br><span class="line">    public User Approver2 &#123; get; set; &#125;//审批人2</span><br><span class="line">    public User Approver3 &#123; get; set; &#125;//审批人3</span><br><span class="line">    public string Remarks &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class User &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserConfig : IEntityTypeConfiguration&lt;User&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;User&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Users&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LeaveConfig : IEntityTypeConfiguration&lt;Leave&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Leave&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Leaves&quot;);</span><br><span class="line">        builder.HasOne&lt;User&gt;(l=&gt;l.Requester).WithMany().IsRequired();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l=&gt;l.Approver1).WithMany();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l =&gt; l.Approver2).WithMany();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l =&gt; l.Approver3).WithMany();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">            var zs = new User &#123; Name = &quot;张三&quot; &#125;;</span><br><span class="line">            var ls = new User &#123; Name =  &quot;李四&quot; &#125;;</span><br><span class="line">            var ww = new User &#123; Name = &quot;王五&quot; &#125;;</span><br><span class="line">            ctx.Users.Add(zs);</span><br><span class="line">            ctx.Users.Add(ls);</span><br><span class="line">            ctx.Users.Add(ww);</span><br><span class="line">            ctx.Leaves.Add(new Leave &#123; Requester=zs,Approver1 = ls,Approver2=ww,Remarks=&quot;看牙&quot;,Time = DateTime.Now,Approver3=ww&#125;);</span><br><span class="line">            ctx.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>对于主从结构的“一对多”表关系，一般声明为双向导航属性。<br>对于其他的“一对多”表关系：如果表属于被很多表引用的基础表，则用单向导航属性，否则可以自由决定是否用双向导航属性。</p><h1 id="自引用组织结构树"><a href="#自引用组织结构树" class="headerlink" title="自引用组织结构树"></a>自引用组织结构树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如果有一个这样的结构，我们该如何处理呢？<br>秋华集团全球总部<br>秋华集团亚太总部<br>秋华集团（中国）<br>秋华集团（新加坡）<br>秋华集团美洲总部<br>秋华集团（美国）<br>秋华集团（加拿大）<br>以上结构我们可以建立自引用组织结构树，具体操作如下<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OrgUnit &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public OrgUnit? Parent &#123; get; set; &#125;</span><br><span class="line">    public List&lt;OrgUnit&gt; Children &#123; get; set; &#125; = new List&lt;OrgUnit&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OrgUnitConfig : IEntityTypeConfiguration&lt;OrgUnit&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;OrgUnit&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_OrgUnits&quot;);</span><br><span class="line">        builder.Property(o=&gt;o.Name).IsUnicode().IsRequired().HasMaxLength(50);</span><br><span class="line">        builder.HasOne&lt;OrgUnit&gt;(o =&gt; o.Parent).WithMany(o =&gt; o.Children);//根节点没有Parent所以这个关系不能为不可空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    var orgUnit1 = new OrgUnit &#123; Name = &quot;秋华集团全球总部&quot; &#125;;</span><br><span class="line">    var orgUnit11 = new OrgUnit &#123; Name = &quot;秋华集团亚太总部&quot;, Parent = orgUnit1 &#125;;</span><br><span class="line">    var orgUnit12 = new OrgUnit &#123; Name = &quot;秋华集团美洲总部&quot;, Parent = orgUnit1 &#125;;</span><br><span class="line">    var orgUnit111 = new OrgUnit &#123; Name = &quot;秋华集团（中国）&quot;, Parent = orgUnit11 &#125;;</span><br><span class="line">    var orgUnit112 = new OrgUnit &#123; Name = &quot;秋华集团（新加坡）&quot;, Parent = orgUnit11 &#125;;</span><br><span class="line">    var orgUnit121 = new OrgUnit &#123; Name = &quot;秋华集团（美国）&quot;, Parent = orgUnit12 &#125;;</span><br><span class="line">    var orgUnit122 = new OrgUnit &#123; Name = &quot;秋华集团（加拿大）&quot;, Parent = orgUnit12 &#125;;</span><br><span class="line">    using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit1);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit11);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit12);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit111);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit112);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit121);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit122);</span><br><span class="line">        ctx.SaveChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里如果只说明某个节点的父节点是XXX，并且ctx.OrgUnits.Add(根节点)是无法做到顺杆爬的，因为无法通过父节点看到自己的子节点，所以采用以上这种方式。</p><h2 id="递归缩进打印"><a href="#递归缩进打印" class="headerlink" title="递归缩进打印"></a>递归缩进打印</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var root = ctx.OrgUnits.Single(o =&gt; o.Parent == null);</span><br><span class="line">                PrintChildren(0, ctx, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 缩进打印parent所有的子节点</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;indentLevel&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;dbContext&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;</span><br><span class="line">        static void PrintChildren(int indentLevel,MyDbContext ctx,OrgUnit parent) &#123;</span><br><span class="line">            var children = ctx.OrgUnits.Where(o=&gt;o.Parent==parent).ToList();//找以我为根节点的节点</span><br><span class="line">            foreach (var child in children) &#123;</span><br><span class="line">                Console.WriteLine(new String(&#x27;\t&#x27;, indentLevel) + child.Name);</span><br><span class="line">                PrintChildren(indentLevel + 1, ctx, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 一对多 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_一些注意事项</title>
      <link href="/2023/11/07/EFCore-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/11/07/EFCore-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h1><h2 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h2><p>1、EF Core支持多种主键生成策略：自动增长、Guid、Hi&#x2F;Lo算法等。<br>2、自动增长优点：简单；缺点：数据库迁移以及分布式系统中比较麻烦；并发性能差。long、int等类型主键，默认是自增的。因为是数据库生成的值，所以SavaChanges后会自动把主键的值更新到Id属性。<br>3、自增字段的代码中不能为Id赋值，必须保持默认值0，否则运行的时候会报错。</p><h2 id="Guid主键"><a href="#Guid主键" class="headerlink" title="Guid主键"></a>Guid主键</h2><p>1、Guid算法（或UUID算法）生成一个全局唯一的Id。适合于分布式系统，在进行多数据库数据合并时很简单。优点：简单、高并发效率比自增主键高、全局唯一；缺点：磁盘空间占用大。<br>2、Guid值不连续。使用Guid类型做主键的时候，不能把主键设置为聚集索引。因为聚集索引是按照顺序保存主键的，因此用Guid做主键性能差。比如MySql的InnoDB引擎中主键是强制使用聚集索引的。有的数据库支持部分的连续Guid，比如SQLServer中的NewSequentialId()，但也不能解决问题。在SQLServer等中，不要把Guid主键设置为聚集索引；在MySQL中，插入频繁的表不要用Guid做主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Guid是结构体，一般不使用new Guid()，当然这样也没问题，但是更推荐以下写法</span><br><span class="line">Guid g = Guid.NewGuid();</span><br></pre></td></tr></table></figure><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>混合自增与Guid（非复合主键）：<br>用自增列做物理的主键，而用Guid列做逻辑上的主键。把自增列设置为表的主键，而在业务上查询数据的时候把Guid当主键使用。在和其他表关联以及和外部系统通讯的时候（比如前端显示数据的标识的时候）都是使用Guid列。不仅保证了性能，而且利用了Guid的优点，减轻了主键自增性导致主键值可被预测带来的安全性问题。<br>Hi&#x2F;Lo算法：<br>EF Core 支持Hi&#x2F;Lo算法来优化自增列。主键值由两部分组成：高位（Hi）和低位（Lo），高位由数据库生成，两个高位之间间隔若干个值，由程序在本地生成低位，低位的值在本地自增生成。不同进程或者集群中不同服务器获取的Hi值不会重复，而本地进程计算的Lo则可以保证可以在本地高效率的生成主键值。但是HiLo算法不是EF Core的标准。</p><h1 id="Migrations"><a href="#Migrations" class="headerlink" title="Migrations"></a>Migrations</h1><h2 id="Migrations原理"><a href="#Migrations原理" class="headerlink" title="Migrations原理"></a>Migrations原理</h2><p>1、使用迁移脚本，可以对当前连接的数据库执行编号更高的迁移，这个操作叫做“向上迁移”（Up），也可以执行把数据库回退到旧的迁移，这个操作叫“向下迁移”（Down）。<br>2、除非有特殊需要，否则不要删除Migrations文件夹下的代码。<br>3、在Migrations文件夹下的文件记录着每个操作事件的Up和Down操作。<br>4、数据库的__EFMigrationsHistory表：记录当前数据库曾经应用过的迁移脚本，按顺序排列。</p><h2 id="Migrations其他命令"><a href="#Migrations其他命令" class="headerlink" title="Migrations其他命令"></a>Migrations其他命令</h2><p>1、Updata-Database XXX<br>把数据库升级&#x2F;回滚到XXX的状态，迁移脚本不动。<br>2、Remove-Migration<br>删除最后一次的迁移脚本。<br>3、Script-Migration<br>生成迁移SQL代码。因为Updata-Database对数据可的操作没有直接的Sql代码清晰，可以通过该语句直观看到对数据库的操作。<br>4、Script-Migration D F<br>生成版本D到版本F的SQL脚本。<br>5、Script-Migration D<br>生成版本D到最新版本的SQL脚本。</p><h1 id="反向工程"><a href="#反向工程" class="headerlink" title="反向工程"></a>反向工程</h1><p>通过数据库表来反向生成实体类：<br>程序包管理控制台输入<br>Scaffold-DbContext “Server&#x3D;.;Database&#x3D;demo1;Trusted_Connection&#x3D;True;MultipleActiveResultSets&#x3D;true” Microsoft.EntityFrameworkCore.SqlServer</p><p>如果已经生成了一个实体类，但是想再在数据库中再增加一个实体类需要加一个参数 -Force：<br>Scaffold-DbContext “Server&#x3D;.;Database&#x3D;demo1;Trusted_Connection&#x3D;True;MultipleActiveResultSets&#x3D;true” Microsoft.EntityFrameworkCore.SqlServer -Force</p><h1 id="通过代码查看EF-Core生成的Sql语句"><a href="#通过代码查看EF-Core生成的Sql语句" class="headerlink" title="通过代码查看EF Core生成的Sql语句"></a>通过代码查看EF Core生成的Sql语句</h1><p>1、标准日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    public class MyDbContext:DbContext &#123;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">        public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">        private static ILoggerFactory loggerFactory = LoggerFactory.Create(b=&gt;b.AddConsole());</span><br><span class="line">        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">            base.OnConfiguring(optionsBuilder);</span><br><span class="line">            optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);</span><br><span class="line">            optionsBuilder.UseLoggerFactory(loggerFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">            base.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、简单日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    public class MyDbContext:DbContext &#123;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">        public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">            base.OnConfiguring(optionsBuilder);</span><br><span class="line">            optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);</span><br><span class="line">            optionsBuilder.LogTo(msg=&gt; &#123;</span><br><span class="line">                Console.WriteLine(msg);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">            base.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、ToQueryString方法<br>上面两种方式无法直接得到一个操作的SQL语句，而且在操作很多的情况下容易混乱。<br>EF Core的Where方法返回的而是IQueryable类型，DbSet也实现了IQueryable接口。IQueryable有拓展方法ToQueryString()可以获得转换后的SQL语句。<br>不需要真的执行查询才获取SQL语句；只能获取查询操作的SQL语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            using(var db = new MyDbContext()) &#123;</span><br><span class="line">                IQueryable&lt;Book&gt; books = db.Books.Where(e =&gt; e.money &gt; 30);</span><br><span class="line">                foreach(var book in books) &#123;</span><br><span class="line">                    Console.WriteLine(book.name);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(books.ToQueryString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、总结<br>写测试性代码，用简单日志；正式需要记录SQL给审核人员或者排查故障，用标准日志；开发阶段，从繁杂的查询操作中立即看到SQL，用ToQueryString()。</p><h1 id="同样的Linq被翻译成不同的SQL语句"><a href="#同样的Linq被翻译成不同的SQL语句" class="headerlink" title="同样的Linq被翻译成不同的SQL语句"></a>同样的Linq被翻译成不同的SQL语句</h1><p>数据库迁移脚本不能跨数据库，因为各个数据库的建表语句或者创建字段语句不一样。可以通过给Add-Migration命令添加“-OutputDir”参数的形式来在同一项目中为不同的数据库生成不同的迁移脚本。<br>由于各个数据库的查询、函数、自增等语法不同，在不同的EF Provider中相同的语法有可能产生不同的SQL语句。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> Migrations </tag>
            
            <tag> 反向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_FluentAPI</title>
      <link href="/2023/10/29/EFCore-FluentAPI/"/>
      <url>/2023/10/29/EFCore-FluentAPI/</url>
      
        <content type="html"><![CDATA[<h1 id="约定配置"><a href="#约定配置" class="headerlink" title="约定配置"></a>约定配置</h1><p>主要规则：<br>1、表名采用DbContext中对应DbSet的属性名。<br>2、数据表列的名字采用实体类属性的名字，列的数据类型采用和实体类属性类型最兼容的类型。<br>3、数据表列的可空性取决于对应实体类属性的可空性。<br>4、名字为Id 的属性为主键，如果主键为short、int、long类型，则默认采用自增字段，如果主键为Guid类型，则默认采用默认的Guid生成机制生成主键值。</p><h1 id="两种配置方式"><a href="#两种配置方式" class="headerlink" title="两种配置方式"></a>两种配置方式</h1><h2 id="1、Data-Annotation"><a href="#1、Data-Annotation" class="headerlink" title="1、Data Annotation"></a>1、Data Annotation</h2><p>把配置以特性（Annotation）的形式标注在实体类中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Table(&quot;T_Perosns&quot;)]</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public int id &#123; get; set; &#125;</span><br><span class="line">    [Required()]</span><br><span class="line">    [MaxLength(100)]</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public string sex &#123; get; set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单<br>缺点：耦合</p><h2 id="2、Fluent-API"><a href="#2、Fluent-API" class="headerlink" title="2、Fluent API"></a>2、Fluent API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PersonEntityConfig : IEntityTypeConfiguration&lt;Person&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Person&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Persons&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：解耦<br>缺点：复杂<br>两种方法大部分功能重叠可以混用，但是不建议，混用优先级：FluentAPI&gt;Data Annotation&gt;约定</p><h1 id="Fluent-API"><a href="#Fluent-API" class="headerlink" title="Fluent API"></a>Fluent API</h1><p>1、视图与实体类映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法</span><br><span class="line">builder.ToView(&quot;blogsView&quot;);</span><br><span class="line">//DbContext类写法</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().ToView(&quot;blogsView&quot;);</span><br></pre></td></tr></table></figure><p>2、排除属性映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Ignore(e=&gt;e.name2);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().Ignore(b=&gt;b.name2);</span><br></pre></td></tr></table></figure><p>3、配置列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.BlogId).HasColumnName(&quot;blog_id&quot;);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().Property(b=&gt;b.BlogId).HasColumnName(&quot;blog_id&quot;);</span><br></pre></td></tr></table></figure><p>4、配置列数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.BlogId).HasColumnType(&quot;blog_id&quot;);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().Property(b=&gt;b.BlogId).HasColumnType(&quot;blog_id&quot;);</span><br></pre></td></tr></table></figure><p>5、配置主键：<br>默认把名字为Id或者“实体类型+Id”的属性作为主键，可以用HasKey()来配置其他属性作为主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.HasKey(c=&gt;c.Number);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().HasKey(c=&gt;c.Number);</span><br></pre></td></tr></table></figure><p>支持复合主键，但是不建议使用。<br>6、生成列的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.Number).ValueGeneratedOnAdd();</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(b=&gt;b.Number).ValueGeneratedOnAdd();</span><br></pre></td></tr></table></figure><p>7、可以用HasDefaultValue()为属性设定默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.Age).HasDefaultValue(6);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(b=&gt;b.Age).HasDefaultValue(6);</span><br></pre></td></tr></table></figure><p>8、<br>索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.HasIndex(b=&gt;b.Url);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().HasIndex(b=&gt;b.Url);</span><br></pre></td></tr></table></figure><p>复合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.HasIndex(p=&gt;new &#123;p.FirstName,p.LastName&#125;);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Person&gt;().HasIndex(p=&gt;new &#123;p.FirstName,p.LastName&#125;);</span><br></pre></td></tr></table></figure><p>唯一索引：IsUnique()<br>聚集索引：IsClustered()<br>9、<br>用EF Core太多高级特性的时候谨慎，尽量不要和业务逻辑混合在一起，以免“不能自拔”。比如Ignore、Shadow、Table Splitting等</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> Fluent API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_简单使用</title>
      <link href="/2023/10/28/EFCore-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/28/EFCore-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="EFCore简介"><a href="#EFCore简介" class="headerlink" title="EFCore简介"></a>EFCore简介</h1><p>ORM：让开发者用对象操作的形式操作关系型数据库。<br>EFCore、Dapper就是常见的ORM</p><p>应用程序通过EF Core将C#代码变成Sql语句借助Ado.Net Core与数据库进行操作。</p><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>1、对于后台系统、信息系统等和数据库相关开发工作量大的系统，且团队比较稳定就用EFCore；对于互联网系统等数据库相关工作量不大的系统，或者团队不稳定就用Dapper<br>2、在项目中可以混用，只要注意EFCore的缓存、Tracking等问题即可。</p><h2 id="EFCore和EF比较"><a href="#EFCore和EF比较" class="headerlink" title="EFCore和EF比较"></a>EFCore和EF比较</h2><p>1、EF有DB First、Model First、Code First。EFCore不支持模型优先，推荐使用代码优先，遗留系统可以使用Scaffold DbContext来生成代码实现类似DB First的效果，但是推荐使用Code First。<br>2、EF会对实体上的标注做校验，EF Core追求轻量化，不校验。<br>3、EFCore加了很多新东西。<br>4、EF中的一些类的命名空间以及一些方法的名字在EF Core中稍有不同。<br>5、EF不再做新特性增加。<br>6、EF Core是对底层ADO.NET Core的封装，因此ADO.NET Core支持的数据库不一定被EF Core支持。</p><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>安装：Microsoft.EntityFrameworkCore.SqlServer或其他用来使用不同的数据库。<br>1、建数据实体类比如Book，Person等。<br>2、建实现IEntityTypeConfiguration&lt;T&gt;接口的配置类，用来配置数据对应哪张表，T为实体类。<br>3、建继承DbContext的类，里面有一个或多个Dbset&lt;T&gt;属性用来声明这个数据库里面有几个表，T为实体类。该类有OnConfiguring方法用于使用数据库连接语句，还有OnModelCreating方法用于告诉EF Core数据库配置类从何处获取（一般为当前程序集）。<br>为了方便对应杨中科老师的教程，我将使用SqlServer进行演示，如果想使用MySql可以看之前几篇博客。<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    public int id &#123; get; set; &#125;</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public double money &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public int id &#123; get; set; &#125;</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public string sex &#123; get; set;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BookEntityConfig : IEntityTypeConfiguration&lt;Book&gt; &#123;</span><br><span class="line">public void Configure(EntityTypeBuilder&lt;Book&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Books&quot;);</span><br><span class="line">        builder.Property(e=&gt;e.name).HasMaxLength(50).IsRequired();//设置书名最大长度50，不允许为空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PersonEntityConfig : IEntityTypeConfiguration&lt;Person&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Person&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Persons&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DbContext类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyDbContext:DbContext &#123;</span><br><span class="line">    public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">        base.OnConfiguring(optionsBuilder);</span><br><span class="line">        optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        base.OnModelCreating(modelBuilder);</span><br><span class="line">        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Migration数据库迁移"><a href="#Migration数据库迁移" class="headerlink" title="Migration数据库迁移"></a>Migration数据库迁移</h2><p>安装：Microsoft.EntityFrameworkCore.Tools。<br>面向对象的ORM开发中，数据库不是程序员手动创建的，而是Migration工具生成的。关系型数据库只是盛放模型数据的一个媒介而已，理想状态下，程序员不用关心数据库的操作。<br>根据对象的定义变化，自动更新数据库中的表以及表结构的操作叫做Migration（迁移）<br>迁移可以分为多步（项目进化），也可以回滚。<br>1、在程序包管理器控制台中执行：<br>Add-Migration 操作名<br>会自动在项目的Migrations文件夹中生成操作数据库的C#代码。<br>2、代码需要执行后才会应用对数据库的操作，所以程序不能有错误。在程序包管理器控制台中执行：<br>Updata-database</p><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>配置类不是必须的，在EF Core中有约定大于配置的规则，会默认生成一个隐藏的配置类，如果想更改表名或者对某字段有进一步配置可以自己添加配置类。</p><h1 id="EF-Core进行增删改查"><a href="#EF-Core进行增删改查" class="headerlink" title="EF Core进行增删改查"></a>EF Core进行增删改查</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        using(var db = new MyDbContext()) &#123;</span><br><span class="line">            //1、增</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;ES6标准入门&quot;, money = 57.5 &#125;);</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;C#图解教程&quot;, money = 69 &#125;);</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;单片微机原理&quot;, money = 30 &#125;);</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;深入浅出NodeJS&quot;, money = 44 &#125;);</span><br><span class="line">            await db.SaveChangesAsync();//相当于Updata-Database</span><br><span class="line">            //2、删</span><br><span class="line">            var b = db.Books.Single(e =&gt; e.name == &quot;C#图解教程&quot;);</span><br><span class="line">            db.Books.Remove(b);</span><br><span class="line">            await db.SaveChangesAsync();</span><br><span class="line">            //3、改</span><br><span class="line">            var  b2 = db.Books.Single(e =&gt; e.name == &quot;深入浅出NodeJS&quot;);</span><br><span class="line">            b2.name = &quot;JAVA核心技术卷一&quot;;</span><br><span class="line">            await db.SaveChangesAsync();</span><br><span class="line">            //4、查</span><br><span class="line">            IQueryable&lt;Book&gt; books = db.Books.Where(e =&gt; e.money &gt; 30);</span><br><span class="line">            foreach(var book in books) &#123;</span><br><span class="line">                Console.WriteLine(book.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前的删除、修改数据需要先查出来，性能低，在.NET7退出了比较高效的修改、删除的操作，详细操作可以查看官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_SignalR</title>
      <link href="/2023/09/18/Asp.NetCore-SignalR/"/>
      <url>/2023/09/18/Asp.NetCore-SignalR/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>需求：Web聊天、站内通知<br>传统HTTP只能客户端主动发送请求<br>传统长轮询方式性能差，不推荐使用<br>基于Tcp协议，支持二进制通信，双工通信<br>性能和并发能力强<br>WebSocket独立于HTTP协议，不过我们一般仍然把WebSocket服务器端部署到Web服务器，因为可以借助HTTP协议完成初始的握手（可选），并且共享HTTP服务器的端口（主要），通过请求的特点决定将请求交给HTTP处理程序或者WebSocket处理程序。</p><h1 id="ASP-NET-Core-SignalR"><a href="#ASP-NET-Core-SignalR" class="headerlink" title="ASP.NET Core SignalR"></a>ASP.NET Core SignalR</h1><p>1、SignalR是对.NET Core平台下对WebSocket的封装<br>2、Hub（集线器）类似于路由器，是数据交换中心</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建web api项目，创建一个继承Hub的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyHub : Hub&#123;</span><br><span class="line">//这个方法名由客户端调用</span><br><span class="line">    public Task SendPublicMsgAsync(string msg) &#123;</span><br><span class="line">        string connId = this.Context.ConnectionId;</span><br><span class="line">        string msgToSend = $&quot;&#123;connId&#125; &#123;DateTime.Now&#125;：&#123;msg&#125;&quot;;</span><br><span class="line">        //双方规定好用&quot;PublicMsgReceived&quot;作为消息名，在前端会有名为&quot;PublicMsgReceived&quot;的事件</span><br><span class="line">        return this.Clients.All.SendAsync(&quot;PublicMsgReceived&quot;, msgToSend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.AddSignalR();</span><br><span class="line">//记得允许跨域</span><br><span class="line">builder.Services.AddCors(options =&gt; &#123;</span><br><span class="line">    options.AddDefaultPolicy(</span><br><span class="line">        policy =&gt; &#123;</span><br><span class="line">            policy.WithOrigins(&quot;http://127.0.0.1:5173&quot;)</span><br><span class="line">                                .AllowAnyHeader()</span><br><span class="line">                                .AllowAnyMethod()</span><br><span class="line">                                .AllowCredentials();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">app.UseCors();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapHub&lt;MyHub&gt;(&quot;/MyHub&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//前端代码</span><br><span class="line">//记得npm下载npm i @microsoft/signalr</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;reactive,onMounted&#125; from &#x27;vue&#x27;;</span><br><span class="line">import * as signalR from &#x27;@microsoft/signalr&#x27;;</span><br><span class="line">export default&#123;</span><br><span class="line">setup()&#123;</span><br><span class="line">let connection;</span><br><span class="line">const state = reactive(&#123;userMsg:&quot;&quot;,message:[]&#125;);</span><br><span class="line">const textMsgOnKeyPress = async function(e)&#123;</span><br><span class="line">if(e.keyCode!=13) return;</span><br><span class="line">//参数1：调用的signalR方法名，参数2：传递的参数</span><br><span class="line">await connection.invoke(&quot;SendPublicMsgAsync&quot;,state.userMsg);</span><br><span class="line">state.userMsg = &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">onMounted(async()=&gt;&#123;</span><br><span class="line">connection = new signalR.HubConnectionBuilder()</span><br><span class="line">.withUrl(&quot;https://localhost:7020/MyHub&quot;)</span><br><span class="line">.withAutomaticReconnect()</span><br><span class="line">.build();</span><br><span class="line">await connection.start();</span><br><span class="line">//参数1：约定的消息名，参数2：回调</span><br><span class="line">connection.on(&quot;PublicMsgReceived&quot;,rcvMsg=&gt;&#123;</span><br><span class="line">state.message.push(rcvMsg);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">return &#123;state,textMsgOnKeyPress&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;state.userMsg&quot; v-on:keypress=&quot;textMsgOnKeyPress&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;(msg,index) in state.message&quot; :key=&quot;index&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="协议协商"><a href="#协议协商" class="headerlink" title="协议协商"></a>协议协商</h2><p>signalR不仅支持WebSocket还支持ServerSent Events、长轮询。<br>浏览器会先使用http请求通过nagotiate告诉服务器自己支持哪种方式，默认按照WebSocket、ServerSent Events、长轮询的顺序尝试。<br>IE浏览器支持WebSocket但signalR的javascript客户端不支持IE浏览器。</p><h2 id="协商带来的问题"><a href="#协商带来的问题" class="headerlink" title="协商带来的问题"></a>协商带来的问题</h2><p>1、集群中协议协商的问题：“协商”请求被服务器A处理，但接下来建立WebSocket请求却被服务器B处理。<br>2、解决方法：粘性会话和禁用协商。<br>3、“粘性会话”：把来自同一客户端的请求都转发到同一服务器上。缺点：因为共享公网IP等造成请求无法被平均的分配到服务器集群；扩容的自适应性不强。<br>4、“禁用协商”：直接向服务器发送WebSocket请求，WebSocket一旦建立，就形成了服务器和客户端持久连接的通道，在该连接中的后续往返WebSocket通信都是由同一台服务器处理。缺点：无法降级到ServerSent Events和长轮询，但是问题不大。<br>5、如果需要使用禁用协商，请参考微软文档，在javascript创建WebSocket时传入所需的配置项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onMounted(async()=&gt;&#123;</span><br><span class="line">connection = new signalR.HubConnectionBuilder()</span><br><span class="line">.withUrl(&quot;https://localhost:7020/MyHub&quot;,&#123;</span><br><span class="line">    skipNegotiation:true,</span><br><span class="line">    transport:signalR.HttpTransportType.WebSockets</span><br><span class="line">&#125;)</span><br><span class="line">.withAutomaticReconnect()</span><br><span class="line">.build();</span><br><span class="line">await connection.start();</span><br><span class="line">//参数1：约定的消息名，参数2：回调</span><br><span class="line">connection.on(&quot;PublicMsgReceived&quot;,rcvMsg=&gt;&#123;</span><br><span class="line">state.message.push(rcvMsg);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="SignalR的分布式部署"><a href="#SignalR的分布式部署" class="headerlink" title="SignalR的分布式部署"></a>SignalR的分布式部署</h2><p>问题：如果客户端连接到了不同的服务器，那么通过SignalR发送的消息很可能因为服务器不同的原因而接受不到。<br>解决方案：分布式部署，所有服务器连接到同一个消息中间件。在粘性会话或者禁用协商的模式下，分布式部署才有意义。<br>官方方案：redis backplane<br>Nuget：安装Microsoft.AspNetCore.SignalR.StackExchangeRedis。<br>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSignalR().AddStackExchangeRedis(&quot;127.0.0.1(redis服务器地址)&quot;, opt =&gt; &#123;</span><br><span class="line">    opt.Configuration.ChannelPrefix = &quot;localhost1_&quot;;//避免和其他连接到这个服务端的redis冲突，添加前缀（非必须）</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="SignalR的身份认证"><a href="#SignalR的身份认证" class="headerlink" title="SignalR的身份认证"></a>SignalR的身份认证</h1><p>ebsocket不支持自定义报文头，所以我们需要把JWT通过url中的QueryString传递，然后再服务器端的OnMessageReceived中，把QueryString中的jwt读取出来赋值给context.Token，后续中间件会从context.Token中解析jwt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(opt =&gt; &#123;</span><br><span class="line">    var jwtSettings = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JwtSetting&gt;();</span><br><span class="line">    byte[] keyBytes = Encoding.UTF8.GetBytes(jwtSettings.SecKey);</span><br><span class="line">    var secKey = new SymmetricSecurityKey(keyBytes);</span><br><span class="line">    opt.TokenValidationParameters = new() &#123;</span><br><span class="line">        ValidateIssuer = false,</span><br><span class="line">        ValidateAudience = false,</span><br><span class="line">        ValidateLifetime = true,</span><br><span class="line">        ValidateIssuerSigningKey = true,</span><br><span class="line">        IssuerSigningKey = secKey</span><br><span class="line">    &#125;;</span><br><span class="line">    opt.Events = new JwtBearerEvents &#123;</span><br><span class="line">        OnMessageReceived = context =&gt; &#123;</span><br><span class="line">            //websocket不支持自定义报文头，所以我们需要把JWT通过url中的QueryString传递，然后再服务器端的OnMessageReceived中，把QueryString中的jwt读取出来赋值给context.Token</span><br><span class="line">            var accessToken = context.Request.Query[&quot;access_token&quot;];</span><br><span class="line">            var path = context.Request.Path;</span><br><span class="line">            if(!string.IsNullOrEmpty(accessToken) &amp;&amp; path.StartsWithSegments(&quot;/MyHub&quot;)) &#123;</span><br><span class="line">                context.Token=accessToken;</span><br><span class="line">            &#125;</span><br><span class="line">            return Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">......</span><br><span class="line">//在app.UseAuthorization之前添加app.UseAuthentication</span><br><span class="line">app.UseAuthentication();</span><br><span class="line">app.UseAuthorization();</span><br></pre></td></tr></table></figure><p>在登录的时候向客户端返回jwt，然后在需要登录才能访问的集线器类上或者方法上添加[Authorize]。也支持角色等设置，可以设置到Hub或者方法上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//[Authorize(Roles =&quot;admin&quot;)]</span><br><span class="line">[Authorize]</span><br><span class="line">public class MyHub:Hub &#123;</span><br><span class="line">    public async Task SendMessage(string user, string message) &#123;</span><br><span class="line">        await Clients.All.SendAsync(&quot;ReceiveMessage&quot;, user, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码需要传递access_token</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//前端代码</span><br><span class="line">//记得npm下载npm i @microsoft/signalr</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive, onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">import * as signalR from &#x27;@microsoft/signalr&#x27;;</span><br><span class="line">import axios from &quot;axios&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let connection;</span><br><span class="line">        const state = reactive(&#123; userMsg: &quot;&quot;, message: [], userName: &quot;&quot;, password: &quot;&quot; &#125;);</span><br><span class="line">        const textMsgOnKeyPress = async function (e) &#123;</span><br><span class="line">            if (e.keyCode != 13) return;</span><br><span class="line">            //参数1：调用的signalR方法名，参数2：传递的参数</span><br><span class="line">            await connection.invoke(&quot;SendPublicMsgAsync&quot;, state.userMsg);</span><br><span class="line">            state.userMsg = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        let login = async () =&gt; &#123;</span><br><span class="line">            let payload = &#123; userName: state.userName, password: state.password &#125;</span><br><span class="line">            axios.get(&quot;https://localhost:7020/Test/Login&quot;, payload).then(async res =&gt; &#123;</span><br><span class="line">                let token = res.data;</span><br><span class="line">                var opt = &#123;&#125;;</span><br><span class="line">                opt.accessTokenFactory = () =&gt; token;</span><br><span class="line">                connection = new signalR.HubConnectionBuilder()</span><br><span class="line">                    .withUrl(&quot;https://localhost:7020/MyHub&quot;,opt)</span><br><span class="line">                    .withAutomaticReconnect()</span><br><span class="line">                    .build();</span><br><span class="line">                await connection.start();</span><br><span class="line">                //参数1：约定的消息名，参数2：回调</span><br><span class="line">                connection.on(&quot;PublicMsgReceived&quot;, rcvMsg =&gt; &#123;</span><br><span class="line">                    state.message.push(rcvMsg);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123; state, textMsgOnKeyPress, login &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;state.userMsg&quot; v-on:keypress=&quot;textMsgOnKeyPress&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; v-model=&quot;state.userName&quot; /&gt;</span><br><span class="line">        密码：&lt;input type=&quot;password&quot; v-model=&quot;state.password&quot; /&gt;</span><br><span class="line">        &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li v-for=&quot;(msg, index) in state.message&quot; :key=&quot;index&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> WebSocket </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_校验机制</title>
      <link href="/2023/09/15/Asp.NetCore-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/09/15/Asp.NetCore-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="校验机制"><a href="#校验机制" class="headerlink" title="校验机制"></a>校验机制</h1><h2 id="Net-Core内置"><a href="#Net-Core内置" class="headerlink" title=".Net Core内置"></a>.Net Core内置</h2><p>1、在.Net Core中内置了对数据校验的支持，在System.ComponentModel.DataAnnotations这个命名空间下有如：[Required]、[EamilAddress]、[RegularExpression]。CustomValidationAttribute、IValidatableObject。<br>2、内置的校验机制的问题：校验规则都是和模型类耦合在一起，违反“单一职责原则”，很多常用的校验都需要编写自定义校验规则，而且写起来麻烦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DataTest &#123;</span><br><span class="line">        [Required]</span><br><span class="line">        public string UserName &#123; get; set; &#125;</span><br><span class="line">        public string Password &#123; get; set; &#125;</span><br><span class="line">        [EmailAddress]</span><br><span class="line">        public string Email &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第三方包（FluentValidation）"><a href="#第三方包（FluentValidation）" class="headerlink" title="第三方包（FluentValidation）"></a>第三方包（FluentValidation）</h2><p>1、用类似于EF Core中Fluent API的方式进行校验规则的 配置，也就是我们可以把对模型类的校验放到单独的校验类中<br>2、NuGet安装：<br>FluentValidation.AspNetCore<br>3、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.AddFluentValidation(opt =&gt; &#123;</span><br><span class="line">    opt.RegisterValidatorsFromAssembly(Assembly.GetExecutingAssembly());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//请求实体类</span><br><span class="line">   public class AddNewUserRequest &#123;</span><br><span class="line">        public string UserName &#123; get; set; &#125;</span><br><span class="line">        public string Password &#123; get; set; &#125;</span><br><span class="line">        public string Email &#123; get; set; &#125;</span><br><span class="line">        public string Password2 &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//请求校验类</span><br><span class="line">    public class AddNewUserRequestValidator :AbstractValidator&lt;AddNewUserRequest&gt; &#123;</span><br><span class="line">        public AddNewUserRequestValidator() &#123;</span><br><span class="line">            RuleFor(x =&gt; x.Email).NotNull().EmailAddress().WithMessage(&quot;密码不合法&quot;).Must(x=&gt;x.EndsWith(&quot;@163.com&quot;)||x.EndsWith(&quot;@qq.com&quot;)).WithMessage(&quot;只支持163或者qq邮箱&quot;);</span><br><span class="line">            RuleFor(x =&gt; x.UserName).NotNull().Length(6, 10);</span><br><span class="line">            RuleFor(x =&gt; x.Password).Equal(x =&gt; x.Password2).WithMessage(&quot;两次密码不一致&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FluentValidation支持从构造函数依赖注入。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 校验机制 </tag>
            
            <tag> FluentValidation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_托管服务</title>
      <link href="/2023/09/15/Asp.NetCore-%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/09/15/Asp.NetCore-%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="托管服务"><a href="#托管服务" class="headerlink" title="托管服务"></a>托管服务</h1><p>1、让代码运行在后台。比如服务器启动的时候在后台预先加载数据到缓存，每天凌晨三点把数据导出到备份数据库，每五秒在两张表之间同步一次数据。<br>2、托管服务实现IHostedService接口，一般编写从BackgroundService继承的类。<br>3、services.AddHostedService&lt;DemoBgService&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HostedService1 : BackgroundService &#123;</span><br><span class="line">        protected override async Task ExecuteAsync(CancellationToken stoppingToken) &#123;</span><br><span class="line">        //在这里面执行后台代码</span><br><span class="line">            Console.WriteLine(&quot;后台启动&quot;);</span><br><span class="line">            await Task.Delay(3000);</span><br><span class="line">            Console.WriteLine(&quot;后台代码执行完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.AddHostedService&lt;HostedService1&gt;();</span><br></pre></td></tr></table></figure><p>如果文件中发生异常：<br>1、程序会自动停止或退出。可以把HostOptions.BackgroundServiceExceptionBehavior设置为Ignore，程序会忽略异常，而不是停止程序，不过不推荐采用默认的设置。<br>2、起码应该用try…catch…包裹一下。<br>使用DI：<br>1、托管服务是以单例的生命周期注册到依赖注入容器中，因此不能注入生命周期为范围或者瞬态的服务，比如注入EFCore上下文的话，程序就会抛异常。<br>2、可以通过构造方法中注入一个IServiceScopeFactory，它可以用来创建一个IServiceScope对象，这样我们就可以通过IServiceScope来创建短生命周期的服务了。记得在Dispose中释放IServiceScope</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//HostedService</span><br><span class="line"> public class HostedService1 : BackgroundService &#123;</span><br><span class="line">        private readonly IServiceScope serviceScope;</span><br><span class="line">        public HostedService1(IServiceScopeFactory factory) &#123;</span><br><span class="line">            this.serviceScope = factory.CreateScope();</span><br><span class="line">        &#125;</span><br><span class="line">        public override void Dispose() &#123;</span><br><span class="line">            this.serviceScope.Dispose();</span><br><span class="line">            base.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        protected override async Task ExecuteAsync(CancellationToken stoppingToken) &#123;</span><br><span class="line">            var scopeTest  = serviceScope.ServiceProvider.GetRequiredService&lt;ScopeTest&gt;();</span><br><span class="line">            scopeTest.Say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Progrom.cs</span><br><span class="line">builder.Services.AddScoped&lt;ScopeTest&gt;();</span><br><span class="line">builder.Services.AddHostedService&lt;HostedService1&gt;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 托管服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_JWT</title>
      <link href="/2023/09/15/Asp.NetCore-JWT/"/>
      <url>/2023/09/15/Asp.NetCore-JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="Session描述"><a href="#Session描述" class="headerlink" title="Session描述"></a>Session描述</h2><p>在浏览器端用户登录后，服务器端生成唯一session id，并且把用户名和session id建立对应关系保存到服务器端，当下次浏览器端访问时携带着cookie和服务器保存session对应，就可以直接登录了。</p><h2 id="Session缺点"><a href="#Session缺点" class="headerlink" title="Session缺点"></a>Session缺点</h2><p>1、对于分布式集群环境，session数据保存在服务器内存中就不合适了，应该放到一个中心状态服务器上。ASP.NET Core支持Session采用Redis、Memcached。<br>2、中心状态服务器有性能问题。</p><h2 id="JWT描述"><a href="#JWT描述" class="headerlink" title="JWT描述"></a>JWT描述</h2><p>1、JWT把登陆信息保存在客户端。<br>2、为了防止客户端数据造假，保存在客户端的令牌经过了签名处理，而签名的密钥只有服务器端才知道，每次服务器端收到客户端提交过来的令牌的时候都要检查一下签名。<br>3、JWT是明文存储的，不要把不能被客户端知道的信息放到JWT中。<br><img src="/images/ASP.NETCore%E9%AB%98%E7%BA%A7%E7%AF%87/1.jpg"></p><h2 id="JWT优点"><a href="#JWT优点" class="headerlink" title="JWT优点"></a>JWT优点</h2><p>1、状态保存在客户端，天然适合分布式签名。<br>2、签名保证了客户端无法数据造假。<br>3、性能更高，不需要和中心状态服务器通讯，纯内存计算。</p><h2 id="JWT基本使用"><a href="#JWT基本使用" class="headerlink" title="JWT基本使用"></a>JWT基本使用</h2><p>NuGet安装：<br>System.IdentityModel.Token，生成和校验JWT<br>生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// See https://aka.ms/new-console-template for more information</span><br><span class="line">using Microsoft.IdentityModel.Tokens;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.IdentityModel.Tokens.Jwt;</span><br><span class="line">using System.Security.Claims;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">List&lt;Claim&gt; claims = new List&lt;Claim&gt;();//一个claim代表一条用户信息，尽量使用ClaimTypes的值</span><br><span class="line">claims.Add(new Claim(&quot;Passport&quot;, &quot;123456&quot;));</span><br><span class="line">claims.Add(new Claim(&quot;QQ&quot;, &quot;8888888888&quot;));</span><br><span class="line">claims.Add(new Claim(&quot;Id&quot;, &quot;6666&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.NameIdentifier, &quot;11111 &quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.Name, &quot;LJH&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.HomePhone, &quot;8364799655&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.Role, &quot;admin&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.Role, &quot;manager&quot;));</span><br><span class="line">string key = &quot;suibianshurudiandongxi,jinliangchangyidian&quot;;//签名的key，不能泄露</span><br><span class="line">DateTime expire = DateTime.Now.AddHours(1);//过期时间</span><br><span class="line">byte[] secBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">var secKey = new SymmetricSecurityKey(secBytes);</span><br><span class="line">var credentials = new SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">var tokenDescriptor = new JwtSecurityToken(claims: claims,</span><br><span class="line">    expires: expire, signingCredentials: credentials);</span><br><span class="line">string jwt = new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);//JWT令牌</span><br><span class="line">Console.WriteLine(jwt);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//调用JwtSecurityTokenHandler类对JWT令牌进行解码</span><br><span class="line"></span><br><span class="line">using Microsoft.IdentityModel.Tokens;</span><br><span class="line">using System.IdentityModel.Tokens.Jwt;</span><br><span class="line">using System.Security.Claims;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">string jwt = Console.ReadLine()!;</span><br><span class="line">string secKey = &quot;suibianshurudiandongxi,jinliangchangyidian&quot;;</span><br><span class="line">JwtSecurityTokenHandler tokenHandler = new();</span><br><span class="line">TokenValidationParameters valParam = new();</span><br><span class="line">var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secKey));</span><br><span class="line">valParam.IssuerSigningKey = securityKey;</span><br><span class="line">valParam.ValidateIssuer = false;</span><br><span class="line">valParam.ValidateAudience = false;</span><br><span class="line">//不合法的key生成的jwt或者篡改过的jwt就会报错</span><br><span class="line">ClaimsPrincipal claimsPrincipal = tokenHandler.ValidateToken(jwt,</span><br><span class="line">valParam, out SecurityToken secToken);</span><br><span class="line">foreach (var claim in claimsPrincipal.Claims) &#123;</span><br><span class="line">Console.WriteLine($&quot;&#123;claim.Type&#125;=&#123;claim.Value&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ASP-NETCore对JWT的封装"><a href="#ASP-NETCore对JWT的封装" class="headerlink" title="ASP.NETCore对JWT的封装"></a>ASP.NETCore对JWT的封装</h2><p>NuGet安装：<br>1、Microsoft.AspNetCore.Authentication.JwtBearer<br>2、配置JWT节点，在appsettings.json下创建SecKey（密钥）、ExpireSeconds（过期时间），再创建配置类JWTSettings，包含SecKey、ExpireSeconds属性。<br>3、对JWT进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//appsetting.json</span><br><span class="line">&quot;JWT&quot;: &#123;</span><br><span class="line">    &quot;SecKey&quot;: &quot;asjdofiwengwieh*audsh&amp;sdy$&quot;,</span><br><span class="line">    &quot;ExpireSeconds&quot;: &quot;3600&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class JWTSettings &#123;</span><br><span class="line">      public string SecKey &#123; get;set; &#125;</span><br><span class="line">      public int ExpireSeconds &#123; get; set; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.Configure&lt;JWTSettings&gt;(builder.Configuration.GetSection(&quot;JWT&quot;));</span><br><span class="line">builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">    .AddJwtBearer(opt =&gt; &#123;</span><br><span class="line">        var jwtSettings = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTSettings&gt;();</span><br><span class="line">        byte[] keyBytes = Encoding.UTF8.GetBytes(jwtSettings.SecKey);</span><br><span class="line">        var secKey = new SymmetricSecurityKey(keyBytes);</span><br><span class="line">        opt.TokenValidationParameters = new() &#123;</span><br><span class="line">            ValidateIssuer = false,</span><br><span class="line">            ValidateAudience = false,</span><br><span class="line">            ValidateLifetime = true,</span><br><span class="line">            ValidateIssuerSigningKey = true,</span><br><span class="line">            IssuerSigningKey = secKey</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...............</span><br><span class="line">    app.UseAuthentication();//在app.UseAuthorization();前使用中间件</span><br><span class="line"></span><br><span class="line">    app.UseAuthorization();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Demo1Controller</span><br><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class Demo1Controller : ControllerBase &#123;</span><br><span class="line">        private readonly IOptionsSnapshot&lt;JWTSettings&gt; jwtSettings;</span><br><span class="line"></span><br><span class="line">        public DemoController(IOptionsSnapshot&lt;JWTSettings&gt; jwtSettings) &#123;</span><br><span class="line">            this.jwtSettings = jwtSettings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        //用户登录，返回jwt</span><br><span class="line">        public ActionResult&lt;string&gt; Login(string userName,string password) &#123;</span><br><span class="line">            if(userName == &quot;LJH&quot; &amp;&amp; password == &quot;123456&quot;) &#123;</span><br><span class="line">                List&lt;Claim&gt; claims = new List&lt;Claim&gt;();</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.NameIdentifier,&quot;1&quot;));</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.Name, userName));</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.Role, &quot;admin&quot;));</span><br><span class="line">                string key = jwtSettings.Value.SecKey;</span><br><span class="line">                DateTime expires = DateTime.Now.AddSeconds(jwtSettings.Value.ExpireSeconds);</span><br><span class="line">                byte[] secBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">                var secKey = new SymmetricSecurityKey(secBytes);</span><br><span class="line">                var credentials = new SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">                var tokenDescriptor = new JwtSecurityToken(claims: claims,</span><br><span class="line">                    expires: expires, signingCredentials: credentials);</span><br><span class="line">                string jwt = new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);</span><br><span class="line">                return jwt;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return BadRequest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;[controller]/[Action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    [Authorize]//该控制下所有action都需要登录才能访问</span><br><span class="line">    public class Demo2Controller : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test1() &#123;</span><br><span class="line">            var claim = this.User.FindFirst(ClaimTypes.Name);//可通过这个方式从jwt字符串的payload中解析并获取当前登录用户的用户名</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [AllowAnonymous]//有这个特性，不登录也可调用该action</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test2() &#123;</span><br><span class="line">            return &quot;666&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [Authorize(Roles = &quot;admin&quot;)]//角色为admin的才可以访问这个action</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test3() &#123;</span><br><span class="line">            return &quot;888&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在需要登录才能访问的控制器或者Action上添加[Authorize]。<br>客户端发送请求时在请求头中携带Authorization的值为”Bearer JWTToken”（JWTToken为生成的jwt）给服务器，就会自动判断是否登录，注意Bearer和jwtToken中间有空格，前后不能多出来额外的空格、换行等。</p><h2 id="Authorize-的注意事项"><a href="#Authorize-的注意事项" class="headerlink" title="[Authorize]的注意事项"></a>[Authorize]的注意事项</h2><p>1、ASP.NET Core中身份验证和授权验证的功能由Authentication、Authorization中间件提供：app.UseAuthentication()、app.UseAuthorization()。<br>2、控制器类上标注了[Authorize]，则所有操作方法都会被进行身份验证和授权验证；对于标注了[Authorize]的控制器中，如果其中某个操作方法不想被验证，可以在操作方法上添加[AllowAnonymous]。action上标注[Authorize]，则该action需要被验证才可以。<br>3、除了简单的[Authorize]验证，我们也可以对jwt的内容比如身份进行进一步验证，需要客户端发送jwt时携带需要验证的内容，在action或者controller类加上[Authorize(Roles &#x3D; “admin”)]特性即可。<br>4、ASP.NET Core会按照http协议的规范，从Authorization取出令牌，并且进行校验、解析，然后把解析结果填充到User属性中，这一切都由ASP.NET Core完成，不需要开发人员编写，但是一旦出现401，没有详细的报错信息，很难排查。</p><h2 id="Swagger携带JWT报文头"><a href="#Swagger携带JWT报文头" class="headerlink" title="Swagger携带JWT报文头"></a>Swagger携带JWT报文头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var scheme = new OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = &quot;Authorization header. \r\nExample: &#x27;Bearer 12345abcdef&#x27;&quot;,</span><br><span class="line">        Reference = new OpenApiReference&#123;Type = ReferenceType.SecurityScheme,</span><br><span class="line">            Id = &quot;Authorization&quot;&#125;,</span><br><span class="line">        Scheme = &quot;oauth2&quot;,Name = &quot;Authorization&quot;,</span><br><span class="line">        In = ParameterLocation.Header,Type = SecuritySchemeType.ApiKey,</span><br><span class="line">    &#125;;</span><br><span class="line">    c.AddSecurityDefinition(&quot;Authorization&quot;, scheme);</span><br><span class="line">    var requirement = new OpenApiSecurityRequirement();</span><br><span class="line">    requirement[scheme] = new List&lt;string&gt;();</span><br><span class="line">    c.AddSecurityRequirement(requirement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="JWT的缺点"><a href="#JWT的缺点" class="headerlink" title="JWT的缺点"></a>JWT的缺点</h2><p>1、到期前令牌无法被提前撤回。什么情况下需要撤回？<br>用户被删除了、禁用了；令牌被盗用了；单设备登录。<br>2、需要JWT撤回的场景用传统Session更合适。<br>3、思路：用Redis保存状态，或者用refresh_token+access_token机制等。<br>4、实现：服务器端将所有发出去的JWT保存下来，当客户端携带JWT，服务器端判断是否被修改，然后去查看有没有保存这个JWT。<br>在用户表中增加一个JWTVersion列，代表最后发放出去的令牌的版本号，每次登录、发放令牌的时候都让JWTVersion的值自增，同时将JWTVersion的值也放到JWT令牌的负载中；当执行禁用用户、撤回用户的令牌等操作时，把这个用户对应的JWTVersion列的值自增；当服务器收到客户端提交的JWT令牌后，先把JWT令牌中的JWTVersion值和数据库中JWTVersion的值做一下比较，如果JWT令牌中JWTVersion的值小于数据库中JWTVersion的值，就说明JWT令牌过期了</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_标识框架</title>
      <link href="/2023/09/15/Asp.NetCore-%E6%A0%87%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/09/15/Asp.NetCore-%E6%A0%87%E8%AF%86%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="标识框架（Identity）"><a href="#标识框架（Identity）" class="headerlink" title="标识框架（Identity）"></a>标识框架（Identity）</h1><h2 id="Authentication与Authorization"><a href="#Authentication与Authorization" class="headerlink" title="Authentication与Authorization"></a>Authentication与Authorization</h2><p>1、Authentication对访问者的用户进行验证，“用户是否登录”。<br>2、Authorization验证访问者的用户身份是否有对资源访问的访问权限，“用户是否有权限访问地址”<br>用户可能有多个角色，一个角色可能有多个用户。</p><h2 id="标识框架概念"><a href="#标识框架概念" class="headerlink" title="标识框架概念"></a>标识框架概念</h2><p>1、Identity采用基于角色的访问控制（RBAC）策略，内置了对用户、角色等表的管理，以及相关的接口，支持外部登录、2FA（两阶段验证）等。<br>2、标识框架使用EFCore对数据库进行操作，因此标识框架几乎支持所有数据库。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1、创建用户类和角色类，一般不自己编写而是创建继承IdentityUser&lt;TKey&gt;、IdentityRole&lt;TKey&gt;的自定义类类，TKey代表主键的类型，可以增加自定义属性。<br>2、NuGet安装：<br>Microsoft.AspNetCore.Identity.EntityFrameworkCore。<br>3、创建继承自IdentityDbContext的类，这个类内置了对IdentityUser&lt;TKey&gt;、IdentityRole&lt;TKey&gt;的处理，同时提供了基本的增删改查的操作。<br>4、可以通过IdentityDbContext类来操作数据库，不过框架中提供了RoleManager、UserManager等类来简化对数据库的操作。<br>5、部分方法的返回值为Task&lt;IdentityResult&gt;类型，这个类型包含着操作是否成功与错误信息等说明，需要手动判断<br>记得执行数据库迁移命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//自定义Identity角色</span><br><span class="line"> public class MyRole : IdentityRole&lt;long&gt;&#123;</span><br><span class="line">    &#125;</span><br><span class="line">//自定义Identity用户</span><br><span class="line">public class MyUser: IdentityUser&lt;long&gt; &#123;</span><br><span class="line">        public string? WeiXinAccount &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//数据库连接</span><br><span class="line">//不要忘了&lt;MyUser,MyRole,long&gt;</span><br><span class="line">public class MyDbContext :IdentityDbContext&lt;MyUser,MyRole,long&gt;&#123;</span><br><span class="line">        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options)</span><br><span class="line">           : base(options) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//数据库迁移时(Add-Migration Init报错)如果报错就定义这个类</span><br><span class="line">public class DbContextDesignTimeFactory : IDesignTimeDbContextFactory&lt;MyDbContext&gt; &#123;</span><br><span class="line">        public MyDbContext CreateDbContext(string[] args) &#123;</span><br><span class="line">            DbContextOptionsBuilder&lt;MyDbContext&gt; builder = new DbContextOptionsBuilder&lt;MyDbContext&gt;();</span><br><span class="line">            var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">            builder.UseMySql(&quot;server=localhost;user=root;password=your_password;database=your_database&quot;, serverVersion);</span><br><span class="line">            return new MyDbContext(builder.Options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">//Identity</span><br><span class="line">            builder.Services.AddDbContext&lt;MyDbContext&gt;(opt =&gt; &#123;</span><br><span class="line">                string constr = &quot;server=localhost;user=root;password=your_password;database=your_database&quot;;</span><br><span class="line">                var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">                opt.UseMySql(constr, serverVersion);</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.Services.AddDataProtection();</span><br><span class="line">            builder.Services.AddIdentityCore&lt;MyUser&gt;(options =&gt; &#123;</span><br><span class="line">                options.Password.RequireDigit = false;//是否需要数字</span><br><span class="line">                options.Password.RequireLowercase = false;//是否要求小写字母</span><br><span class="line">                options.Password.RequireNonAlphanumeric = false;//是否要求非数字非字母的字符</span><br><span class="line">                options.Password.RequireUppercase = false;//是否要求大写字母</span><br><span class="line">                options.Password.RequiredLength = 6;//长度</span><br><span class="line">                options.Tokens.PasswordResetTokenProvider = TokenOptions.DefaultEmailProvider;//密码重置</span><br><span class="line">                options.Tokens.EmailConfirmationTokenProvider = TokenOptions.DefaultEmailProvider;//邮箱配置</span><br><span class="line">            &#125;);</span><br><span class="line">            IdentityBuilder idBuilder = new IdentityBuilder(typeof(MyUser), typeof(MyRole), builder.Services);</span><br><span class="line">            idBuilder.AddEntityFrameworkStores&lt;MyDbContext&gt;()</span><br><span class="line">                .AddDefaultTokenProviders()</span><br><span class="line">                .AddUserManager&lt;UserManager&lt;MyUser&gt;&gt;()</span><br><span class="line">                .AddRoleManager&lt;RoleManager&lt;MyRole&gt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//Controller</span><br><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class DemoController : ControllerBase &#123;</span><br><span class="line">        private readonly UserManager&lt;MyUser&gt; userManager;</span><br><span class="line">        private readonly RoleManager&lt;MyRole&gt; roleManager;</span><br><span class="line">        private IWebHostEnvironment env;</span><br><span class="line"></span><br><span class="line">        public DemoController(UserManager&lt;MyUser&gt; userManager, RoleManager&lt;MyRole&gt; roleManager, IWebHostEnvironment env) &#123;</span><br><span class="line">            this.userManager = userManager;</span><br><span class="line">            this.roleManager = roleManager;</span><br><span class="line">            this.env = env;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        //创建用户</span><br><span class="line">        public async Task&lt;ActionResult&lt;string&gt;&gt;  Test1() &#123;</span><br><span class="line">           if(await roleManager.RoleExistsAsync(&quot;admin&quot;)==false) &#123;</span><br><span class="line">                MyRole role = new MyRole() &#123; Name = &quot;admin&quot;&#125;;</span><br><span class="line">                var result = await roleManager.CreateAsync(role);</span><br><span class="line">                if (!result.Succeeded) return BadRequest(&quot;roleManager,CreateAsync failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">           MyUser user1 =await userManager.FindByNameAsync(&quot;LJH&quot;);</span><br><span class="line">            if(user1==null) &#123;</span><br><span class="line">                user1 = new MyUser &#123; UserName = &quot;LJH&quot; &#125;;</span><br><span class="line">                var result = await userManager.CreateAsync(user1, &quot;123456&quot;);</span><br><span class="line">                if (!result.Succeeded) return BadRequest(&quot;userManager,CreateAsync failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(! await userManager.IsInRoleAsync(user1, &quot;admin&quot;)) &#123;</span><br><span class="line">               var result = await userManager.AddToRoleAsync(user1, &quot;admin&quot;);</span><br><span class="line">                if (!result.Succeeded) return BadRequest(&quot;userManager,AddToRoleAsync failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public async Task&lt;ActionResult&gt; CheckPwd(CheckPwdRequest req) &#123;</span><br><span class="line">            string userName = req.UserName;</span><br><span class="line">            string pwd = req.Password;</span><br><span class="line">            var user = await userManager.FindByNameAsync(userName);</span><br><span class="line">            if(user==null) &#123;</span><br><span class="line">                if(env.IsDevelopment()) &#123;</span><br><span class="line">                    return BadRequest(&quot;用户名不存在&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return BadRequest();//更安全</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            if(await userManager.IsLockedOutAsync(user)) &#123;</span><br><span class="line">                return BadRequest(&quot;用户已被锁定,锁定结束时间&quot;+user.LockoutEnd);</span><br><span class="line">            &#125;</span><br><span class="line">            if(await userManager.CheckPasswordAsync(user, pwd)) &#123;</span><br><span class="line">                await userManager.ResetAccessFailedCountAsync(user);</span><br><span class="line">                return Ok(&quot;登录成功&quot;);    </span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                await userManager.AccessFailedAsync(user);</span><br><span class="line">                return BadRequest(&quot;用户名或密码错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h2><p>流程：<br>1、生成重置Token<br>2、Token发给客户，形式：连接、验证码<br>3、根据Token实现密码重置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">       public async Task&lt;ActionResult&gt; SendRestPasswordToken(string userName) &#123;</span><br><span class="line">           var user = await userManager.FindByNameAsync(userName);</span><br><span class="line">           if(user==null) &#123;</span><br><span class="line">               return BadRequest(&quot;用户名不存在&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           string token = await userManager.GeneratePasswordResetTokenAsync(user);</span><br><span class="line">           Console.WriteLine(&quot;验证码是&quot; + token);</span><br><span class="line">           return Ok();</span><br><span class="line">       &#125;</span><br><span class="line">       [HttpPut]</span><br><span class="line">       public async Task&lt;ActionResult&gt; ResetPassword(string userName,string token,string newPassword) &#123;</span><br><span class="line">           var user = await userManager.FindByNameAsync(userName);</span><br><span class="line">           if (user == null) &#123;</span><br><span class="line">               return BadRequest(&quot;用户名不存在&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           var result = await userManager.ResetPasswordAsync(user, token, newPassword);</span><br><span class="line">           if(result.Succeeded) &#123;</span><br><span class="line">               await userManager.ResetAccessFailedCountAsync(user);</span><br><span class="line">               return Ok(&quot;密码重置成功&quot;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               await userManager.ResetAccessFailedCountAsync(user);</span><br><span class="line">               return BadRequest(&quot;密码重置失败&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 标识框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_中间件</title>
      <link href="/2023/09/13/Asp.NetCore-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2023/09/13/Asp.NetCore-%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我怕我解释不清楚，这里直接上课件<br><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/1.jpg"><br><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/2.jpg"><br><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/3.jpg"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们建立一个空的asp.net core项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args) &#123;</span><br><span class="line">            var builder = WebApplication.CreateBuilder(args);</span><br><span class="line">            var app = builder.Build();</span><br><span class="line"></span><br><span class="line">            //app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello World!&quot;);</span><br><span class="line">            app.Map(&quot;/test&quot;, async (pipeBuilder) =&gt; &#123;</span><br><span class="line">                pipeBuilder.Use(async (context, next) =&gt; &#123;</span><br><span class="line">                    context.Response.ContentType = &quot;text/html&quot;;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;1 Start &lt;br/&gt;&quot;);</span><br><span class="line">                    await next.Invoke();</span><br><span class="line">                    await context.Response.WriteAsync(&quot;1 End &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeBuilder.Use(async (context, next) =&gt; &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 Start &lt;br/&gt;&quot;);</span><br><span class="line">                    await next.Invoke();</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 End &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeBuilder.Run(async (context) =&gt; &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;Run &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            app.Run();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>以上仅为了演示，一般都在Run中输出内容，如果在Use中输出了内容，就不要next了，不然容易引起混乱。</p><h2 id="简单的自定义中间件"><a href="#简单的自定义中间件" class="headerlink" title="简单的自定义中间件"></a>简单的自定义中间件</h2><p>1、如果中间件的代码比较复杂，或者我们需要重复使用一个中间件的话，我们最好把中间件的代码放到一个单独的“中间件类”中。<br>2、中间件类是一个普通的类，不需要继承任何父类或者实现任何接口，但是这个类需要有一个构造方法，构造方法至少要有一个RequestDelegate类型的参数（就是上面的next），这个参数用来指向下一个中间件。这个类还需要定义一个名字为Invoke或者InvokeAsync的方法，方法至少有一个HttpContext类型的参数，方法的返回值必须是Task类型。中间件类的构造方法和Invoke（或者InvokeAsync）方法还可以定义其他参数，其他参数的值会通过依赖注入自动赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//自定义中间件类</span><br><span class="line">public class CheckAndParsingMiddleware &#123;</span><br><span class="line">        private readonly RequestDelegate next;</span><br><span class="line">        public CheckAndParsingMiddleware(RequestDelegate next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        public async Task InvokeAsync(HttpContext context) &#123;</span><br><span class="line">            string password = context.Request.Query[&quot;password&quot;];</span><br><span class="line">            if(password == &quot;123&quot;) &#123;</span><br><span class="line">                if (context.Request.HasJsonContentType()) &#123;</span><br><span class="line">                    //如果请求中有json就往下执行（浏览器看不出来，去postman上看）</span><br><span class="line"></span><br><span class="line">                    //如果password为123就将请求报文转为dynamic类型</span><br><span class="line">                    var reqStream = context.Request.BodyReader.AsStream();//转成流的格式</span><br><span class="line">                    //需要安装Dynamic.json包</span><br><span class="line">                    //目前（.net6）System.Text.Json不支持把json反序列化为dynamic类型</span><br><span class="line">                    dynamic? jsonObj = DJson.Parse(reqStream);</span><br><span class="line">                    context.Items[&quot;BodyJson&quot;] = jsonObj;</span><br><span class="line">                &#125;</span><br><span class="line">                await next.Invoke(context);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                context.Response.StatusCode = 401;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">app.Map(&quot;/test&quot;, async (pipeBuilder) =&gt; &#123;</span><br><span class="line">                pipeBuilder.UseMiddleware&lt;CheckAndParsingMiddleware&gt;();</span><br><span class="line">                pipeBuilder.Use(async (context, next) =&gt; &#123;</span><br><span class="line">                    context.Response.ContentType = &quot;text/html&quot;;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 Start &lt;br/&gt;&quot;);</span><br><span class="line">                    await next.Invoke();</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 End &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeBuilder.Run(async (context) =&gt; &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;Run &lt;br/&gt;&quot;);</span><br><span class="line">                    //context.Item可以在同一个请求中跨中间件进行消息传递</span><br><span class="line">                    dynamic obj = context.Items[&quot;BodyJson&quot;];</span><br><span class="line">                    if(obj != null) &#123;</span><br><span class="line">                        await context.Response.WriteAsync($&quot;&#123;obj.ToString()&#125;&lt;br/&gt;&quot;);</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="案例（Markdown渲染中间件）"><a href="#案例（Markdown渲染中间件）" class="headerlink" title="案例（Markdown渲染中间件）"></a>案例（Markdown渲染中间件）</h2><p>Markdown不被浏览器支持，所以编写一个在服务器端把Markdown转换为HTML的中间件。<br>我们开发的中间件是构件在ASP.NET Core内置的StaticFiles中间件之上，并且在它之前运行，所有的*.md文件都被放到wwwroot文件夹下，当我们请求wwwroot下其他静态文件时，StaticFiles中间件会把它们返回给浏览器，而当我们请求wwwroot下的*.md文件时，我们编写的中间件会读取对应的*.md文件，并把它们转换为HTML格式返回给浏览器<br>检测文本编码：<br>安装Ude.NetStandard包。<br>通过CharsetDetector类探测文件编码。<br>Markdown-&gt;HTML：<br>安装MarkdownSharp包。<br>通过Markdown实例的Transform()方法将md文本转换为html。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">using MarkdownSharp;</span><br><span class="line">using Microsoft.Extensions.Caching.Memory;</span><br><span class="line">using System.Text;</span><br><span class="line">using Ude;</span><br><span class="line"></span><br><span class="line">public class MarkDownViewerMiddleware &#123;</span><br><span class="line">    private readonly RequestDelegate next;</span><br><span class="line">    private readonly IWebHostEnvironment hostEnv;</span><br><span class="line">    private readonly IMemoryCache memCache;</span><br><span class="line"></span><br><span class="line">    public MarkDownViewerMiddleware(RequestDelegate next,</span><br><span class="line">        IWebHostEnvironment hostEnv, IMemoryCache memCache) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.hostEnv = hostEnv;</span><br><span class="line">        this.memCache = memCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 检测流的编码</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;stream&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    private static string DetectCharset(Stream stream) &#123;</span><br><span class="line">        CharsetDetector charDetector = new();</span><br><span class="line">        charDetector.Feed(stream);</span><br><span class="line">        charDetector.DataEnd();</span><br><span class="line">        string charset = charDetector.Charset ?? &quot;UTF-8&quot;;</span><br><span class="line">        stream.Position = 0;</span><br><span class="line">        return charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 读取文本内容</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;stream&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    private static async Task&lt;string&gt; ReadText(Stream stream) &#123;</span><br><span class="line">        string charset = DetectCharset(stream);</span><br><span class="line">        using var reader = new StreamReader(stream, Encoding.GetEncoding(charset));</span><br><span class="line">        return await reader.ReadToEndAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async Task InvokeAsync(HttpContext context) &#123;</span><br><span class="line">        string path = context.Request.Path.Value ?? &quot;&quot;;</span><br><span class="line">        if (!path.EndsWith(&quot;.md&quot;)) &#123;</span><br><span class="line">            await next(context);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var file = hostEnv.WebRootFileProvider.GetFileInfo(path);</span><br><span class="line">        if (!file.Exists) &#123;</span><br><span class="line">            await next(context);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        context.Response.ContentType = $&quot;text/html;charset=UTF-8&quot;;</span><br><span class="line">        context.Response.StatusCode = 200;</span><br><span class="line">        string cacheKey = nameof(MarkDownViewerMiddleware)</span><br><span class="line">            + path + file.LastModified;</span><br><span class="line">        var html = await memCache.GetOrCreateAsync(cacheKey, async ce =&gt; &#123;</span><br><span class="line">            ce.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(1);</span><br><span class="line">            using var stream = file.CreateReadStream();</span><br><span class="line">            string text = await ReadText(stream);</span><br><span class="line">            Markdown markdown = new Markdown();</span><br><span class="line">            return markdown.Transform(text);</span><br><span class="line">        &#125;);</span><br><span class="line">        await context.Response.WriteAsync(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">//注意中间件的位置</span><br><span class="line">            app.UseHttpsRedirection();</span><br><span class="line">            app.UseMiddleware&lt;MarkDownViewerMiddleware&gt;();</span><br><span class="line">            app.UseStaticFiles();</span><br></pre></td></tr></table></figure><h1 id="中间件和Filter的区别"><a href="#中间件和Filter的区别" class="headerlink" title="中间件和Filter的区别"></a>中间件和Filter的区别</h1><p><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/4.jpg"><br>区别：<br>1、中间件可以处理所有的请求，而Filter只能处理对控制器的请求；中间件运行在一个更底层、更抽象的级别，因此在中间件中无法处理MVC中间件特有的概念。<br>2、中间件和Filter可以完成很多相似的功能。“未处理异常中间件”和“未处理异常Filter”；“请求限流中间件”和“请求限流FIlter”<br>3、优先选择使用中间件；但是如果这个组件只针对MVC或者需要调用一些MVC相关的类的时候，我们就只能选择Filter</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 筛选器 </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_筛选器</title>
      <link href="/2023/09/13/Asp.NetCore-%E7%AD%9B%E9%80%89%E5%99%A8/"/>
      <url>/2023/09/13/Asp.NetCore-%E7%AD%9B%E9%80%89%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="筛选器Filter"><a href="#筛选器Filter" class="headerlink" title="筛选器Filter"></a>筛选器Filter</h1><p>1、Filter是面向切面编程机制，在ASP.NET Core特定的位置执行我们自定义的代码<br>2、有5种Filter类型：Authorization filter、Resource filter、Action filter、Exception filter、Result filter。<br>3、所有筛选器一般有同步异步两个版本比如IActionFilter、IAsyncActionFilter接口</p><h2 id="异常筛选器"><a href="#异常筛选器" class="headerlink" title="异常筛选器"></a>异常筛选器</h2><p>当系统中出现未经处理的异常时，异常筛选器会执行。<br>目标：当系统中出现未处理异常的时候，我们统一给客户端返回如下格式的响应报文：{“code”:”500”,”message”:”异常信息”}，对于开发环境中message是异常堆栈，对于其他环境message用一个general的报错信息。<br>实现：实现IAsyncExceptionFilter接口。注入IHostEnvironment得知运行环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Action方法</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string MakeErr() &#123;</span><br><span class="line">           string s =  System.IO.File.ReadAllText(&quot;f:/1.txt&quot;);</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//创建自定义异常筛选器</span><br><span class="line">    public class MyExceptionFilter : IAsyncExceptionFilter &#123;</span><br><span class="line">        private readonly IWebHostEnvironment webHostEnvironment;//将需要用到的服务注入，我们需要这个来判断当前为什么环境</span><br><span class="line">        public MyExceptionFilter(IWebHostEnvironment webHostEnvironment) &#123;</span><br><span class="line">            this.webHostEnvironment = webHostEnvironment;</span><br><span class="line">        &#125;</span><br><span class="line">        public Task OnExceptionAsync(ExceptionContext context) &#123;</span><br><span class="line">            //当Action中发生未处理异常，该方法会被调用</span><br><span class="line">            //context.Exception代表异常信息对象</span><br><span class="line">            //如果给context.ExceptionHandled赋值为true，其他的ExceptionFilter就不会再执行</span><br><span class="line">            //context.Result的值会被输出给客户端，是一个IActionResult类型的对象</span><br><span class="line">            string msg;</span><br><span class="line">            if(webHostEnvironment.IsDevelopment()) &#123;</span><br><span class="line">                //如果是开发环境</span><br><span class="line">                msg = context.Exception.ToString();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                msg = &quot;服务器端发生未处理异常&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //ObjectResult继承ActionResult实现IActionResult</span><br><span class="line">            ObjectResult obj = new ObjectResult(new &#123;code= 500 ,message = msg&#125;);</span><br><span class="line">            context.Result = obj;</span><br><span class="line">            context.ExceptionHandled = true;//告诉别的ExceptionFilter不用执行了</span><br><span class="line">            return Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">            builder.Services.Configure&lt;MvcOptions&gt;(options =&gt; &#123;</span><br><span class="line">                options.Filters.Add&lt;MyExceptionFilter&gt;();//注入自定义异常筛选器，注意！！！：多个筛选器Add的时候要注意顺序</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="Action筛选器"><a href="#Action筛选器" class="headerlink" title="Action筛选器"></a>Action筛选器</h2><p>用于控制器中每个action方法执行之前和之后执行自定义代码，比如在执行action之前判断用户有没有权限或者在执行之后记录日志。<br>一个筛选器分为前代码和后代码，有多个ActionFilter执行顺序为：<br>1前-&gt;2前-&gt;3前-&gt;Action-&gt;3后-&gt;2后-&gt;1后<br>自定义Action筛选器需要实现IActionFilter&#x2F;IAsyncActionFilter接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Action方法</span><br><span class="line">[HttpGet]</span><br><span class="line">        public string TestAction() &#123;</span><br><span class="line">            Console.WriteLine(&quot;执行中&quot;);</span><br><span class="line">            return &quot;执行中&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建自定义Action筛选器</span><br><span class="line">    public class MyActionFilter : IAsyncActionFilter &#123;</span><br><span class="line">        public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) &#123;</span><br><span class="line">            //next为委托，调用next()程序就会向下执行</span><br><span class="line">            Console.WriteLine(&quot;Action1执行前&quot;);</span><br><span class="line">            ActionExecutedContext result = await next();//next()的返回值表示action执行中是否出现异常</span><br><span class="line">            if(result.Exception != null) &#123;</span><br><span class="line">                Console.WriteLine(&quot;Action1发生了异常&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Console.WriteLine(&quot;Action1执行成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">            builder.Services.Configure&lt;MvcOptions&gt;(options =&gt; &#123;</span><br><span class="line">                options.Filters.Add&lt;MyActionFilter&gt;();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="筛选器案例"><a href="#筛选器案例" class="headerlink" title="筛选器案例"></a>筛选器案例</h2><h3 id="案例一（TransactionScope）"><a href="#案例一（TransactionScope）" class="headerlink" title="案例一（TransactionScope）"></a>案例一（TransactionScope）</h3><p>需求：<br>1、数据库事务：要么全部成功，要么全部失败。<br>2、自动化：启动、提交以及回滚事务。<br>3、当一段使用EFCore进行数据库操作的代码放到TransactionScope声明的范围中的时候，这段代码就会自动被标记为“支持事务”。<br>4、TransactionScope实现了IDisposable接口，如果一个TransactionScope的对象没有调用Complete()就执行了Dispose()方法，则事物会被回滚，否则事务就会被提交。<br>5、TransactionScope支持嵌套式事务，即便里面的TransactionScope已经提交，但是外面的TransactionScope失败了，事务依然会回滚。<br>6、.Net Core中的TransactionScope不像.Net FX一样有MSDTC分布式事务提升的问题，请使用最终一致性事务。<br>接下来我会用MySql数据库举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//appsetting.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ConnectionStrings&quot;: &#123;</span><br><span class="line">    &quot;DefaultConnection&quot;: &quot;server=localhost;user=root;password=your_password;database=your_database&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//实体类</span><br><span class="line">    public class Book &#123;</span><br><span class="line">        public long Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public double Price &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Person &#123;</span><br><span class="line">        public long Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public int Age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//连接数据库</span><br><span class="line">public class MyDbContext:DbContext &#123;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">        public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options) : base(options) &#123; </span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//自定义特性</span><br><span class="line">public class NotTransactionAttribute :Attribute&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//自动启用事务的ActionFilter</span><br><span class="line">    public class TransactionScopeFilter : IAsyncActionFilter &#123;</span><br><span class="line">        public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) &#123;</span><br><span class="line">            //context.ActionDescriptor中是当前被执行的Action方法的描述信息</span><br><span class="line">            //context.ActionArguments中是当前被执行的Action方法的参数信息</span><br><span class="line">            //context.ActionDescriptor.Parameters[0]是当前被执行的Action方法的第一个参数</span><br><span class="line">            ControllerActionDescriptor ctrlActionDesc = context.ActionDescriptor as ControllerActionDescriptor;</span><br><span class="line">            bool isTX = false;//是否进行事务控制</span><br><span class="line">            if(ctrlActionDesc != null) &#123;//是一个MVC的action</span><br><span class="line">                //ctrlActionDesc.MethodInfo当前的Action方法</span><br><span class="line">                bool hasNotTransactionAttribute = ctrlActionDesc.MethodInfo</span><br><span class="line">                    .GetCustomAttributes(typeof(NotTransactionAttribute), false)</span><br><span class="line">                    .Any();</span><br><span class="line">                isTX = !hasNotTransactionAttribute;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isTX) &#123;</span><br><span class="line">                using(TransactionScope tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled)) &#123;</span><br><span class="line">                    var r = await next();</span><br><span class="line">                    if(r.Exception == null) &#123;</span><br><span class="line">                        tx.Complete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                await next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">           builder.Services.AddDbContext&lt;MyDbContext&gt;(options =&gt; &#123;</span><br><span class="line">                string constr = builder.Configuration.GetSection(&quot;ConnectionStrings:DefaultConnection&quot;).Value;</span><br><span class="line">                var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">                options.UseMySql(constr, serverVersion);</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.Services.Configure&lt;MvcOptions&gt;(opt =&gt; &#123;</span><br><span class="line">                opt.Filters.Add&lt;TransactionScopeFilter&gt;();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//控制器</span><br><span class="line">    [Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class DemoController : ControllerBase &#123;</span><br><span class="line">        private MyDbContext ctx;</span><br><span class="line">        public DemoController(MyDbContext ctx) &#123;</span><br><span class="line">            this.ctx = ctx;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        [NotTransaction]</span><br><span class="line">        public string Test1() &#123;</span><br><span class="line">            using (TransactionScope tx = new TransactionScope()) &#123;</span><br><span class="line">                ctx.Books.Add(new Book &#123; Name = &quot;aaa&quot;, Price = 34 &#125;);</span><br><span class="line">                ctx.SaveChanges();//一个事务</span><br><span class="line">                ctx.Persons.Add(new Person &#123; Name = &quot;ljhljh&quot;, Age = 18 &#125;);</span><br><span class="line">                ctx.SaveChanges();//一个事务</span><br><span class="line">                tx.Complete();</span><br><span class="line">                return &quot;ok&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        [NotTransaction]</span><br><span class="line">        public async Task&lt;string&gt; Test2() &#123;</span><br><span class="line">            //异步需要向TransactionScope传入这个参数，原理是：</span><br><span class="line">            //同步的代码在TheadLocal中（相当于当前线程的全局变量）</span><br><span class="line">            //异步的代码在AsyncLocal中（相当于当前异步线程的全局变量）</span><br><span class="line">            using (TransactionScope tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled)) &#123;</span><br><span class="line">                ctx.Books.Add(new Book &#123; Name = &quot;aaa&quot;, Price = 34 &#125;);</span><br><span class="line">                await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">                ctx.Persons.Add(new Person &#123; Name = &quot;ljh&quot;, Age = 18 &#125;);</span><br><span class="line">                await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">                tx.Complete();</span><br><span class="line">                return &quot;ok&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public async Task&lt;string&gt; Test3() &#123;</span><br><span class="line">            ctx.Books.Add(new Book &#123; Name = &quot;aaa&quot;, Price = 34 &#125;);</span><br><span class="line">            await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">            ctx.Persons.Add(new Person &#123; Name = &quot;ljh&quot;, Age = 18 &#125;);</span><br><span class="line">            await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="案例二（限流器）"><a href="#案例二（限流器）" class="headerlink" title="案例二（限流器）"></a>案例二（限流器）</h3><p>需求：<br>对用户访问进行限流。<br>通过缓存机制，将用户的ip地址存放到缓存中。<br>如果缓存中ip已过期或者超过1秒就执行action。<br>ActionFilter可以在满足条件的时候终止操作方法的执行。<br>在ActionFilter中如果不调用next()就可以终止Action方法的执行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//筛选器</span><br><span class="line">    public class RateLimitFilter : IAsyncActionFilter &#123;</span><br><span class="line">        private readonly IMemoryCache memoryCache;</span><br><span class="line"></span><br><span class="line">        public RateLimitFilter(IMemoryCache memoryCache) &#123;</span><br><span class="line">            this.memoryCache = memoryCache;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) &#123;</span><br><span class="line">            string userIp = context.HttpContext.Connection.RemoteIpAddress.ToString();//用户ip</span><br><span class="line">            string cacheKey = $&quot;Limit_&#123;userIp&#125;&quot;;</span><br><span class="line">            long? lastTick = memoryCache.Get&lt;long?&gt;(cacheKey) ;//获取用户ip对应最后一次登录时间</span><br><span class="line">            if (lastTick == null || Environment.TickCount64 - lastTick &gt; 1000) &#123;</span><br><span class="line">                //如果用户ip缓存已过期或者超过一秒</span><br><span class="line">                memoryCache.Set(cacheKey, Environment.TickCount64,TimeSpan.FromSeconds(10));//存储当前时间并且设置10秒固定过期时间</span><br><span class="line">                return next();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               ObjectResult result = new ObjectResult(&quot;访问过于频繁&quot;)&#123; StatusCode = 429&#125;;</span><br><span class="line">                context.Result = result;</span><br><span class="line">                return Task.CompletedTask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(opt =&gt; &#123;</span><br><span class="line">                opt.Filters.Add&lt;TransactionScopeFilter&gt;();</span><br><span class="line">                opt.Filters.Add&lt;RateLimitFilter&gt;();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//控制器</span><br><span class="line">    [Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class RateLimitController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string LimitTest() &#123;</span><br><span class="line">            return &quot;响应结果……&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 筛选器 </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_EFCore</title>
      <link href="/2023/09/13/Asp.NetCore-EFCore/"/>
      <url>/2023/09/13/Asp.NetCore-EFCore/</url>
      
        <content type="html"><![CDATA[<h1 id="多层项目中EFCore的使用"><a href="#多层项目中EFCore的使用" class="headerlink" title="多层项目中EFCore的使用"></a>多层项目中EFCore的使用</h1><p>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    public long Id &#123; get ; set; &#125;</span><br><span class="line">    public string Title &#123; get; set; &#125;</span><br><span class="line">    public string AuthorName &#123; get; set; &#125;</span><br><span class="line">    public double Price &#123; get; set; &#125;</span><br><span class="line">    public DataSetDateTime PubDate &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">internal class BookConfig : IEntityTypeConfiguration&lt;Book&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Book&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Books&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>1、建立类库项目，放实体类、DbContext、配置类等。<br>DbContext中不配置数据库连接，而是为DbContext增加一个DbContextOptions类型的构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public  class MyDbContext:DbContext &#123;</span><br><span class="line">    public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">    public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options):base(options) &#123; &#125;</span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">        base.OnConfiguring(optionsBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        base.OnModelCreating(modelBuilder);</span><br><span class="line">        modelBuilder.ApplyConfigurationsFromAssembly</span><br><span class="line">            (this.GetType().Assembly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、EFCore项目安装对应数据库的EFCore Provider。<br>3、asp.net core项目引用EFCore项目，并且通过AddDbContext来注入DbContext及对DbContext进行配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddDbContext&lt;MyDbContext&gt;(opt =&gt; &#123;</span><br><span class="line">    string connStr = builder.Configuration.GetSection(&quot;ConnStr&quot;).Value;</span><br><span class="line">    var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">    opt.UseMySql(connStr, serverVersion);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4、Controller中就可以注入DbContext类使用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;api/[controller]/[action]&quot;)]</span><br><span class="line">[ApiController]</span><br><span class="line">public class TestController : ControllerBase &#123;</span><br><span class="line">    private readonly MyDbContext dbCtx;</span><br><span class="line">    public TestController(MyDbContext dbCtx) &#123;</span><br><span class="line">        this.dbCtx = dbCtx;</span><br><span class="line">    &#125;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    public string Deme1() &#123;</span><br><span class="line">        int c  = dbCtx.Books.Count();</span><br><span class="line">        return $&quot;C=&#123;c&#125;;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、让开发环境的Add-Migration知道连接哪个数据库，在EFCore项目中创建一个实现了IDesignTimeDbContextFactory的类，并且在CreateDbContext返回一个连接开发数据库的DbContext。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class MyDbContextDesignFac : IDesignTimeDbContextFactory&lt;MyDbContext&gt; &#123;</span><br><span class="line">    public MyDbContext CreateDbContext(string[] args) &#123;</span><br><span class="line">        DbContextOptionsBuilder&lt;MyDbContext&gt; builder = new DbContextOptionsBuilder&lt;MyDbContext&gt;();</span><br><span class="line">        string connStr = &quot;server=localhost;user=root;password=yourpassword;database=csharptest&quot;;</span><br><span class="line">        var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">        builder.UseMySql(connStr, serverVersion);</span><br><span class="line">        MyDbContext ctx = new MyDbContext(builder.Options);</span><br><span class="line">        return ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不在乎连接字符串被上传到Git，可以把连接字符串写死到CreatDbContext;如果在乎。那么CreateDbContext里面很难读取到vs中通过简单的方法设置的环境变量，所以必须把连接字符串配置到windows的正式的环境变量中，然后再Environment.GetEnvironmentVariable读取。<br>6、正常执行Add-Migration、Update-Database迁移就行了。需要把EFCore项目设置为启动项目，并且在【程序包管理器控制台】中也要选中EFCore项目，并且安装Microsoft.EntityFrameworkCore.SqlServer、Microsoft.EntityFrameworkCore.Tools</p><h1 id="AddDbContextPool"><a href="#AddDbContextPool" class="headerlink" title="AddDbContextPool"></a>AddDbContextPool</h1><p>AddDbContext是Scope模式的依赖注入，当一个请求结束后就会销毁DbContext实例，在请求多的情况下会有一定的性能影响。<br>AddDbContextPool是池化技术，不用每次创建和销毁，会有一点性能提升</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddDbContextPool&lt;MyDbContext&gt;(opt =&gt; &#123;</span><br><span class="line">    string connStr = builder.Configuration.GetSection(&quot;ConnStr&quot;).Value;</span><br><span class="line">    var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">    opt.UseMySql(connStr, serverVersion);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="可能带来的问题："><a href="#可能带来的问题：" class="headerlink" title="可能带来的问题："></a>可能带来的问题：</h2><p>1、AddDbContextPool注册的DbContext无法注入其他服务，因为这样注册的DbContext是Singleton的，在长生命周期的组件中无法注入短生命周期的组件，而大多数服务都不是Singleton的，所以可以理解成无法注入其他服务。<br>2、很多ADO.NET提供者都实现了数据库连接池机制，可能会有冲突，使用的时候需要自己调节。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_配置系统</title>
      <link href="/2023/09/13/Asp.NetCore-%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/13/Asp.NetCore-%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h1><h2 id="默认添加配置提供者"><a href="#默认添加配置提供者" class="headerlink" title="默认添加配置提供者"></a>默认添加配置提供者</h2><p>ASP.NET CORE默认添加的配置提供者：<br>1)加载现有的IConfiguration<br>2)加载项目根目录下的appsettings.json<br>3)加载项目根目录下的appsettings.{Environment}.json<br>4)当程序运行在开发环境在，程序会加载“用户机密”配置<br>5)加载环境变量中的配置<br>6)加载命令行中的配置</p><h2 id="开发、测试、生产环境"><a href="#开发、测试、生产环境" class="headerlink" title="开发、测试、生产环境"></a>开发、测试、生产环境</h2><p>不同的环境有不同的配置<br>运行环境：ASP.NET Core会从环境变量中读取名字为ASPNETCORE_ENVIRONMENT的值，推荐值：Development、Staging、Production。<br>读取方法：app.Environment.EnvironmentName、app.Environment.IsDevelopment()……<br>在windows和vs中设置环境变量的方法。</p><h2 id="机密信息"><a href="#机密信息" class="headerlink" title="机密信息"></a>机密信息</h2><p>1、把不方便放到appsetting.json中的机密信息放到一个不在项目中的json文件中。<br>2、在ASP.NET Core项目上单击鼠标右键，选择【管理用户机密】。<br>3、secrets.json文件和项目通过csproj文件中的&lt;UserSecretsId&gt;建立关系。<br>注意事项：<br>机密信息仅供开发人员使用。<br>仍然是明文存储，如果不想被人看到可通过Azure Key Vault、Zack.AnyDBConfigProvider等，但是无法完全避免。<br>如果因为重装、新员工等原因导致secrets.js重建，就要重新配置，如果影响大的话，还是用集中式配置服务器。</p><h2 id="配置系统的使用"><a href="#配置系统的使用" class="headerlink" title="配置系统的使用"></a>配置系统的使用</h2><p>其实没必要看我的，直接看文档就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">            builder.Configuration.AddJsonFile(&quot;MyConfig.json&quot;,//添加json配置文件</span><br><span class="line">                optional: true,</span><br><span class="line">                reloadOnChange: true</span><br><span class="line">            );</span><br><span class="line">            builder.Services.Configure&lt;Config&gt;(builder.Configuration);//将Config注入到DI中，并且绑定到根节点上</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//MyConfig.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;18&quot;,</span><br><span class="line">  &quot;proxy&quot;: &#123;</span><br><span class="line">    &quot;address&quot;: &quot;aa&quot;,</span><br><span class="line">    &quot;port&quot;: &quot;8080&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//ConfigController.cs</span><br><span class="line">    [Route(&quot;api/[controller]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class ConfigController : ControllerBase &#123;</span><br><span class="line">        private readonly IOptionsSnapshot&lt;Config&gt; optConfig;//在需要用到的地方依赖注入</span><br><span class="line">        public ConfigController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">            this.optConfig = optConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test() &#123;</span><br><span class="line">            return optConfig.Value.Proxy.Address;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 配置系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志系统</title>
      <link href="/2023/09/07/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/07/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>日志系统官方文档：<br><a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/logging?tabs=command-line">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/logging?tabs=command-line</a><br>日志级别：<br>Trace&lt;Debug&lt;Information&lt;Warning&lt;Error&lt;Critical<br>日志提供者（LoggingProvider）:<br>把日志输出到控制台、文件、数据库等。<br>对于业务代码只要注入日志对象记录日志即可，具体哪些日志输出到哪里、什么样的格式、是否输出等都有配置或者初始化代码决定。</p><h1 id="控制台日志"><a href="#控制台日志" class="headerlink" title="控制台日志"></a>控制台日志</h1><p>安装：Microsoft.Extensions.Logging、Microsoft.Extensions.Logging.Console</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line"></span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddLogging((logBuilder) =&gt; &#123;</span><br><span class="line">                logBuilder.AddConsole();</span><br><span class="line">                //logBuilder.AddEventLog();安装Microsoft.Extension.Logging.EventLog，这个只能windows用所以用的很少</span><br><span class="line">                logBuilder.SetMinimumLevel(LogLevel.Debug);//设置最低级别，不写这个看不到Debug信息</span><br><span class="line">            &#125;);</span><br><span class="line">            services.AddScoped&lt;Test1&gt;();</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               var test1 = sp.GetRequiredService&lt;Test1&gt;();</span><br><span class="line">                test1.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Test1 &#123;</span><br><span class="line">        //&lt;&gt;里面一般为当前类，这样可以直接从找到是哪个类记录了日志</span><br><span class="line">        private readonly ILogger&lt;Test1&gt; logger;</span><br><span class="line">        public Test1(ILogger&lt;Test1&gt; logger) &#123;</span><br><span class="line">            this.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Test() &#123;</span><br><span class="line">            logger.LogDebug(&quot;开始执行数据库同步&quot;);</span><br><span class="line">            logger.LogDebug(&quot;连接数据库成功&quot;);</span><br><span class="line">            logger.LogWarning(&quot;查找数据失败，重试第一次&quot;);</span><br><span class="line">            logger.LogWarning(&quot;查找数据失败，重试第二次&quot;);</span><br><span class="line">            logger.LogError(&quot;查找数据最终失败&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                File.ReadAllText(&quot;A:/1.txt&quot;);</span><br><span class="line">                logger.LogDebug(&quot;读取文件成功&quot;);</span><br><span class="line">            &#125;catch(Exception ex) &#123;</span><br><span class="line">                //通过该方法记录异常，可以传入异常对象</span><br><span class="line">                logger.LogError(ex,&quot;读取文件失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NLog文本日志"><a href="#NLog文本日志" class="headerlink" title="NLog文本日志"></a>NLog文本日志</h1><p>NLog官方文档：<br><a href="https://github.com/NLog/NLog/wiki/Getting-started-with-ASP.NET-Core-6">https://github.com/NLog/NLog/wiki/Getting-started-with-ASP.NET-Core-6</a><br>文本日志一般按照日期区分，为了避免磁盘被撑爆可以限制日志总个数或者总大小。<br>1、.Net没有内置文本日志提供者。第三方有Log4Net、NLog、Serilog等。老牌的Log4Net另搞一套，不考虑。<br>安装：<br>NLog.Extensions.Logging(using NLog.Extension.Logging;)。2、项目根目录下建nlog.config选择文件较新则赋值，注意文件名的大小写（考虑linux）。也可以是其他文件名，但是需要单独配置。约定大于配置。<br>3、增加logBuilder.AddNLog();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//nlog.config</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      autoReload=&quot;true&quot;</span><br><span class="line">      internalLogLevel=&quot;Info&quot;</span><br><span class="line">      internalLogFile=&quot;c:\temp\internal-nlog-AspNetCore.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- enable asp.net core layout renderers --&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;add assembly=&quot;NLog.Web.AspNetCore&quot;/&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- the targets to write to --&gt;</span><br><span class="line">  &lt;targets&gt;</span><br><span class="line">    &lt;!-- File Target for all log messages with basic details --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;File&quot; name=&quot;allfile&quot; fileName=&quot;c:\temp\nlog-AspNetCore-all-$&#123;shortdate&#125;.log&quot;</span><br><span class="line">            layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId:whenEmpty=0&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;File&quot; name=&quot;ownFile-web&quot; fileName=&quot;c:\temp\nlog-AspNetCore-own-$&#123;shortdate&#125;.log&quot;</span><br><span class="line">            layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId:whenEmpty=0&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;|url: $&#123;aspnet-request-url&#125;|action: $&#123;aspnet-mvc-action&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;Console&quot; name=&quot;lifetimeConsole&quot; layout=&quot;$&#123;MicrosoftConsoleLayout&#125;&quot; /&gt;</span><br><span class="line">  &lt;/targets&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- rules to map from logger name to target --&gt;</span><br><span class="line">  &lt;rules&gt;</span><br><span class="line">    &lt;!--All logs, including from Microsoft--&gt;</span><br><span class="line">    &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;allfile&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Output hosting lifetime messages to console target for faster startup detection --&gt;</span><br><span class="line">    &lt;logger name=&quot;Microsoft.Hosting.Lifetime&quot; minlevel=&quot;Info&quot; writeTo=&quot;lifetimeConsole, ownFile-web&quot; final=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --&gt;</span><br><span class="line">    &lt;logger name=&quot;Microsoft.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;logger name=&quot;System.Net.Http.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;ownFile-web&quot; /&gt;</span><br><span class="line">  &lt;/rules&gt;</span><br><span class="line">&lt;/nlog&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using NLog.Extensions.Logging;</span><br><span class="line">//============================</span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddLogging((logBuilder) =&gt; &#123;</span><br><span class="line">                logBuilder.AddNLog();</span><br><span class="line">            &#125;);</span><br><span class="line">            services.AddScoped&lt;Test1&gt;();</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               var test1 = sp.GetRequiredService&lt;Test1&gt;();</span><br><span class="line">                test1.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>nlog有多个traget表示日志输出到哪，rules中有多个logger，会从上往下匹配，用来配置日志规则（哪个级别输出到哪个target），匹配到final&#x3D;true就不再往下匹配。</p><h2 id="日志分类、过滤"><a href="#日志分类、过滤" class="headerlink" title="日志分类、过滤"></a>日志分类、过滤</h2><p>1、为什么要分类？不同级别或者不同模块的日志要记录到不同的地方。<br>2、为什么要过滤？项目不同阶段（比如刚上线和稳定后）需要记录的日志不同。严重错误可以调用短信Provider等。<br>3、搞一个新的类，放到SystemServices这个名称空间下，然后输出一些日志。然后调用很多次日志执行。nlog.config如备注所改。</p><h2 id="重要的参数"><a href="#重要的参数" class="headerlink" title="重要的参数"></a>重要的参数</h2><p>archiveAboveSize为”单个日志文件超过多少字节就把日志存档”，如果不设定maxArchiveFiles参数，则文件日志存档文件的数量会一直增加。<br>maxArchiveFiles指定数量个数的存档文件，旧的会被删掉。<br>maxArchiveDays设定保存若干天的日志存档。<br>通过设定这些参数实现滚动日志策略。</p><h2 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h2><p>rules节点下可以添加多个logger，每个logger都有name属性，name是通配符格式的。<br>logger节点的minlevel属性和maxlevel属性，表示这个logger接受日志的最低级别和最高级别。<br>日志输出时，会从上往下匹配rules节点下所有的logger，若发现当前日志的分类名和level符合这个logger的name的通配符，就会把日志输出给这个logger。如果匹配多个logger，就会把这条日志输出给多个logger。但是如果一个logger设置了final&#x3D;”true”，那么如果匹配到这个logger，就不继续向下匹配其他logger了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>NLog部分功能和.NET的Logging重复，比如分类、分级、各种Provider。<br>为了避免冲突，如果用NLog，建议不要再配置.NET的分级等。</p><h1 id="结构化日志"><a href="#结构化日志" class="headerlink" title="结构化日志"></a>结构化日志</h1><p>结构化日志比普通文本更利于日志的分析，比如统计“邮件发送失败”错误发生了多少次。</p><h1 id="集中化日志"><a href="#集中化日志" class="headerlink" title="集中化日志"></a>集中化日志</h1><p>集群化配置环境中，有N多个服务器，如果每个服务器都把日志记录到本地文件，不便于查询、分析。<br>需要把日志保存到集中化的日志服务器中。<br>NLog可以配置结构化日志不过比较麻烦更推荐——Serilog<br>Nuget安装：Serilog.AspNetCore。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = new LoggerConfiguration()</span><br><span class="line">                .MinimumLevel.Debug()</span><br><span class="line">                .Enrich.FromLogContext()</span><br><span class="line">                .WriteTo.Console(new JsonFormatter())</span><br><span class="line">                .CreateLogger();</span><br><span class="line">builder.AddSerilog();</span><br></pre></td></tr></table></figure><p>要记录的结构化数据通过占位符来输出：<br>logger.LogWaring(“新增用户{@person}”,new {Id &#x3D; 3,Name &#x3D; “zack”});<br>同样可以输出到文件、数据库、MongoDB等。</p><h2 id="集中日志服务"><a href="#集中日志服务" class="headerlink" title="集中日志服务"></a>集中日志服务</h2><p>使用NLog、Serilog等可以把日志记录到数据库，MongoDB等地方，就可以实现“结构化、集中日志服务”，不过需要自己编写日志分析程序。<br>公有云厂商一般都提供了日志云服务，都带有分析功能，都有对应Serilog插件，即使没有提供，开发一个插件也不麻烦。<br>如果没有用云平台或者想自己控制日志服务，可以使用Exceptionless或者ELK等</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>普通项目用NLog输出到文本文件即可，根据需要设定过滤、分类规则。<br>集群部署的项目用Serilog+集中式日志服务。如果需要记录结构化日志，再进行结构化输出。<br>如果用云服务的就够了，就用云服务，免得自己部署；如果想自己控制日志数据就用自部署Exceptionless或者ELK等。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Logging </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_缓存</title>
      <link href="/2023/09/07/Asp.NetCore-%E7%BC%93%E5%AD%98/"/>
      <url>/2023/09/07/Asp.NetCore-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存（Caching）是系统优化中简单又有效的工具，投入小收效大，数据库中的索引等简单有效的优化功能本质上都是缓存。<br>缓存的概念：缓存命中，缓存命中率，缓存数据不一致，多级缓存。</p><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><p>RFC7324是HTTP协议中对缓存进行控制的规范，其中重要的是cache-control这个响应报文头。服务器如果返回cache-control:max-age&#x3D;60,则表示服务器指示浏览器端“可以缓存这个相应内容60秒”。<br>我们只要给需要进行缓存控制的控制器的操作方法添加ResponseCache特性，ASP.NET Core就会自动添加cache-control报文头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class TimeController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        [ResponseCache(Duration = 10)]//缓存这个内容10秒</span><br><span class="line">        public DateTime GetTime([FromServices]Value value) &#123;</span><br><span class="line">            return DateTime.Now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端缓存"><a href="#服务器端缓存" class="headerlink" title="服务器端缓存"></a>服务器端缓存</h2><p>服务器端缓存位于浏览器和服务器执行代码之间。<br>如果ASP.NET Core中安装了“响应缓存中间件”，那么ASP.NET Core不仅会继续根据[ResponseCache]设置来生成cache-control响应报文头来设置客户端缓存，而且服务器端也会按照[ResponseCache]的设置来对响应进行服务器端缓存。服务器端的缓存对不同客户端都生效，而客户端缓存只对自身生效。<br>用法：<br>app.MapControllers()之前app.UseCors()之后加上app.UseResponseCaching()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure><p>大部分浏览器的“开发者工具”中可以禁用缓存，如果禁用了缓存，则在请求报文头中加入了”cache-control:no-cache”，如果加了该请求头，服务器端缓存和浏览器端缓存都会失效。<br>服务器端响应缓存还有很多限制，包括但不限于：响应状态码为200的GET或者HEAD请求才可能被缓存；报文头中不能含有Authorization、Set-Cookie等。<br>最好采用内存缓存、分布式缓存等。</p><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>1、把缓存数据放到应用程序的内存。内存缓存中保存的是一系列的键值对，就像字典类型一样。<br>2、内存缓存的数据保存在当前运行的网站程序的内存中，是和进程相关的。因为在web服务器中，多个不同网站是运行在不同的进程中的，因此不同网站的内存缓存是不会互相干扰的，而且网站重启后，内存缓存中的所有数据也就都被清空了。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>1、启用：builder.Services.AddMemoryCache()<br>2、注入IMemoryCache接口，查看接口的方法：TryGetValue、Remove、Set、GetOrCreate、GerOrCreateAsync</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">[ApiController]</span><br><span class="line">public class BookController : ControllerBase &#123;</span><br><span class="line">    private readonly IMemoryCache _memoryCache;//注入</span><br><span class="line">    public BookController(IMemoryCache memoryCache) &#123;</span><br><span class="line">        _memoryCache = memoryCache;</span><br><span class="line">    &#125;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    public async Task&lt;ActionResult&lt;Book?&gt;&gt; GetBookById(int Id) &#123;</span><br><span class="line">        var book = await _memoryCache.GetOrCreateAsync(&quot;Book&quot; + Id, async (e) =&gt; &#123;</span><br><span class="line">            return await DataBase.GetBookAsync(Id);</span><br><span class="line">        &#125;);</span><br><span class="line">        if(book == null) &#123;</span><br><span class="line">            return NotFound(&quot;未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Ok(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DataBase &#123;</span><br><span class="line">        public static Task&lt;Book?&gt; GetBookAsync(int Id) &#123;</span><br><span class="line">            return Task.FromResult(DataBase.GetBook(Id));</span><br><span class="line">        &#125;</span><br><span class="line">        public static Book? GetBook(int Id) &#123;</span><br><span class="line">            switch (Id) &#123;</span><br><span class="line">                case 1: return new Book() &#123; Id = 1, Name = &quot;C#图解教程&quot; &#125;;</span><br><span class="line">                case 2: return new Book() &#123; Id = 2, Name = &quot;Java从入门到精通&quot; &#125;;</span><br><span class="line">                case 3: return new Book() &#123; Id = 3, Name = &quot;C语言入门&quot; &#125;;</span><br><span class="line">                default: return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存过期"><a href="#缓存过期" class="headerlink" title="缓存过期"></a>缓存过期</h3><p>1、在数据改变的时候调用Remove或者Set来删除或者修改缓存。<br>2、绝对过期时间：<br>到了设定的时间就清除指定的缓存。<br>在GetOrCreateAsync()方法的回调函数中有一个ICacheEntry类型的的参数，通过ICacheEntry对当前的缓存项做设置。<br>AbsoluteExpirationRelativeToNow用来设定缓存项的绝对过期时间。<br>3、滑动过期时间：<br>在设定时间内如果继续发请求，就续命。<br>ICacheEntry的SlidingExpiration属性用来设定缓存项的滑动过期时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var book = await _memoryCache.GetOrCreateAsync(&quot;Book&quot; + Id, async (e) =&gt; &#123;</span><br><span class="line">    Console.WriteLine(&quot;去数据库找ID为&quot; + Id + &quot;的书&quot;);</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(30);//30秒绝对过期时间</span><br><span class="line">    e.SlidingExpiration = TimeSpan.FromSeconds(10);//10秒滑动过期时间</span><br><span class="line">    return await DataBase.GetBookAsync(Id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>混合过期时间：<br>使用滑动过期实践策略，如果一个缓存项一直被频繁访问，那么这个缓存项就会一直被续期而不过期。可以对一个缓存项同时设定滑动过期时间和绝对过期时间，并且把绝对过期时间设定的比滑动过期时间长，这样缓存项的内容会在绝对过期时间内伴随着访问被滑动续期，但是一超过绝对过期时间，缓存项就会被删除。</p><h1 id="缓存的问题"><a href="#缓存的问题" class="headerlink" title="缓存的问题"></a>缓存的问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var book = _memoryCache.Get&lt;Book?&gt;(&quot;Book&quot; + Id);</span><br><span class="line">if(book == null) &#123;//缓存中不存在</span><br><span class="line">    book = await DataBase.GetBookAsync(Id);</span><br><span class="line">    _memoryCache.Set(&quot;Book&quot; + Id, book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，当我们从缓存中得到了null，我们就认为缓存中不存在，于是在数据库中查询。但如果数据库中本来就不存在也会返回null，这样会造成一个问题，如果用户请求一个不存在的书ID，就会不停的访问数据库，这样的漏洞称为缓存穿透。<br>解决方法：<br>把查不到也当做一个数据放入缓存中。<br>当我们使用GetOrCreateAsync()方法时，该方法会把null当成合法的缓存值，所以即便不喜欢用回调函数也要尽量使用GetOrCreateAsync()方法。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>如果缓存中有很多数据，在固定的时间后统一失效，然后同时去数据库重新获取，就会造成数据库周期性的负载增大，进而造成缓存雪崩。<br>解决方法：<br>在基础过期时间之上，再加一个随机的过期时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(Random.Shared.Next(10,15));//随机10-15秒的过期时间</span><br></pre></td></tr></table></figure><h2 id="缓存数据混乱"><a href="#缓存数据混乱" class="headerlink" title="缓存数据混乱"></a>缓存数据混乱</h2><p>解决方法：合理给Key命名。</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>IQueryable、IEnumerable类型可能存在延迟加载的问题，如果把这两种类型的变量指向的对象保存到缓存中，在我们把它们取出来再去执行的时候，如果它们延迟加载时候需要的对象已经被释放，就会执行失败，因此需要禁止缓存这两种类型。</p><h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>如果集群节点的数量非常多的话，每个节点的数据不能共享，每个节点都需要相同的数据，就会到数据库服务器重复查询，可能会把数据库压垮。<br>不是再读取内存中的缓存，而是创建一个缓存服务器来存储缓存数据。<br>1、常用的分布式缓存服务器有Redis、Memcached等。<br>2、.Net Core中没有内置分布式缓存，但是提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法和内存缓存类似，用于可以更好的使用不同的分布式缓存服务器。<br>3、分布式缓存和内存缓存的区别：缓存值的类型为byte[]，需要我们进行类型转换，也提供了一些按照string类型存取缓存的扩展方法，string类型在底层还是转换成char[]。<br><img src="/images/Asp.NetCore%E5%88%9D%E7%BA%A7%E7%AF%87/1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book book = new Book();</span><br><span class="line">JsonSerializer.Deserialize&lt;Book&gt;(&quot;json字符串&quot;);//将json字符串转为对应对象</span><br><span class="line">JsonSerializer.Serialize(book);//将对象转为json字符串</span><br></pre></td></tr></table></figure><p>用SQLSever做缓存性能不好。<br>Memcached是缓存专用，性能高但是集群、高可用等方面较弱，而且有“缓存键的最大长度为250字节”等限制。可以安装EnyimMemcachedCore这个第三方NuGet包。<br>Redis不局限于缓存，虽然性能比Memcached性能稍差，但高可用、集群等非常强大，适合在数据量大、高可用性等场合使用。<br>我用Redis做个演示：<br>1、安装Microsoft.Extensions.Caching.StackExchangeRedis包。<br>2、注册服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddStackExchangeRedisCache(options =&gt;&#123;</span><br><span class="line">    options.Configuration = &quot;localhost&quot;;//缓存服务器地址</span><br><span class="line">    options.InstanceName = &quot;Cache1_&quot;;//Key的前缀，避免和其他数据冲突</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、使用服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private readonly IMemoryCache _memoryCache;//注入</span><br><span class="line">private readonly IDistributedCache _distributedCache;//注入</span><br><span class="line">public BookController(IMemoryCache memoryCache, IDistributedCache distributedCache) &#123;</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    _distributedCache = distributedCache;</span><br><span class="line">&#125;</span><br><span class="line">[HttpGet]</span><br><span class="line">public async Task&lt;ActionResult&lt;Book&gt;&gt; GetBookRedis(int Id) &#123;</span><br><span class="line">    Book? book;</span><br><span class="line">    string? str = await _distributedCache.GetStringAsync(&quot;Book&quot; + Id);</span><br><span class="line">    if(str == null) &#123;</span><br><span class="line">        await Console.Out.WriteLineAsync(&quot;去数据库查找&quot;);</span><br><span class="line">        book =await DataBase.GetBookAsync(Id);</span><br><span class="line">        await _distributedCache.SetStringAsync(&quot;Book&quot;+Id,JsonSerializer.Serialize(book));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        book = JsonSerializer.Deserialize&lt;Book&gt;(str);</span><br><span class="line">    &#125;</span><br><span class="line">    if (book == null) &#123;</span><br><span class="line">        Console.WriteLine(&quot;未找到ID为&quot; + Id + &quot;的书&quot;);</span><br><span class="line">        return NotFound(&quot;未找到&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Console.WriteLine(&quot;找到了ID为&quot; + Id + &quot;的书&quot;);</span><br><span class="line">        return Ok(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis不会出现缓存穿透问题，但需要自己处理一下缓存雪崩问题。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .NET </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_依赖注入</title>
      <link href="/2023/09/07/Asp.NetCore-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/07/Asp.NetCore-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h2 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h2><p>在ASP.NET Core项目中一般不需要自己创建ServiceCollection、IServiceProvider。在Program.cs的builder.Build()之前向builder.Services中注入。</p><p>在Controller中可以通过构造方法注入服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//控制器</span><br><span class="line"></span><br><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class SumController : ControllerBase &#123;</span><br><span class="line"></span><br><span class="line">        private readonly Value value;</span><br><span class="line"></span><br><span class="line">        public SumController(Value value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpGet]</span><br><span class="line"></span><br><span class="line">        public int GetValue() &#123;</span><br><span class="line">            return this.value.Sum(3, 4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Value &#123;</span><br><span class="line">        public int Sum(int a,int b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Program.cs</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped&lt;Value&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="低使用频率的服务"><a href="#低使用频率的服务" class="headerlink" title="低使用频率的服务"></a>低使用频率的服务</h2><p>可以把action用到的服务通过action的参数注入，在这个参数上标注[FromServices]。和action的其他参数不冲突。</p><p>一般不需要，只有调用频率不高并且资源的创建比较消耗资源的服务才[FromServices]。</p><p>只有action方法才能用[FromServices]，普通的类默认不支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//其余地方不变，只修改控制器即可</span><br><span class="line"></span><br><span class="line">public class SumController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public int GetValue([FromServices]Value value) &#123;</span><br><span class="line">            return value.Sum(6, 8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .NET </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_基本使用</title>
      <link href="/2023/09/07/Asp.NetCore-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/07/Asp.NetCore-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="初识ASP-NET-CORE-Web-Api"><a href="#初识ASP-NET-CORE-Web-Api" class="headerlink" title="初识ASP.NET CORE Web Api"></a>初识ASP.NET CORE Web Api</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AspTest.Controllers</span> &#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span> : <span class="title">ControllerBase</span> &#123;</span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserInfoRequest <span class="title">UserInfo</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> UserInfo =  <span class="keyword">new</span> UserInfoRequest();</span><br><span class="line">            UserInfo.Email = <span class="string">&quot;abc@123.com&quot;</span>;</span><br><span class="line">            UserInfo.Name = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">            UserInfo.Password = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> UserInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">UserInfoRequery</span>(<span class="params">UserInfoRequest userInfo</span>)</span> &#123;</span><br><span class="line">            Console.WriteLine(userInfo.Name);</span><br><span class="line">            Console.WriteLine(userInfo.Email);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Route特性内为访问路径。<br>web api比mvc少了视图，它的控制器依然以xxxController命名并且控制器类被[ApiController修饰]，其中xxx表示控制器的名字，它需要继承ControllerBase，当浏览器访问&#x2F;xxx路径时默认发起Get请求。<br>[HttpGet]、[HttpPost]用于修饰方法，该方法的返回值为http请求的响应内容（默认JSON）。<br><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/1.jpg"><br><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/2.jpg"></p><h1 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h1><p>web api风格有两种，一种是面向过程（RPC），一种是面向REST。</p><h2 id="RPC："><a href="#RPC：" class="headerlink" title="RPC："></a>RPC：</h2><p>通过“控制器&#x2F;操作方法”（有点像mvc）的形式把服务器端的代码当成方法去调用。把http当成传输数据的通道，不关心http谓词，通过QueryString、请求报文体给服务器传递数据，状态码。比如：&#x2F;Person&#x2F;GetAll、&#x2F;Person&#x2F;GetById?id&#x3D;8</p><h2 id="REST："><a href="#REST：" class="headerlink" title="REST："></a>REST：</h2><p>按照http语义来使用http协议。<br>URL用于资源的定位：&#x2F;user&#x2F;888、&#x2F;user&#x2F;888&#x2F;orders<br>http谓词有GET POST PUT DELETE PATCH等<br>DELETE PUT GET是幂等的<br>服务器端通过状态码来反应资源获取结果如404 403 201</p><h3 id="REST的优点"><a href="#REST的优点" class="headerlink" title="REST的优点"></a>REST的优点</h3><p>可以对GET、PUT、DELETE请求进行重试；<br>可以用GET请求做缓存；<br>通过HTTP状态码反映服务器端的处理结果，统一错误处理机制<br>网关等可以分析请求处理结果；</p><h3 id="REST的不足"><a href="#REST的不足" class="headerlink" title="REST的不足"></a>REST的不足</h3><p>很难清晰地进行资源的划分；<br>系统的进化可能会改变幂等；<br>有些环节会篡改非200响应码的响应报文；<br>有的客户端不支持PUT、DELETE</p><h1 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h1><p>方式：<br>URL、QueryString、请求报文体（不支持Get、Delete）</p><h2 id="RPC风格请求数据传递"><a href="#RPC风格请求数据传递" class="headerlink" title="RPC风格请求数据传递"></a>RPC风格请求数据传递</h2><p>控制器上[Route(“[controller]&#x2F;[action]”)]表示通过控制器名和方法名进行定位<br>强制要求控制器中不同的操作用不同的方法名<br>把[HttpGet]、[HttpPost]等添加到对应操作方法上<br>注意：如果控制器中存在一个没有添加[HttpGet]、[HttpPost]等的public方法，swagger就会报错，可以用[ApiExploreSetting(IgnoreApi &#x3D; true)]<br>action方法支持方法重载，GET和POST可以使用同名的函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AspTest.Controllers</span> &#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]/[action]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StudentController</span> : <span class="title">ControllerBase</span> &#123;</span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="keyword">public</span> Student? GetStdInfo(<span class="built_in">int</span> id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">18</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="number">18</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/3.jpg"></p><h2 id="控制器与返回值"><a href="#控制器与返回值" class="headerlink" title="控制器与返回值"></a>控制器与返回值</h2><p>控制器可以不继承ControllerBase，不继承的类更方便单元检测，但是会少了很多好用的方法，所以一般建议继承。<br>action函数支持异步。<br>可以让action函数返回IActionResult类型，但是不包含类型信息，因而Swagger等无法推断出类型，需要手动通过Ok()或NotFount()等方法转为IActionResult格式，所以更推荐用ActionResult&lt;T&gt;类型做返回值，T为实际返回类型，它支持类型转换（重写了隐式转换运算），从而用起来更简单。<br>web api中Action方法的返回值如果是普通数据类型，那么返回值就会默认被序列化为Json格式。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetStdInfo</span>(<span class="params"><span class="built_in">int</span> id</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Ok(<span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Ok(<span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>, <span class="number">2</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> NotFound(<span class="string">&quot;学生不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActionResult&lt;Student&gt; <span class="title">GetStudent</span>(<span class="params"><span class="built_in">int</span> id</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//可以将任何类型转为ActionResult类型</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>, <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非泛型ActionResult可以隐式转换为泛型ActionResult</span></span><br><span class="line">                <span class="keyword">return</span> NotFound(<span class="string">&quot;学生不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Action方法的参数"><a href="#Action方法的参数" class="headerlink" title="Action方法的参数"></a>Action方法的参数</h2><p>1、在[HttpGet]、[HttpPost]等中使用占位符比如{schoolName}捕捉路径中的内容，从而供Action方法的参数使用。<br>[HttpGet(“&#x2F;School&#x2F;{SchoolName}&#x2F;class&#x2F;{classNum}”)]<br>捕捉的值会自动赋值给Action中的同名参数，如果名字不一致可以用[FromRoute(Name&#x3D;”名字”)]。<br>2、使用[FromQuery]来获取QueryString中的值，如果名字一致，只要为参数添加[FromQuery]即可；如果名字不一致，则需要[FromQuery(Name&#x3D;”名字”)]，与[FromRoute(Name&#x3D;”名字”)]使用方法一致，这里不做演示。<br>3、QueryString和Route可以混用。<br>注意：一定要设置请求头中的Content-Type为application&#x2F;json</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserInfoRequest <span class="title">UserInfo</span>(<span class="params"><span class="built_in">string</span> Name</span>)</span> &#123;<span class="comment">//localhost:7190/Test?Name=张三  从QueryString获取参数</span></span><br><span class="line">            <span class="keyword">var</span> UserInfo =  <span class="keyword">new</span> UserInfoRequest();</span><br><span class="line">            UserInfo.Email = <span class="string">&quot;abc@123.com&quot;</span>;</span><br><span class="line">            UserInfo.Name = Name;</span><br><span class="line">            UserInfo.Password = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> UserInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">UserInfoRequery</span>(<span class="params">UserInfoRequest userInfo</span>)</span> &#123;<span class="comment">//localhost:/Test/从请求体获取参数</span></span><br><span class="line">            Console.WriteLine(userInfo.Name);</span><br><span class="line">            Console.WriteLine(userInfo.Email);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpGet(<span class="string">&quot;&#123;Value1&#125;/&#123;Value2&#125;&quot;</span>)</span>]<span class="comment">//localhost:7190/Test/66/99  从URL获取params参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetValues</span>(<span class="params"><span class="built_in">int</span> Value1, <span class="built_in">int</span> Value2</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;Value1:<span class="subst">&#123;Value1&#125;</span>,Value2:<span class="subst">&#123;Value2&#125;</span>&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpGet(<span class="string">&quot;A/&#123;B&#125;/C/&#123;D&#125;&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">GetABCD</span>(<span class="params"><span class="built_in">int</span> B, [FromRoute(Name =<span class="string">&quot;D&quot;</span></span>)] <span class="built_in">int</span> Dd)</span> &#123;<span class="comment">//localhost:7190/Test/GetABCD/A/66/C/99</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> &#123; B=B , D=Dd &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpGet(<span class="string">&quot;&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">MixTest</span>(<span class="params">[FromRoute] <span class="built_in">int</span> id, <span class="built_in">string</span> name</span>)</span> &#123;<span class="comment">//localhost:7190/Test/MixTest/3?name=张三</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> &#123; id = id, name = name &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/4.jpg"><br>从Content-Type为multipart&#x2F;from-data的请求中获取数据的[FromFrom]。<br>从请求报文头中获取值的[FromHeader]。</p><h1 id="处理跨域"><a href="#处理跨域" class="headerlink" title="处理跨域"></a>处理跨域</h1><p>CORS原理：在服务器的响应报文头中通过access-control-allow-origin告诉浏览器允许跨域访问的域名。<br>在Program.cs的 “var app &#x3D; builder.Build()” 这句之前注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] urls = <span class="keyword">new</span> []&#123;<span class="string">&quot;http://localhost:3000&quot;</span>&#125;;</span><br><span class="line">builder.Services.AddCors(</span><br><span class="line">    options=&gt;&#123;</span><br><span class="line">        options.AddDefaultPolicy(</span><br><span class="line">            builder=&gt;builder.WithOrigins(urls)</span><br><span class="line">            .AllowAnyMethods()</span><br><span class="line">            .AllowAnyHeader()</span><br><span class="line">            .AllowCredentials();</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在Program.cs的 “app.UseHttpsRedirection()”这句代码之前加一句”app.UseCors();”</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseCors();<span class="comment">//使用中间件</span></span><br><span class="line">app.UseHttpsRedirection();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asp.NetCore </tag>
            
            <tag> C# </tag>
            
            <tag> .NET </tag>
            
            <tag> REST </tag>
            
            <tag> RPC </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置系统</title>
      <link href="/2023/09/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>配置系统官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/configuration">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/configuration</a><br>.Net配置系统支持丰富的配置源包括文件、注册表、环境变量、命令行、Azure Key Vault等，还可以配置自定义配置源。可以跟踪配置的改变，可以按照优先级覆盖。<br>还支持ini、xml等格式的配置源。<br>还支持在运行时、调试时加载不同的json文件。<br>还内置或第三方支持中心化配置服务器，比如使用Apollo、Nacos等开源服务器，或使用Azure、阿里云等的配置服务</p><h1 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a>JSON配置</h1><p>安装Microsoft.Extensions.Configuration（配置框架的包）和Microsoft.Extensions.Configuration.Json（读json的包）<br>新建json文件，设置属性如果较新就赋值。<br>config.json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;18&quot;,</span><br><span class="line">  &quot;proxy&quot;: &#123;&quot;address&quot;: &quot;aa&quot;,&quot;port&quot;: &quot;8080&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原始使用方式"><a href="#原始使用方式" class="headerlink" title="原始使用方式"></a>原始使用方式</h2><p>AddJsonFile()命名参数介绍<br>optional表示文件是否可选<br>reloadOnChange参数表示如果文件修改了，是否重新加载设置（可以不重启就加载）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">            configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">            IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">            //原始方式</span><br><span class="line">            string name = configurationRoot[&quot;name&quot;];</span><br><span class="line">            string address = configurationRoot.GetSection(&quot;proxy:address&quot;).Value;</span><br><span class="line">            Console.WriteLine($&quot;name = &#123;name&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;address = &#123;address&#125;&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="绑定对象方式"><a href="#绑定对象方式" class="headerlink" title="绑定对象方式"></a>绑定对象方式</h2><p>安装Microsoft.Extensions.Configuration.Binder<br>有自动类型转换，自定义的类的属性名应与配置文件中的键名一致（拼写一致就行，不区分大小写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">            configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">            IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">            //绑定对象方式</span><br><span class="line">            Proxy proxy = configurationRoot.GetSection(&quot;proxy&quot;).Get&lt;Proxy&gt;();</span><br><span class="line">            Console.WriteLine($&quot;&#123;proxy.Address&#125;:&#123;proxy.Port&#125;&quot;);</span><br><span class="line">            Config config = configurationRoot.Get&lt;Config&gt;();</span><br><span class="line">            Console.WriteLine($&quot;&#123;config.Name&#125;,&#123;config.Age&#125;,&#123;config.Proxy.Address&#125;,&#123;config.Proxy.Port&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Config &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public string Age &#123; get; set; &#125;</span><br><span class="line">        public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Proxy &#123;</span><br><span class="line">        public string Address &#123; get; set; &#125;</span><br><span class="line">        public int Port &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入方式（更推荐）"><a href="#依赖注入方式（更推荐）" class="headerlink" title="依赖注入方式（更推荐）"></a>依赖注入方式（更推荐）</h2><p>在需要读取配置的地方，用IOptionsSnapshot&lt;T&gt;注入。不要在构造函数里直接读取IOptionsSnapshot.Value，而是到用到的地方再读取，否则就无法更新变化。<br>读取配置时，DI要声明IOptions&lt;T&gt;（旧的值）、IOptionsMonitor&lt;T&gt;（新的值）、IOptionsSnapshot&lt;T&gt;（一个范围内新的值）等类型，建议用IOptionsSnapshot。<br>安装：<br>Microsoft.Extensions.Configuration.Binder<br>Microsoft.Extensions.Configuration<br>Microsoft.Extensions.Configuration.Json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           ServiceCollection services = new ServiceCollection();</span><br><span class="line">           services.AddScoped&lt;TestController&gt;();</span><br><span class="line">           services.AddScoped&lt;Test2&gt;();</span><br><span class="line"> </span><br><span class="line">           ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">           configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">           IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line"></span><br><span class="line">           services.AddOptions()</span><br><span class="line">               .Configure&lt;Config&gt;(e =&gt; configurationRoot.Bind(e))//DI将根节点绑定到Config对象上并且将Config类型注册到依赖注入容器中</span><br><span class="line">               .Configure&lt;Proxy&gt;(e=&gt; configurationRoot.GetSection(&quot;proxy&quot;).Bind(e));//将proxy节点绑定到Proxy对象上并且将Proxy类型注册到依赖注入容器中</span><br><span class="line"></span><br><span class="line">           using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               //因为我们使用了IOptionSnapshot，所以修改文件时不会改变，相当于在一个大scope中</span><br><span class="line">               while (true) &#123;</span><br><span class="line">                   //如果想改变时获取新的数据，可以手动新建scope</span><br><span class="line">                   using(var scope = sp.CreateScope()) &#123;</span><br><span class="line">                       var c = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                       c.Test();</span><br><span class="line">                       Console.WriteLine(&quot;改一下age&quot;);</span><br><span class="line">                       Console.ReadLine();</span><br><span class="line">                       c.Test();</span><br><span class="line">                       var c2 = scope.ServiceProvider.GetRequiredService&lt;Test2&gt;();</span><br><span class="line">                       c2.Test();</span><br><span class="line">                       //注意：你无法通过以下方式获取配置对象</span><br><span class="line">                       //var config = scope.ServiceProvider.GetRequiredService&lt;Config&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   Console.WriteLine(&quot;点击任意键继续&quot;);</span><br><span class="line">                   Console.ReadLine();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Config &#123;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">       public string Age &#123; get; set; &#125;</span><br><span class="line">       public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Proxy &#123;</span><br><span class="line">       public string Address &#123; get; set; &#125;</span><br><span class="line">       public int Port &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class TestController &#123;</span><br><span class="line">       //创建IOptionsSnapshot&lt;&gt;类型成员，为依赖注入提供条件</span><br><span class="line">       public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">       public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">           this.optConfig = optConfig;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(this.optConfig.Value.Age);</span><br><span class="line">           Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class Test2 &#123;</span><br><span class="line">       private readonly IOptionsSnapshot&lt;Proxy&gt; optProxy;</span><br><span class="line">       public Test2(IOptionsSnapshot&lt;Proxy&gt; optProxy) &#123;</span><br><span class="line">           this.optProxy = optProxy;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(optProxy.Value.Address);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h1><h2 id="命令行简单配置："><a href="#命令行简单配置：" class="headerlink" title="命令行简单配置："></a>命令行简单配置：</h2><p>安装Microsoft.Extensions.Configuration.CommandLine<br>支持 server &#x3D; 127.0.0.1、–server&#x3D;127.0.0.1、 –server 127.0.0.1等，注意在键值之间加空格，格式不能混用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddScoped&lt;TestController&gt;();</span><br><span class="line">            services.AddScoped&lt;Test2&gt;();</span><br><span class="line">            ConfigurationBuilder configBuder = new ConfigurationBuilder();</span><br><span class="line">            configBuder.AddCommandLine(args);//推荐传这个</span><br><span class="line">            IConfigurationRoot configRoot = configBuder.Build();</span><br><span class="line">            services.AddOptions()</span><br><span class="line">                .Configure&lt;Config&gt;(e =&gt; configRoot.Bind(e))</span><br><span class="line">                .Configure&lt;Proxy&gt;(e =&gt; configRoot.GetSection(&quot;Proxy&quot;));</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                while(true) &#123;</span><br><span class="line">                    using(var scope = sp.CreateScope()) &#123;</span><br><span class="line">                        var c1 = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                        var c2 = scope.ServiceProvider.GetRequiredService&lt;Test2&gt;();</span><br><span class="line">                        c1.Test();</span><br><span class="line">                        c2.Test();</span><br><span class="line">                        Console.ReadLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Config &#123;</span><br><span class="line">            public string Name &#123; get; set; &#125;</span><br><span class="line">            public int Age &#123; get; set; &#125;</span><br><span class="line">            public Proxy proxy &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public class Proxy &#123;</span><br><span class="line">            public string Address &#123; get; set; &#125;</span><br><span class="line">            public int Port &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        internal class TestController &#123;</span><br><span class="line">       public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">       public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">           this.optConfig = optConfig;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(this.optConfig.Value.Age);</span><br><span class="line">           Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class Test2 &#123;</span><br><span class="line">       private readonly IOptionsSnapshot&lt;Proxy&gt; optProxy;</span><br><span class="line">       public Test2(IOptionsSnapshot&lt;Proxy&gt; optProxy) &#123;</span><br><span class="line">           this.optProxy = optProxy;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(optProxy.Value.Address);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以这样运行：<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/1.jpg"><br>或者使用vs右键项目-&gt;属性-&gt;调试-&gt;启动配置文件：<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/2.jpg"></p><h2 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h2><p>对于多级结构需要用root:key&#x3D;value的方式来进行扁平化处理<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/3.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Config &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public int Age &#123; get; set; &#125;</span><br><span class="line">        public Proxy proxy &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Proxy &#123;</span><br><span class="line">        public string Address &#123; get; set; &#125;</span><br><span class="line">        public int Port &#123; get; set; &#125;</span><br><span class="line">        public int[] Ids &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    internal class TestController &#123;</span><br><span class="line">    public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">    public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">        this.optConfig = optConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Test() &#123;</span><br><span class="line">        Console.WriteLine(optConfig.Value.Name);</span><br><span class="line">        Console.WriteLine(optConfig.Value.Age);</span><br><span class="line">        Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">        Console.WriteLine(optConfig.Value.proxy.Address);</span><br><span class="line">        Console.WriteLine(optConfig.Value.proxy.Port);</span><br><span class="line">        Console.WriteLine(string.Join(&#x27;,&#x27;, optConfig.Value.proxy.Ids));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/4.jpg"><br>注意遇到深层次结构还是需要做扁平化处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configBuder.AddEnvironmentVariables();</span><br></pre></td></tr></table></figure><p>还可以传一个名为prefix的字符串参数，这个参数是所需要的环境变量的前缀为了防止和系统其他环境变量冲突，记得修改自己写的环境变量为其添加前缀。</p><h1 id="开发自己的配置提供者"><a href="#开发自己的配置提供者" class="headerlink" title="开发自己的配置提供者"></a>开发自己的配置提供者</h1><p>1、开发一个直接或间接实现IConfigurationProvider接口的类XXXConfigurationProvider，一般直接继承ConfigurationProvider。如果是从文件读取，可以继承自FileConfigurationProvider。重写Load方法，把”扁平化数据”设置到Data属性即可。<br>2、再开发一个实现了IConfigurationSource接口的类XXXIConfigurationSource。如果是从文件读取，可以继承自FileConfigurationSource。在Build方法中返回上面的ConfigurationProvider对象。<br>3、然后使用即可，configurationBuilder.Add(new ConfigurationSource())即可。为了简化使用，一般提供一个IConfigurationBuilder的扩展方法<br>整体流程：<br>编写ConfigurationProvider类实际读取配置；编写ConfigurationSource在Build中返回ConfigurationProvider对象；把ConfigurationSource对象加入IConfigurationBuilder。记得在返回之前加一句EnsureDefaults(builder)用于处理默认值问题。<br>配置文件格式：<br>开发web.config提供者<br>.net core中不建议使用.net framework里的web.config，不过仍然继续提供了ConfigurationManager的方式。我们来实现一个能够读取web.config里的connectionStrings和appSettings的内容<br>具体内容我没看明白，请看杨中科老师的视频吧：<a href="https://www.bilibili.com/video/BV1pK41137He?p=43&vd_source=b855e022b9c5c6c637f3aa9babc2e438">https://www.bilibili.com/video/BV1pK41137He?p=43&amp;vd_source=b855e022b9c5c6c637f3aa9babc2e438</a></p><h1 id="多配置源"><a href="#多配置源" class="headerlink" title="多配置源"></a>多配置源</h1><p>比如某个网站需要自定义配置；程序员的同一台机器上，开发调试环境和测试环境用不同的配置。<br>按照注册到ConfigurationBuilder的顺序，后来者居上，后注册的优先级高，如果配置名字重复，用后注册的值</p><h1 id="保命的UserSecrets"><a href="#保命的UserSecrets" class="headerlink" title="保命的UserSecrets"></a>保命的UserSecrets</h1><p>.net提供了user-secrets机制，user-secrets的配置不会放到源代码中<br>不能泄露到源码中的配置放到user-secrets即可，不用都放<br>一般把user-secrets优先级放到普通json文件之后。<br>如果开发人员电脑重装系统等原因造成本地的配置文件被删除了，就需要重新配置<br>并不是生产中的加密，只适用于开发<br>安装：<br>Microsoft.Extensions.Configuration.UserSecrets<br>在vs项目上点右键【管理用户机密】，编辑这个配置文件。看看这个文件在哪里。在csproj中的UserSecretsld就是文件夹的名字<br>configBuilder.AddUserSecrets&lt;Program&gt;()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//secrets.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;password&quot;:&quot;secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//主程序</span><br><span class="line">var builder = new ConfigurationBuilder();</span><br><span class="line">builder.AddJsonFile(&quot;config.json&quot;, true, true);</span><br><span class="line">builder.AddCommandLine(args);</span><br><span class="line">builder.AddUserSecrets&lt;Program&gt;();</span><br></pre></td></tr></table></figure><p>记得在除了secrets.json以外的所有配置地方删除私密的数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建容器</span><br><span class="line">ServiceCollection services = new ServiceCollection();</span><br><span class="line">//添加服务</span><br><span class="line">services.AddScoped&lt;TestController&gt;();</span><br><span class="line">//创建提供方</span><br><span class="line">var sp = services.BuildServiceProvider();</span><br><span class="line">//获取对象</span><br><span class="line">sp.GetService&lt;Test&gt;();</span><br></pre></td></tr></table></figure><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建配置创建者 </span><br><span class="line">ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">//添加配置方</span><br><span class="line">configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">//创建根节点</span><br><span class="line">IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">//通过根节点找到数据</span><br><span class="line">string address = configurationRoot.GetSection(&quot;proxy:address&quot;).Value;</span><br><span class="line">//或绑定对象</span><br><span class="line">Proxy proxy = configurationRoot.GetSection(&quot;proxy&quot;).Get&lt;Proxy&gt;();</span><br><span class="line">//或通过依赖注入绑定对象</span><br><span class="line">services.AddOptions()  </span><br><span class="line">               .Configure&lt;Config&gt;(e =&gt; configurationRoot.Bind(e))  </span><br><span class="line">               .Configure&lt;Proxy&gt;(e=&gt; configurationRoot.GetSection(&quot;proxy&quot;).Bind(e));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 配置系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元检测</title>
      <link href="/2023/09/04/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/"/>
      <url>/2023/09/04/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h2><p>当我们要查看某个方法是否有错误，我们可以创建一个专门用来测试的类，用于不调用主程序的情况下，在测试类中检测方法是否符合所期待的那样。这样的行为称为单元检测或单元测试。</p><h2 id="单元检测演示"><a href="#单元检测演示" class="headerlink" title="单元检测演示"></a>单元检测演示</h2><p>一台电脑如果想玩3A游戏的话当然需要一个好的显卡，能玩游戏的显卡就是好显卡，我们可以使用单元检测来判断。<br>主程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            IGraphicsCard card = new NVIDIA();</span><br><span class="line">            Console.WriteLine(card.Show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface IGraphicsCard &#123;</span><br><span class="line">        string Show();</span><br><span class="line">    &#125;</span><br><span class="line">    public class NVIDIA:IGraphicsCard &#123; </span><br><span class="line">        public string Show() &#123;</span><br><span class="line">            return &quot;正在玩原神&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class AMD:IGraphicsCard &#123; </span><br><span class="line">        public string Show() &#123;</span><br><span class="line">            return &quot;正在玩星穹铁道&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元检测程序：<br>请先创建单元测试项目<br><img src="/images/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using Test;//引用主程序名称空间</span><br><span class="line">namespace GraphicsCardTest &#123;</span><br><span class="line">    public class GraphicsCardTest &#123;//测试类</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test1() &#123;//测试方法</span><br><span class="line">            var gc = new NVIDIA();</span><br><span class="line">            var expected = &quot;正在玩原神&quot;;//如果NVIDIA显卡能玩原神则成功</span><br><span class="line">            var actual = gc.Show();</span><br><span class="line">            Assert.Equal(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test2() &#123;//测试方法</span><br><span class="line">            var gc = new AMD();</span><br><span class="line">            var expected = &quot;正在玩星穹铁道&quot;;//如果AMD显卡能玩星穹铁道则成功</span><br><span class="line">            var actual = gc.Show();</span><br><span class="line">            Assert.Equal(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="/images/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 单元检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2023/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>依赖注入官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection</a><br>依赖注入的原理是——反射<br>如果想用依赖注入框架需要：<br>先用NuGet下载Microsoft.Extensions.DependencyInjection。<br>使用名称空间using Microsoft.Extensions.DependencyInjection;</p><h1 id="依赖注入框架的简单使用"><a href="#依赖注入框架的简单使用" class="headerlink" title="依赖注入框架的简单使用"></a>依赖注入框架的简单使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var sc = new ServiceCollection();//创建容器</span><br><span class="line">            sc.AddScoped(typeof(IStudent),typeof(Student));//接口描述，绑定该接口的类型的描述</span><br><span class="line">            var sp = sc.BuildServiceProvider();</span><br><span class="line">            // ==============================以下不再有new操作符</span><br><span class="line">            IStudent student = sp.GetService&lt;IStudent&gt;();</span><br><span class="line">            student.Study();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStudent &#123;</span><br><span class="line">        void Study();</span><br><span class="line">    &#125;</span><br><span class="line">    class Student : IStudent &#123;</span><br><span class="line">        public void Study() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我要学习&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 依赖注入的几个概念<br> 服务：就是你需要的对象；<br> 注册服务：对象不能凭空出现，需要先注册；<br> 服务容器：负责管理注册的服务<br> 查询服务：创建对象及关联对象；<br> 对象生命周期：Transient（瞬态）、Scoped（范围内单例）、Singleton（单例）；<br> 可以指定服务类型和实现类型，或者服务类型和实现类型是同一类型<br> 服务类型尽量用接口<br> 微软的控制反转组件（DependencyInjection）包含服务定位器和依赖反转</p><h1 id="服务定位器的写法"><a href="#服务定位器的写法" class="headerlink" title="服务定位器的写法"></a>服务定位器的写法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            //1、创建容器</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //2、注册服务</span><br><span class="line">            services.AddTransient&lt;TestServiceImp1&gt;();</span><br><span class="line">            //3、创建服务提供者（相当于服务定位器）</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //4、从提供者获取服务</span><br><span class="line">                TestServiceImp1 t1 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t1.Name = &quot;Test1&quot;;</span><br><span class="line">                t1.SayHi();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public void SayHi();</span><br><span class="line">    &#125;</span><br><span class="line">    public class TestServiceImp1 : ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public void SayHi() &#123;</span><br><span class="line">            Console.WriteLine(&quot;hi&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class TestServiceImp2 : ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public void SayHi() &#123;</span><br><span class="line">            Console.WriteLine(&quot;你好&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="瞬时模式与单例模式Transient、Singleton"><a href="#瞬时模式与单例模式Transient、Singleton" class="headerlink" title="瞬时模式与单例模式Transient、Singleton"></a>瞬时模式与单例模式Transient、Singleton</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //Transient</span><br><span class="line">            //services.AddTransient&lt;TestServiceImp1&gt;();</span><br><span class="line">            //Singleton</span><br><span class="line">            //services.AddSingleton&lt;TestServiceImp1&gt;();</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                TestServiceImp1 t1 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t1.Name = &quot;Test1&quot;;</span><br><span class="line">                TestServiceImp1 t2 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t2.Name = &quot;Test2&quot;;</span><br><span class="line">                Console.WriteLine(object.ReferenceEquals(t1, t2));//判断是否为同一对象</span><br><span class="line">                Console.WriteLine(t1.Name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="范围模式Scope"><a href="#范围模式Scope" class="headerlink" title="范围模式Scope"></a>范围模式Scope</h2><p>Scope<br>如果一个类实现了IDisposable接口，则离开作用域之后，容器会自动调用对象的Dispose方法<br>不要在长生命周期的对象中引用比它短的声明周期的对象<br>生命周期的选择：<br>如果类无状态（无属性，无成员变量），建议为Singleton；如果类有状态，且有Scope控制，建议为Scoped，因为通常这种Scope控制下的代码都是运行在同一线程中，没有并发修改的问题；使用Transient要谨慎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //Scoped</span><br><span class="line">            services.AddScoped&lt;TestServiceImp1&gt;();</span><br><span class="line">            //老大sp</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //老大创造了小弟scope1</span><br><span class="line">                //创建范围，这个范围就是using的代码块</span><br><span class="line">                using (IServiceScope scope1 = sp.CreateScope()) &#123;</span><br><span class="line">                    //在scope中获取Scope相关的对象，scope1.ServiceProvider而不是sp</span><br><span class="line">                    //想获取服务不能直接问老大要，应该问小弟scope1要</span><br><span class="line">                    TestServiceImp1 t1 = scope1.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    TestServiceImp1 t2 = scope1.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    Console.WriteLine(object.ReferenceEquals(t1, t2));</span><br><span class="line">                &#125;</span><br><span class="line">                //老大创造小弟scope2</span><br><span class="line">                //创建范围，这个范围就是using的代码块</span><br><span class="line">                using (IServiceScope scope2 = sp.CreateScope()) &#123;</span><br><span class="line">                    //在scope中获取Scope相关的对象，scope1.ServiceProvider而不是sp</span><br><span class="line">                    //想获取服务不能直接问老大要，应该问小弟scope2要</span><br><span class="line">                    TestServiceImp1 t1 = scope2.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    TestServiceImp1 t2 = scope2.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    Console.WriteLine(object.ReferenceEquals(t1, t2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h2><p>当服务类型与实现类型不一致时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //泛型方法</span><br><span class="line">            services.AddScoped&lt;ITestService, TestServiceImp1&gt;();</span><br><span class="line">            services.AddScoped&lt;ITestService, TestServiceImp2&gt;();</span><br><span class="line">            //非泛型方法</span><br><span class="line">            //services.AddScoped(typeof(ITestService),typeof(TestServiceImp1));</span><br><span class="line">            //自定义单例对象</span><br><span class="line">            //services.AddSingleton(typeof(ITestService),new TestServiceImp1());</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //获取服务时，&lt;&gt;里面是注册类型而不是实现类型</span><br><span class="line">                //如果找不到服务就返回null</span><br><span class="line">                ITestService ts1 = sp.GetService&lt;ITestService&gt;();</span><br><span class="line">                //如果找不到直接抛异常而不是返回null</span><br><span class="line">                //ITestService ts1 = sp.GetRequiredService&lt;ITestService&gt;();</span><br><span class="line">                //非泛型方法，返回object，使用时需要手动转换</span><br><span class="line">                //ITestService ts1 = (ITestService)sp.GetService(typeof(ITestService));</span><br><span class="line">                //一个注册类型对应多个实现类型时，可以获取全部</span><br><span class="line">                //如果不用GetServices而用GetService就以最后一个添加进来的为准</span><br><span class="line">                IEnumerable&lt;ITestService&gt; tests = sp.GetServices&lt;ITestService&gt;();</span><br><span class="line">                foreach (ITestService test in tests) &#123;</span><br><span class="line">                    Console.WriteLine(test.GetType());</span><br><span class="line">                &#125;</span><br><span class="line">                ts1.Name = &quot;Test1&quot;;</span><br><span class="line">                ts1.SayHi();</span><br><span class="line">                Console.WriteLine(ts1.GetType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="依赖注入写法"><a href="#依赖注入写法" class="headerlink" title="依赖注入写法"></a>依赖注入写法</h1><p>依赖注入是有传染性的，如果一个类的对象是通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值；但如果一个对象是程序员手动创建的，那么这个类就和DI没有关系，它的构造函数中声明的服务类型参数就不会被自动赋值。<br>.Net的DI默认是构造函数注入<br>你只管声明，其余交给DI<br>降低模块之间的耦合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //日志服务或者配置服务需要替换只需要在这里更改就行了</span><br><span class="line">            services.AddScoped&lt;Controller&gt;();</span><br><span class="line">            services.AddScoped&lt;ILog, LogImp1&gt;();</span><br><span class="line">            services.AddScoped&lt;IStorage, StorageImp1&gt;();</span><br><span class="line">            //如果从本地读取配置</span><br><span class="line">            //services.AddScoped&lt;IConfig, ConfigImp1&gt;();</span><br><span class="line">            //如果从数据库读取配置</span><br><span class="line">            services.AddScoped&lt;IConfig, DbConfig&gt;();</span><br><span class="line">            using(var sp =  services.BuildServiceProvider()) &#123;</span><br><span class="line">                var c = sp.GetRequiredService&lt;Controller&gt;();</span><br><span class="line">                c.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Controller &#123;</span><br><span class="line">        private readonly ILog log;</span><br><span class="line">        private readonly IStorage storage;</span><br><span class="line">        public Controller(ILog log, IStorage storage) &#123;</span><br><span class="line">            this.log = log;</span><br><span class="line">            this.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Test() &#123;</span><br><span class="line">            this.log.Log(&quot;开始上传&quot;);</span><br><span class="line">            this.storage.Save(&quot;asdfa&quot;, &quot;1.txt&quot;);</span><br><span class="line">            this.log.Log(&quot;上传完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface ILog &#123;</span><br><span class="line">        public void Log(string msg);</span><br><span class="line">    &#125;</span><br><span class="line">    class LogImp1 : ILog &#123;</span><br><span class="line">        public void Log(string msg) &#123;</span><br><span class="line">            Console.WriteLine($&quot;日志：&#123;msg&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IConfig &#123;</span><br><span class="line">        public string GetValue(string name);</span><br><span class="line">    &#125;</span><br><span class="line">    class ConfigImp1 : IConfig &#123;</span><br><span class="line">        public string GetValue(string name) &#123;</span><br><span class="line">            return &quot;SqlServer&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStorage &#123;</span><br><span class="line">        public void Save(string content,string name);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果从本地配置文件读取配置</span><br><span class="line">    class StorageImp1 : IStorage &#123;</span><br><span class="line">        private readonly IConfig config;</span><br><span class="line">        public StorageImp1(IConfig config) &#123;</span><br><span class="line">            this.config = config;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Save(string content, string name) &#123;</span><br><span class="line">            string server = config.GetValue(&quot;server&quot;);</span><br><span class="line">            Console.WriteLine($&quot;向服务器&#123;server&#125;的文件名为&#123;name&#125;上传&#123;content&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果从数据库读取配置</span><br><span class="line">    class DbConfig : IConfig &#123;</span><br><span class="line">        public string GetValue(string name) &#123;</span><br><span class="line">            return &quot;MySql&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/09/04/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/09/04/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>对某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。<br>有关程序及其类型的数据称为元数据，被保存在程序的程序集中。<br>程序在运行时，可以查看其他程序集或本身的元数据。这种行为叫做反射。<br>使用反射要使用System.Reflection命名空间。</p><h2 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h2><p>blc声明了一个Type抽象类，用来包含类型的特征，使用这个类的对象能获取程序使用的类型信息。<br>Type类成员<br><img src="/images/%E5%8F%8D%E5%B0%84/1.jpg"></p><h2 id="获取Type对象"><a href="#获取Type对象" class="headerlink" title="获取Type对象"></a>获取Type对象</h2><p>实例对象的GetType()方法和typeof()运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           Student std = new Student();</span><br><span class="line">           Type type1 = std.GetType();</span><br><span class="line">           Type type2 = typeof(Student);</span><br><span class="line">           Type type3 = typeof(int);</span><br><span class="line">           Console.WriteLine(type1.Name);</span><br><span class="line">           Console.WriteLine(type1.Namespace);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Student &#123;</span><br><span class="line">       public int Id &#123; get; set; &#125;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            IStudent std = new Student();</span><br><span class="line">            Type s = std.GetType();//获取类型信息</span><br><span class="line">            object o = Activator.CreateInstance(s);//通过获取的类型信息创建object类型实例</span><br><span class="line">            MethodInfo stuMi = s.GetMethod(&quot;Study&quot;);//获取该类型的Study方法</span><br><span class="line">            stuMi.Invoke(o, null);//在指定对象上调用该方法，第二个参数是参数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStudent &#123;</span><br><span class="line">        int Id &#123; get; set; &#125;</span><br><span class="line">        string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Student : IStudent &#123;</span><br><span class="line">        public int Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public void Study() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我要学习&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="插件程序的开发"><a href="#插件程序的开发" class="headerlink" title="插件程序的开发"></a>插件程序的开发</h2><p>主体程序：<br>请先在程序目录下创建Animals文件夹，该文件用来存放插件，请将插件生成的dll放在该文件夹中，主体程序会遍历文件夹中的dll，从dll中通过反射获取类库的中所有具有Voice方法的类型信息，存放在animaTypes中，最后通过反射调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.Loader;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(Environment.CurrentDirectory);//请在该路径下创建Animals文件夹</span><br><span class="line">            var floder = Path.Combine(Environment.CurrentDirectory, &quot;Animals&quot;);</span><br><span class="line">            var files = Directory.GetFiles(floder);</span><br><span class="line">            var animalTypes = new List&lt;Type&gt;();</span><br><span class="line">            foreach (var file in files) &#123;</span><br><span class="line">                var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(file);</span><br><span class="line">                var types = assembly.GetTypes();</span><br><span class="line">                foreach (var t in types) &#123;</span><br><span class="line">                    if(t.GetMethod(&quot;Voice&quot;)!=null) &#123;</span><br><span class="line">                        animalTypes.Add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (true) &#123;</span><br><span class="line">                for(int i = 0; i&lt; animalTypes.Count; i++) &#123;</span><br><span class="line">                    Console.WriteLine($&quot;&#123;i+1&#125;,&#123;animalTypes[i].Name&#125;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;====================&quot;);</span><br><span class="line">                Console.WriteLine(&quot;Please choose animal&quot;);</span><br><span class="line">                int index = int.Parse(Console.ReadLine());</span><br><span class="line">                if(index&gt;animalTypes.Count || index&lt;1) &#123;</span><br><span class="line">                    Console.WriteLine(&quot;No such an animal.Try again!&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;How many times?&quot;);</span><br><span class="line">                int times = int.Parse(Console.ReadLine());</span><br><span class="line">                var t = animalTypes[index-1];</span><br><span class="line">                var m = t.GetMethod(&quot;Voice&quot;);</span><br><span class="line">                var o = Activator.CreateInstance(t);</span><br><span class="line">                m.Invoke(o, new object[] &#123; times &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace Animals &#123;</span><br><span class="line">    public class Cat &#123;</span><br><span class="line">        public void Voice(int times) &#123;</span><br><span class="line">            for(int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">                Console.WriteLine(&quot;喵&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 反射 </tag>
            
            <tag> Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程</title>
      <link href="/2023/08/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/08/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h2><p>默认情况下一个进程只包含一个线程。<br>线程可以派生其他线程，因此在任意时刻，一个进程可能包含不同状态的多个线程，它们执行程序的不同部分。<br>如果一个进程拥有多个线程，它们将共享进程的资源。<br>系统为处理器执行所调度的单元是线程，不是进程。</p><h2 id="异步编程演示"><a href="#异步编程演示" class="headerlink" title="异步编程演示"></a>异步编程演示</h2><p>异步获取百度的html然后异步写入test.txt文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            string str = await client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            string fileName = @&quot;F:\test.txt&quot;;</span><br><span class="line">            await File.WriteAllTextAsync(fileName,str);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方法在其完成所有工作之前就返回到调用方法。<br>主函数调用异步方法，然后主函数在异步方法执行时继续执行（可能在相同的线程也可能在不同的线程）<br>async：声明这种方法是异步的。<br>await：在异步方法内等待。</p><h2 id="异步方法的注意点"><a href="#异步方法的注意点" class="headerlink" title="异步方法的注意点"></a>异步方法的注意点</h2><p>异步方法头中用async修饰符，即使返回结果为空也应该将结果声明为Task.<br>异步方法包含一个或多个await。<br>异步方法必须返回void、Task、Task&lt;T&gt;、ValueTask&lt;T&gt;的其中之一。<br>异步方法应具有公开可访问的GetAwaiter方法类型。<br>异步方法名称一般以Async为后缀。<br>Lambda表达式和匿名方法也可以作为异步对象。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await操作符帮我们提供异步等待，并且可以将Task&lt;T&gt;所封装的真实值取出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            //不用await帮忙，我就要自己取</span><br><span class="line">            Task&lt;string&gt; str1 = client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            await Console.Out.WriteLineAsync(str1.Result);</span><br><span class="line">            //await帮我取值</span><br><span class="line">            string str2 = await client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            await Console.Out.WriteLineAsync(str2);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>await表达式制订了一个异步执行的任务，这个任务可能是Task也可能不是，默认情况下这个任务在当前线程上异步运行。<br>一个空闲对象既是一个awaitable类型的实例，awaitable类型是指包含GetAwaiter方法的类型，该方法没有参数，返回一个awaiter类型的对象。awaiter类型包含以下成员：<br>bool IsCompleted{get}<br>void OnCompleted(Action);<br>还包含以下成员之一：<br>void GetResult();<br>T GetResult();<br>实际上，你不需要构建自己的awaitable，相反，你应该使用Task或ValueTask类，它们是awaitable类型</p><h2 id="Task-Run"><a href="#Task-Run" class="headerlink" title="Task.Run"></a>Task.Run</h2><p>异步方法不等于多线程，异步方法的代码并不会自动在新线程中执行，除非把代码放到新线程中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            await Repeat(100);</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; Repeat(int times) &#123;</span><br><span class="line">            int i = 0;</span><br><span class="line">            for(int j = 0; j &lt; times; j++) &#123;</span><br><span class="line">                i = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Task.Run()方法可以创建一个Task，并且在不同线程上运行你的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            await Repeat(100);</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; Repeat(int times) &#123;</span><br><span class="line">            return await Task.Run(() =&gt; &#123;</span><br><span class="line">                int i = 0;</span><br><span class="line">                for (int j = 0; j &lt; times; j++) &#123;</span><br><span class="line">                    i = i + j;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">                return i;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它接受一个委托，委托类型可以是：<br><img src="/images/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/1.jpg"></p><h2 id="为什么有些异步方法没标async"><a href="#为什么有些异步方法没标async" class="headerlink" title="为什么有些异步方法没标async"></a>为什么有些异步方法没标async</h2><p>如果不需要传递异步结果，不需要包装成Task，就没必要async，在哪await都是await。<br>这样写对优化有帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string str = await GetBaidu();</span><br><span class="line">            await Console.Out.WriteLineAsync(str);</span><br><span class="line">        &#125;</span><br><span class="line">        static  Task&lt;string&gt; GetBaidu() &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            return client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="取消异步操作CancellationToken和CancellationTokenSource"><a href="#取消异步操作CancellationToken和CancellationTokenSource" class="headerlink" title="取消异步操作CancellationToken和CancellationTokenSource"></a>取消异步操作CancellationToken和CancellationTokenSource</h2><p>位于System.Threading.Tasks名称空间下。<br>很多异步方法都有CancellationToken参数用于获得提前终止执行的信号。<br>CancellationToken是一个结构体，它包含着一个任务是否应被取消的信息。<br>拥有CancellationToken对象的任务应定期检查其令牌状态也就是IsCancellationRequested属性是否为true，任务需停止其操作并返回。<br>CancellationToken是不可逆的只能使用一次。<br>CancellationTokenSource对象创建可分配给不同任务的CancellationToken对象。任何持有CancellationTokenSource的对象都可以调用其Cancel方法，这会将CancellationToken的IsCancellationRequested设置为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();</span><br><span class="line">            CancellationToken token = cancellationTokenSource.Token;</span><br><span class="line">            cancellationTokenSource.CancelAfter(3000);</span><br><span class="line">            Task&lt;int&gt; res = GetBaidu(token);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (Console.ReadLine() != &quot;p&quot;) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                cancellationTokenSource.Cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; GetBaidu(CancellationToken token) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            for(int i = 0; i &lt; 65533; i++) &#123;</span><br><span class="line">                if(token.IsCancellationRequested) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(&quot;请求被取消&quot;);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                string str = await client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">                await Console.Out.WriteLineAsync(str);</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="同步等待任务"><a href="#同步等待任务" class="headerlink" title="同步等待任务"></a>同步等待任务</h2><p>可以使用task对象的Wait()方法在调用方法中同步等待：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            t.Wait();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Task.WaitAll()静态方法用于等待一组任务都完成<br>Task.WaitAny()静态方法用于等待一组任务中的某一个完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t1 = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            Task t2 = File.ReadAllTextAsync(@&quot;F:\test.txt&quot;);</span><br><span class="line">            //Task.WaitAll(t1, t2);</span><br><span class="line">            Task.WaitAny(t1, t2);</span><br><span class="line">            Console.WriteLine($&quot;t1是否完成:&#123;t1.IsCompleted&#125;,t2是否完成&#123;t2.IsCompleted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们的重载还有：<br><img src="/images/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/2.jpg"></p><h2 id="在异步方法中异步等待"><a href="#在异步方法中异步等待" class="headerlink" title="在异步方法中异步等待"></a>在异步方法中异步等待</h2><p>有时在异步方法中，你会希望用await表达式来等待Task，这时异步方法会返回调用方法，但该异步方法会等待一个或所有任务完成。可以通过Task.WhenAll()和Task.WhenAny()来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            await Test();</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task Test() &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t1 = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            Task t2 = File.ReadAllTextAsync(@&quot;F:\test.txt&quot;);</span><br><span class="line">            //await Task.WhenAll(t1, t2);</span><br><span class="line">            await Task.WhenAny(t1, t2);</span><br><span class="line">            await Console.Out.WriteLineAsync($&quot;t1是否完成:&#123;t1.IsCompleted&#125;,t2是否完成&#123;t2.IsCompleted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Delay"><a href="#Task-Delay" class="headerlink" title="Task.Delay"></a>Task.Delay</h2><p>该方法创建Task对象，将对象暂停在其线程中，一定时间后再完成，该方法不会阻塞主线程.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Delay(3000);</span><br></pre></td></tr></table></figure><h2 id="GUI程序中的异步"><a href="#GUI程序中的异步" class="headerlink" title="GUI程序中的异步"></a>GUI程序中的异步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void Button_Click(object sender, RoutedEventArgs e) &#123;</span><br><span class="line">            this.input.Text = &quot;Watting&quot;;</span><br><span class="line">            this.btn.IsEnabled = false;</span><br><span class="line">            Thread.Sleep(4000);</span><br><span class="line">            this.input.Text = &quot;没有任务&quot;;</span><br><span class="line">            this.btn.IsEnabled = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在wpf中当点击按钮，文本框文字没有改变，按钮也没有被禁用，但是页面卡住了三秒，期间无法拖动也无法进行其他活动。<br>原因是GUI需要处理很多事情，当点击按钮时，按钮的Click被放入消息队列，消息泵从队列中移除该消息并开始执行事件处理函数。事件处理函数将改变文本框文字、禁用按钮、移动窗体、改变文本框文字、启用按钮放入消息泵，消息泵还未刷新页面时，被Thread.Sleep()阻塞了主线程，当三秒之后再处理消息泵的内容，但是这一切发生的太快。<br>将上述代码修改如下即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private async void Button_Click(object sender, RoutedEventArgs e) &#123;</span><br><span class="line">            this.input.Text = &quot;Watting&quot;;</span><br><span class="line">            this.btn.IsEnabled = false;</span><br><span class="line">            await Task.Delay(4000);      </span><br><span class="line">            this.input.Text = &quot;没有任务&quot;;</span><br><span class="line">            this.btn.IsEnabled = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Yield"><a href="#Task-Yield" class="headerlink" title="Task.Yield"></a>Task.Yield</h2><p>该方法创建一个立即返回的awaitable。等待一个Yield可以让异步方法在执行后续部分的同时返回到调用方法，可以将其理解成离开当前的消息队列、回到队伍末尾、让处理器有时间处理其他任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Task&lt;int&gt; value = DoStuff.FindSeriesSum(100000);</span><br><span class="line">            CountBig(100000); CountBig(100000);</span><br><span class="line">            CountBig(100000); CountBig(100000);</span><br><span class="line">            Console.WriteLine($&quot;Sum:&#123;value.Result&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        private static void CountBig(int value) &#123;</span><br><span class="line">            for (int i = 0; i &lt; value; i++) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class DoStuff &#123;</span><br><span class="line">        public static async Task&lt;int&gt;FindSeriesSum(int i1) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for(int i = 0; i &lt; i1; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                if(i%1000 ==0)await Task.Yield();</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Yield方法在GUI程序中非常有用，可以中断大量工作，让其他任务使用处理器。</p><h2 id="异步Lambda表达式"><a href="#异步Lambda表达式" class="headerlink" title="异步Lambda表达式"></a>异步Lambda表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button.Click+=async(sender,e)=&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 异步编程 </tag>
            
            <tag> async </tag>
            
            <tag> await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINQ</title>
      <link href="/2023/08/30/LINQ/"/>
      <url>/2023/08/30/LINQ/</url>
      
        <content type="html"><![CDATA[<p>Linq表示语言集成查询，它是.Net框架的扩展，允许我们以使用sql查询数据库的类似方法来查询集合。<br>Linq的查询语法有方法语法和查询语法。方法语法是命令式的，查询语法是声明式的。<br>位于System.Linq名称空间。<br>Linq查询可以返回两种类型的结果——可以是一个枚举，它是满足查询参数的项列表；也可以是一个叫标量的单一值，它是满足查询条件的结果的某种摘要形式。</p><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>学习Linq之前，让我们先来认识一下匿名类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var student = new &#123;</span><br><span class="line">                age = 18,</span><br><span class="line">                name = &quot;张三&quot;,</span><br><span class="line">                major = &quot;数字电路&quot;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>匿名类型的成员类型由编译器推断，只需要在对象初始化语句中初始化即可。<br>注意事项：<br>匿名类型只能用于局部变量，不能用于类成员。<br>必须使用var作为变量类型。<br>编译器为匿名类型创建的属性是只读的。<br>可以使用投影初始化语句来初始化匿名对象（与JS一样）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            int age = 18;</span><br><span class="line">            string name = &quot;张三&quot;;</span><br><span class="line">            string major = &quot;数字电路&quot;;</span><br><span class="line">            var student = new &#123;</span><br><span class="line">                age, name, major</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果编译器遇到了另一个具有相同参数名，相同的推断类型和相同顺序的匿名类型对象初始化语句，它会重用这个类型并直接创建新的实例，不会创建新的匿名类型。</p><h2 id="查询语法（微软推荐，我不推荐）"><a href="#查询语法（微软推荐，我不推荐）" class="headerlink" title="查询语法（微软推荐，我不推荐）"></a>查询语法（微软推荐，我不推荐）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new List&lt;int&gt;() &#123; 1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">            var result = from n in list</span><br><span class="line">                         where n&gt;5</span><br><span class="line">                         select n;</span><br><span class="line">            foreach(var n in result) &#123;</span><br><span class="line">                Console.WriteLine(n);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>如果查询表达式返回枚举，则查询一直到处理枚举时才会执行。<br>如果枚举被处理多次，查询就会执行多次。<br>如果在进行遍历之后，查询执行之前数据有改动，则查询会使用新的数据。<br>如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。<br>查询表达式由from子句和查询主题组成。<br>子句必须按照一定的顺序出现。<br>from子句和select…group子句这两部分是必须的，其他子句是可选的。<br>select子句在表达式最后。<br>可以有任意多的from…let…where子句。</p><h2 id="from子句"><a href="#from子句" class="headerlink" title="from子句"></a>from子句</h2><p>指定要作为数据源使用的数据集合（必须是可枚举的），它还引入了迭代变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from n in list where n&gt;5 select n;</span><br><span class="line">from l1 in list1 from l2 in list2 where l1&lt;l2 select </span><br></pre></td></tr></table></figure><h2 id="join子句（联结）"><a href="#join子句（联结）" class="headerlink" title="join子句（联结）"></a>join子句（联结）</h2><p>接受两个集合，然后创建一个新的集合，其中每一个元素包含两个原始集合中的元素成员。<br>必须使用上下文关键字equals来比较字段，不能用&#x3D;&#x3D;运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var query = from s in students </span><br><span class="line">join c in studentsInCourses on s.StID equals c.StID</span><br></pre></td></tr></table></figure><h2 id="let子句"><a href="#let子句" class="headerlink" title="let子句"></a>let子句</h2><p>接受一个表达式的运算并把它赋值给一个需要在其他运算中使用的标识符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 3, 4, 5, 6 &#125;;</span><br><span class="line">            List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6,7,8,9 &#125;;</span><br><span class="line">            var res = from l1 in list1</span><br><span class="line">                      from l2 in list2</span><br><span class="line">                      let sum = l1+ l2</span><br><span class="line">                      where sum==12</span><br><span class="line">                      select new &#123; l1,l2,sum &#125;;</span><br><span class="line">            foreach(var a in res) &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><p>根据之后的运算来去除不符合指定条件的项</p><h2 id="orderby子句"><a href="#orderby子句" class="headerlink" title="orderby子句"></a>orderby子句</h2><p>接受一个表达式并根据表达式按顺序返回结果项。<br>可选ascending（升序）descending（降序），默认是升序<br>可以有任意多个子句，他们必须用逗号分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 16,8,146,95,3,24 &#125;;</span><br><span class="line">            var res = from l1 in list1</span><br><span class="line">                      orderby l1</span><br><span class="line">                      select l1;</span><br><span class="line">            foreach(var a in res) &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="select子句"><a href="#select子句" class="headerlink" title="select子句"></a>select子句</h2><p>select子句指定应该选择所选对象的哪些部分。<br>查询结果可以由原始集合的项，原始集合中项的字段或匿名类型组成。</p><h2 id="group子句"><a href="#group子句" class="headerlink" title="group子句"></a>group子句</h2><p>group…by是可选的，用来指定选择的项如何被分组。<br>如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组。作为字段分组依据的属性叫做键（key）<br>group子句返回的不是原始数据源中项的枚举，而是返回可以枚举已经形成的项的分组的可枚举类型。<br>分组本身是可枚举类型，他们可以枚举实际的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Student[] students = new Student[] &#123; </span><br><span class="line">            new Student()&#123;Lname = &quot;三&quot;,Fname = &quot;张&quot;, age = 18,Major = &quot;计算机网络&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;四&quot;,Fname = &quot;李&quot;, age = 18,Major = &quot;数据结构与算法&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;五&quot;,Fname = &quot;王&quot;, age = 18,Major = &quot;计算机网络&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;人甲&quot;,Fname = &quot;路&quot;, age = 18,Major = &quot;数据库原理&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;灰乙&quot;,Fname = &quot;炮&quot;, age = 18,Major = &quot;数据库原理&quot;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            var query = from student in students</span><br><span class="line">                        group student by student.Major;</span><br><span class="line">            foreach(var q in query) &#123;</span><br><span class="line">                Console.WriteLine(q.Key);</span><br><span class="line">                foreach(var s in q) &#123;</span><br><span class="line">                    Console.WriteLine(s.Fname+s.Lname+&quot;选修&quot;+s.Major);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Student &#123;</span><br><span class="line">        public string Lname &#123; get; set; &#125;</span><br><span class="line">        public string Fname &#123; get; set; &#125;</span><br><span class="line">        public string Major &#123; get; set; &#125;</span><br><span class="line">        public int age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每一个分组由一个叫做键的字段区分<br>每一个分组本身是可枚举类型并且可以枚举它的项。</p><h2 id="into语句"><a href="#into语句" class="headerlink" title="into语句"></a>into语句</h2><p>into语句是查询延续子句，可以接受查询一部分的结果并赋予一个名字，从而可以在查询的另一部分中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            var groupA = new[]&#123; 3, 4, 5, 6, &#125;;</span><br><span class="line">            var groupB = new[] &#123; 4,5,6,7 &#125;;</span><br><span class="line">            var res = from a in groupA</span><br><span class="line">                      join b in groupB on a equals b</span><br><span class="line">                      into groupAB</span><br><span class="line">                      from c in groupAB</span><br><span class="line">                      select c;</span><br><span class="line">            foreach(var r in res) &#123;</span><br><span class="line">                Console.WriteLine(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="方法语法（标准查询运算符）"><a href="#方法语法（标准查询运算符）" class="headerlink" title="方法语法（标准查询运算符）"></a>方法语法（标准查询运算符）</h2><p>标准查询运算符由一系列API方法组成，一些运算符返回IEnumerable对象（或其他序列），而其他运算符返回标量，返回标量的运算符立即执行查询，并返回一个值，而不是一个可枚举类型对象。ToArray()、ToList()等ToCollection运算符也会立即执行。<br>许多操作都以一个谓词作为参数，谓词是一个方法，它以对象为参数，根据对象是否满足某个条件返回true或false。<br>被查询的集合对象叫序列，它必须实现IEnumerable&lt;T&gt;接口，其中T是类型。<br><img src="/images/LINQ/1.jpg"><br><img src="/images/LINQ/2.jpg"><br><img src="/images/LINQ/3.jpg"><br>System.Linq.Enumerable类声明了标准查询运算符方法，然而这些方法不仅仅是普通方法，他们是拓展了IEnumerable&lt;T&gt;泛型类的扩展方法。</p><h2 id="常用标准查询运算符"><a href="#常用标准查询运算符" class="headerlink" title="常用标准查询运算符"></a>常用标准查询运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var group = new[] &#123;1,2,3,4,5,6,7,8,9,0 &#125;;</span><br><span class="line">            Student[] students = new Student[] &#123; </span><br><span class="line">                new Student()&#123;name = &quot;路人甲&quot;,age =18 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人乙&quot;,age =18 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人丙&quot;,age =19 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人丁&quot;,age =120 &#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">            var res1 = group.Where(e =&gt; e &gt; 6);</span><br><span class="line">            var res2 = group.Count(e=&gt;e&lt;5);</span><br><span class="line">            var res3 = group.Any(e=&gt;e&lt;0);</span><br><span class="line">            var res4 = group.Single(e=&gt;e==6);</span><br><span class="line">            var res5 = group.SingleOrDefault(e=&gt;e==7);</span><br><span class="line">            var res6 = group.First(e=&gt;e&gt;3);</span><br><span class="line">            var res7 = group.FirstOrDefault(e=&gt;e&gt;15);</span><br><span class="line">            var res8 = group.OrderBy(e=&gt;e);</span><br><span class="line">            var res9  = students.OrderBy(e=&gt;e.age);</span><br><span class="line">            var res10 = students.OrderByDescending(e=&gt;e.age);</span><br><span class="line">            var res11 = students.OrderBy(e =&gt; Guid.NewGuid());//随机排序</span><br><span class="line">            var res12 = students.OrderBy(e =&gt; e.age).ThenBy(e=&gt;e.name);</span><br><span class="line">            var res13 = students.OrderBy(e =&gt; e.age).ThenByDescending(e=&gt;e.name);</span><br><span class="line">            var res14 = group.Skip(2).Take(3);//跳过2条，取2条</span><br><span class="line">            var res15 = students.Max(e =&gt; e.age);</span><br><span class="line">            var res16 = students.Min(e =&gt; e.age);</span><br><span class="line">            var res17 = students.Average(e =&gt; e.age);</span><br><span class="line">            var res18 = students.Sum(e =&gt; e.age);</span><br><span class="line">            var res19 = students.Count();</span><br><span class="line">            var res20 = students.GroupBy(e =&gt; e.age);</span><br><span class="line">            var res21 = students.Select(e =&gt; e.age);</span><br><span class="line">            var res22 = students.ToList();</span><br><span class="line">            var res23 = students.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Student &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public int age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Linq </tag>
            
            <tag> 匿名类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举器与迭代器</title>
      <link href="/2023/08/30/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2023/08/30/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>为什么数组可以被foreach遍历呢？<br>原因是数组可以按需提供一个叫做枚举器的对象，枚举器可以依次返回请求数组中的元素，枚举器知道项的次序并且追踪它在序列中的位置，然后返回请求的当前项。<br>获取对象枚举器的方法是调用对象的GetEnumerator方法。实现GetEnumerator方法的类型叫做可枚举类型。</p><h2 id="IEnumerator接口"><a href="#IEnumerator接口" class="headerlink" title="IEnumerator接口"></a>IEnumerator接口</h2><p>位于System.Collections。<br>实现了IEnumerator接口的枚举器包含3个函数成员：Current、MoveNext以及Reset。<br>Current是返回序列中当前位置项的属性，它是只读的，它返回object类型的引用，我们必须把它转成实际类型的实例。<br>MoveNext是把枚举器位置前进到集合中下一项的方法。它也返回布尔值，指示新的位置是有效位置还是已经超过了序列的尾部，MoveNext必须在第一次使用Current之前调用。<br>Reset是把位置重置为原始状态的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//using System.Collections;</span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            int[] arr = &#123; 10, 11, 12, 13 &#125;;</span><br><span class="line">            IEnumerator ie = arr.GetEnumerator();</span><br><span class="line">            while (ie.MoveNext()) &#123;</span><br><span class="line">                int item = (int) ie.Current;</span><br><span class="line">                Console.WriteLine($&quot;Item value：&#123;item&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerable接口"><a href="#IEnumerable接口" class="headerlink" title="IEnumerable接口"></a>IEnumerable接口</h2><p>位于System.Collections。<br>可枚举类是实现了IEnumerable接口的类，IEnumerable只有一个成员——GetEnumerator方法，它返回对象的枚举器。<br>枚举器与迭代器完整写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Spectrum spectrum = new Spectrum();</span><br><span class="line">            foreach (var color in spectrum) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ColorEnumerator : IEnumerator &#123;</span><br><span class="line">        string[] colors;</span><br><span class="line">        int position = -1;</span><br><span class="line">        public ColorEnumerator(string[] theColors) &#123;</span><br><span class="line">            colors = new string[theColors.Length];</span><br><span class="line">            for(int i = 0;i &lt; theColors.Length; i++) &#123;</span><br><span class="line">                colors[i] = theColors[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public object Current &#123;</span><br><span class="line">            get &#123;</span><br><span class="line">                if(position == -1) &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                if(position&gt;= colors.Length) &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                return colors[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public bool MoveNext() &#123;</span><br><span class="line">            if(position&lt;colors.Length-1) &#123;</span><br><span class="line">                position++;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else &#123; return false; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Reset() &#123;</span><br><span class="line">            position = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Spectrum : IEnumerable &#123;</span><br><span class="line">        string[] Colors = &#123; &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yello&quot;, &quot;pink&quot; &#125;;</span><br><span class="line">        public IEnumerator GetEnumerator() &#123;</span><br><span class="line">            return new ColorEnumerator(Colors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>大多数情况下你应该使用泛型版本的IEnumerable&lt;T&gt;和IEnumerator&lt;T&gt;。<br>IEnumerable&lt;T&gt;接口的GetEnumerator方法返回实现IEnumator&lt;T&gt;的枚举器类的实例，这些接口是协变接口。<br>泛型接口的枚举器是类型安全的，它自动将返回结果转换成实际类型的引用。<br><img src="/images/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/1.jpg"></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器需要System.Collections.Generic名称空间。<br>从C#2.0开始提供了更简单的创建枚举器和可枚举类型的方式，这种结构称为迭代器，我们可以把手动编码的可枚举类型和枚举器替换为由迭代器生成的可枚举类型和枚举器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样的有迭代器产生的枚举器简化了很多代码。<br>迭代器块是有一个或多个yield语句的代码块。<br>迭代器块不是需要在同一时间执行的一串命令式命令，而是声明性的。<br>迭代器块有两个特殊的语句：<br>yield return 指定了序列中要返回的下一项。<br>yield break  指定在序列中没有其他项。<br>根据迭代器块的返回类型，可以让迭代器产生枚举器或可枚举类型<br>使用迭代器创建枚举器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">        public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">            return this.BlackAndWhite();</span><br><span class="line">        &#125;</span><br><span class="line">        public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用迭代器创建可枚举对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass mc = new MyClass();</span><br><span class="line">        foreach (string color in mc) &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass &#123;</span><br><span class="line">    public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">        return this.BlackAndWhite();</span><br><span class="line">    &#125;</span><br><span class="line">    public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">        yield return &quot;black&quot;;</span><br><span class="line">        yield return &quot;gray&quot;;</span><br><span class="line">        yield return &quot;white&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代器创建可枚举类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyClass mc = new MyClass();</span><br><span class="line">            foreach (string color in mc) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">            foreach (string color in mc.BlackAndWhite()) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyClass &#123;</span><br><span class="line">        public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">            return this.BlackAndWhite().GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line">        public IEnumerable&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><p>当我们实现返回枚举器的迭代器时，必须通过实现GetEnumerator来让类可枚举，它返回由迭代器返回的枚举器。<br>在类中实现返回可枚举类型的迭代器时，我们可以让类实现GetEnumerator来让类本身可枚举，或不实现让类不可枚举。<br>如果实现GetEnumerator，让它调用迭代器方法以获取自动生成的实现IEnumerable的类实例，然后从IEnumerable对象返回由GetEnumerator创建的枚举器。<br>如果不实现GetEnumerator使类本身不可枚举，仍然可以使用由迭代器返回的可枚举类，只需要直接调用迭代器方法。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> IEnumerator </tag>
            
            <tag> IEnumerable </tag>
            
            <tag> 枚举器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协变与逆变</title>
      <link href="/2023/08/30/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
      <url>/2023/08/30/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>大家通常会犯一个错误，就是将派生类型的委托分配给基类型委托的变量，下面来看这个主题叫做可变性，它分为三种——协变、逆变、不变。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p>如果类型参数只用做输出值与构造委托有效性之间的常数关系叫做协变。<br>你也许知道，你可以将派生类型的对象赋值给基类型的变量，这称作类型兼容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Factory&lt;Cat&gt; catMaker = MakeCat;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = catMaker;//报错</span><br><span class="line">    &#125;</span><br><span class="line">    static Cat MakeCat() &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        return cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate T Factory&lt;T&gt;();</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public int NumberOfLegs = 4;</span><br><span class="line">&#125;</span><br><span class="line">class Cat:Animal &#123; &#125;</span><br></pre></td></tr></table></figure><p>出现以上问题的原因很简单，Cat虽然是Animal的子类，但是Factory&lt;Cat&gt;不是Factory&lt;Animal&gt;的子类，必然无法赋值。<br>如果我们想用这样的赋值，就需要告诉编译器我要使用协变。<br>使用协变的前提：类型参数只用做输出值与构造委托有效性之间的常数关系，必须使用out关键字标记委托声明中的类型参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate T Factory&lt;out T&gt;();</span><br></pre></td></tr></table></figure><p>可能会觉得协变的定义很难懂，接下来我来解释一下什么叫输出值。<br>输出值就是返回值，上面的MakeCat函数的返回值是一个Cat类型的对象，Factory&lt;Animal&gt;接收一个Animal类型的返回值，用Animal来接受返回值为Cat的对象，并声明成out协变保证这个派生类对象只用来当做函数返回值，这样当然没问题。</p><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p>逆变用于在期望传入基类时允许传入派生类对象的特性称作逆变。<br>如果上面的函数变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = MakeAnimal;</span><br><span class="line">        Factory&lt;Cat&gt; CatMaker = animalMaker;</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeAnimal(Animal animal) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void Factory&lt; T &gt;(T t);</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public int NumberOfLegs = 4;</span><br><span class="line">&#125;</span><br><span class="line">class Cat:Animal &#123; &#125;</span><br></pre></td></tr></table></figure><p>这次我们用一个MakeAnimal函数接受一个Animal类或其派生类的对象，当我们传入了Cat时，虽然Cat是Animal的派生类，但是Factory&lt;Cat&gt;与Factory&lt;Animal&gt;平级，所以不能直接赋值。<br>如果就想这样做，就需要告诉编译器我要使用逆变。使用协变的前提：类型参数只用做输入值与构造委托有效性之间的常数关系，必须使用in关键字标记委托声明中的类型参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate T Factory&lt;in T&gt;();</span><br></pre></td></tr></table></figure><p>MakeAnimal函数接受一个animal的对象，我们传入了animal的派生类对象并声明成in逆变保证这个派生类对象只用来当做函数传参，这样做当然没问题</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>可变性处理的是可以使用基类型替换派生类型的安全情况，反之亦然。因此可变性只适用于引用类型。</p><p>in和out关键字的显式变化只适用于委托和接口，不适用于类、结构、方法。</p><p>不包括in和out关键字的委托和接口类型参数是不变的。这些类型参数不能用于协变或逆变。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 可变性 </tag>
            
            <tag> 协变 </tag>
            
            <tag> 逆变 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2023/08/29/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/08/29/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>大家有没有觉得一个类的成员类型或者一个方法的返回值类型和参数类型一旦写好就不太方便修改，如果一个经常使用的类，它的某个成员类型有时候需要int，有时候需要string，我们需要不停的修改这个类，或者声明一个与其名字相似但成员类型不同的新的类，这样做非常麻烦。<br>另外还有一个函数，它的参数类型有时候需要int，有时候需要double，虽然我们可以进行函数重载，但代码挺多的。<br>为了解决上述问题，提供了新的解决方案——泛型。<br>我们可以使用“类型占位符”书写代码，然后在创建类的实例时知名真实的类型。<br>泛型类型不是类型，而是类型的模板。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            MyClass&lt;int, double&gt; myClass = new MyClass&lt;int, double&gt;() &#123; Value1 = 12 ,Value2 = new double[] &#123; 1,2,3&#125; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class MyClass&lt;T1 , T2&gt; &#123;</span><br><span class="line">        public T1 Value1 &#123; get; set; &#125;</span><br><span class="line">        public T2[] Value2;</span><br><span class="line">        public void Fun1(T1 x) &#123; ... &#125;</span><br><span class="line">        public T2 Fun2() &#123; ...&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码，如果我们想要修改MyClass类成员的类型，只需要在声明时修改&lt;&gt;内的内容，也就是类型参数就行。<br>泛型的声明有点长可以使用var进行简化。</p><h2 id="类型参数的约束（where）"><a href="#类型参数的约束（where）" class="headerlink" title="类型参数的约束（where）"></a>类型参数的约束（where）</h2><p>由于泛型栈不知道它们保存的项的类型是什么，所以也就不会知道这些类型实现的成员。<br>栈可以确认的是，这些保存的项都实现了object类的成员，包括ToString、Equals、以及GetType方法，除此之外，它不知道还有哪些成员可用。<br>为了让泛型变得更有用，我们需要提供额外的信息让编译器知道参数可以接受哪种类型，这样的信息称为约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass&lt;int, double[]&gt; myClass = new MyClass&lt;int, double[]&gt;() &#123; Value1 = 12 ,Value2 = new double[] &#123; 1,2,3&#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass&lt;T1 , T2&gt;where T1: struct </span><br><span class="line">                             where T2 : class, IEnumerable&lt;double&gt; &#123;</span><br><span class="line">    public T1 Value1 &#123; get; set; &#125;</span><br><span class="line">    public T2 Value2;</span><br><span class="line">    public void Fun1(T1 x) &#123;</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">    &#125;</span><br><span class="line">    public T2 Fun2() &#123;</span><br><span class="line">        return Value2 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约束类型：</p><table><thead><tr><th>约束类型</th><th>描述</th></tr></thead><tbody><tr><td>类名</td><td>只有这个类型的类或从它派生的类才能用作类型实参</td></tr><tr><td>class</td><td>任何引用类型，包括类、数组、委托和接口都可以用作类型实参</td></tr><tr><td>struct</td><td>任何值类型都可以用作类型实参</td></tr><tr><td>接口名</td><td>只有这个接口或实现这个接口的类型才能用作类型实参</td></tr><tr><td>new()</td><td>任何具有无参公共构造函数的类型都可以用作类型实参</td></tr><tr><td>where子句可以以任何次序列出，但是where字句中的约束必须有特定的顺序：</td><td></td></tr><tr><td>最多只能有一个主约束，而且必须放在第一位。</td><td></td></tr><tr><td>可以有任意多的接口名称约束。</td><td></td></tr><tr><td>如果存在构造函数约束，则必须放在最后。</td><td></td></tr><tr><td>主约束</td><td>次约束</td></tr><tr><td>–</td><td>–</td></tr><tr><td>ClassName</td><td>InterfaceName</td></tr><tr><td>class</td><td></td></tr><tr><td>struct</td><td></td></tr></tbody></table><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var intArray = new int[] &#123; 3, 5, 7, 9, 11 &#125;;</span><br><span class="line">            var stringArray = new string[] &#123; &quot;first&quot;, &quot;second&quot;, &quot;third&quot; &#125;;</span><br><span class="line">            Simple.ReverseAndPrint&lt;int&gt;(intArray);</span><br><span class="line">            Simple.ReverseAndPrint(stringArray);//自动推断</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple &#123;</span><br><span class="line">        static public void ReverseAndPrint&lt;T&gt;(T[] arr) &#123;</span><br><span class="line">            Array.Reverse(arr);</span><br><span class="line">            foreach (var item in arr) &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译器可以帮我们从方法参数的类型中推断出应用作为泛型方法的类型参数的类型，简化调用时书写的代码。</p><h2 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct&lt;T1,T2&gt; &#123;</span><br><span class="line">            public T1 Value1;</span><br><span class="line">            public T2 Value2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyDel&lt;int&gt; del = func;</span><br><span class="line">            del.Invoke(0);</span><br><span class="line">        &#125;</span><br><span class="line">        static void func(int i) &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate void MyDel&lt;T&gt;(T t);</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>如果一个类实现了泛型接口，那么这个类本身也是泛型的。<br>如果一个类实现了特化之后的泛型接口，那么这个类就不再是泛型类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Simple&lt;string&gt; simple = new Simple&lt;string&gt;();</span><br><span class="line">            Simple&lt;int&gt; int1 = new Simple&lt;int&gt;();</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(&quot;hello world&quot;));</span><br><span class="line">            Console.WriteLine(int1.ReturnIt(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IMyIf&lt;T&gt; &#123;</span><br><span class="line">        T  ReturnIt( T inValue);</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple&lt;S&gt; : IMyIf&lt;S&gt; &#123;</span><br><span class="line">        public S ReturnIt(S inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用不同类型参数实例化的泛型接口的实例是不同的接口。<br>我们可以在非泛型类型中实现泛型接口。<br>必须实现每一个接口的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Simple simple = new Simple();</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(&quot;hello world&quot;));</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IMyIf&lt;T&gt; &#123;</span><br><span class="line">        T  ReturnIt( T inValue);</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple : IMyIf&lt;int&gt;, IMyIf&lt;string&gt; &#123;</span><br><span class="line">        public int ReturnIt(int inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public string ReturnIt(string inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。<br>泛型接口的名字不会与非泛型冲突。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 泛型 </tag>
            
            <tag> 泛型约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/08/29/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/08/29/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么我们需要接口"><a href="#为什么我们需要接口" class="headerlink" title="为什么我们需要接口"></a>为什么我们需要接口</h2><p>接口是指定一组函数成员而不实现它们的引用类型，只有类和结构可以实现接口。<br>接口是抽象类的进一步抽象。<br>可以很好的帮助我们解决类的耦合。<br>接下来我会一步步推出来为什么要使用接口。</p><h2 id="抽象类解耦"><a href="#抽象类解耦" class="headerlink" title="抽象类解耦"></a>抽象类解耦</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            HuaWei huaWei = new HuaWei();</span><br><span class="line">            Man man = new Man();</span><br><span class="line">            man.huaWei = huaWei;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Man &#123;</span><br><span class="line">        public HuaWei huaWei &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class HuaWei &#123;</span><br><span class="line">        public void Call() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个代码表示一个人拿了一部华为手机，当这个人想换成小米手机的时候，就不得不修改成一下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        XiaoMi xiaoMi = new XiaoMi();</span><br><span class="line">        Man man = new Man();</span><br><span class="line">        man.xiaoMi = xiaoMi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man &#123;</span><br><span class="line">    public XiaoMi xiaoMi &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class XiaoMi &#123; </span><br><span class="line">    public void Call() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现一个问题，这个人可能会换很多部不同的手机，难道我们每次都要重写Man类就为了让这个人打电话吗？当然不可能，所以我们想了一个方法，用抽象类封装一下，再通过多态来实现不就可以了吗：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">      static void Main(string[] args) &#123;</span><br><span class="line">          Man man = new Man();</span><br><span class="line">          Phone phone = new XiaoMi();</span><br><span class="line">          phone.Call();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Man &#123;</span><br><span class="line">      public Phone phone &#123; get; set; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract class Phone &#123;</span><br><span class="line">      public abstract void Call();</span><br><span class="line">  &#125;</span><br><span class="line">  class XiaoMi:Phone &#123; </span><br><span class="line">      override public void Call() &#123;</span><br><span class="line">          Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class HuaWei:Phone &#123;</span><br><span class="line">      override public void Call() &#123;</span><br><span class="line">          Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就好多了，这下我们只需要每次给man换手机就行了，Call方法给每个手机厂商自己实现就行了。</p><h2 id="接口解耦"><a href="#接口解耦" class="headerlink" title="接口解耦"></a>接口解耦</h2><p>当我们声明一个抽象类的时候，我们必须要写非常多的public abstract 用来声明抽象方法，还必须在子类中写好多override，况且随着手机的功能越来越多，手机可以当游戏机，可以当手电筒，可以当记事本，难道我们要在Phone中加入不属于手机初衷的功能吗？这样一点都不优雅，有没有优雅一点的办法？<br>有！就是使用接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           Man man = new Man();</span><br><span class="line">           IPhone phone = new XiaoMi();</span><br><span class="line">           phone.Call();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Man &#123;</span><br><span class="line">       public IPhone phone &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   interface IPhone &#123;</span><br><span class="line">       void Call();</span><br><span class="line">   &#125;</span><br><span class="line">   class XiaoMi:IPhone &#123; </span><br><span class="line">       public void Call() &#123;</span><br><span class="line">           Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class HuaWei:IPhone &#123;</span><br><span class="line">       public void Call() &#123;</span><br><span class="line">           Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>interface声明接口，接口内的成员隐式都是public abstract的所以无需再写也不能写了。还可以看到在实现接口的类中不用再写override了，优雅太优雅了。</p><h2 id="声明接口的注意事项"><a href="#声明接口的注意事项" class="headerlink" title="声明接口的注意事项"></a>声明接口的注意事项</h2><p>接口成员不能是数据成员或静态成员<br>接口声明只能包含如下类型非静态成员函数声明：<br>方法<br>属性<br>事件<br>索引器<br>接口成员的声明不能包含任何实现代码，必须用分号代替每一个成员声明的主体。<br>按照惯例接口名称应以大写I开始。<br>接口声明可以分隔成分部接口声明。<br>接口声明可以有任何访问修饰符，但是接口成员都是隐式public的，不允许有任何修饰符包括public。<br>接口不能实例化，只能用来声明变量，但不能调用不属于这个接口成员的类成员。<br>接口可以继承一个或多个接口</p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>类和结构可以实现接口，而且可以实现多个接口。<br>实现接口的类或结构需要在基类列表中包含接口名称基类在前接口在后，必须为每一个接口成员提供实现。<br>如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。<br>实现接口的类可以从它的基类继承实现的代码。</p><h2 id="显式接口成员实现"><a href="#显式接口成员实现" class="headerlink" title="显式接口成员实现"></a>显式接口成员实现</h2><p>使用限定接口名称来声明，由接口名称和成员名称以及它们中间的点分隔号构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        IKiller man1 = new Man();</span><br><span class="line">        man1.Kill();</span><br><span class="line">        IGoodMan man2 = new Man();</span><br><span class="line">        man2.Smile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface IKiller &#123;</span><br><span class="line">    void Kill();</span><br><span class="line">&#125;</span><br><span class="line">interface IGoodMan &#123;</span><br><span class="line">    void Smile();</span><br><span class="line">&#125;</span><br><span class="line">class Man : IKiller, IGoodMan &#123;</span><br><span class="line">     void IKiller.Kill() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我是个杀手&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     void IGoodMan.Smile() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我是个好人&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式实现接口成员的函数不应该有访问修饰符，因为其是隐式public的。<br>显式接口成员实现只可以通过指向接口的引用来访问，其他的类成员都不可以直接访问他们。<br>由于其他类成员不能直接访问显式接口成员的实现，派生类的成员也不能直接访问他们，他们必须总是通过接口的引用来访问。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数</title>
      <link href="/2023/08/29/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2023/08/29/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>匿名方法是在实例化委托是内联声明的方法。</p><h2 id="匿名函数使用位置"><a href="#匿名函数使用位置" class="headerlink" title="匿名函数使用位置"></a>匿名函数使用位置</h2><p>声明委托变量时作为初始化表达式</p><p>组合委托时在赋值语句的右边</p><p>为委托增加事件时在赋值语句的右边</p><h2 id="匿名函数语法"><a href="#匿名函数语法" class="headerlink" title="匿名函数语法"></a>匿名函数语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyDel del = delegate (string str) &#123;</span><br><span class="line">                Console.WriteLine(str);</span><br><span class="line">            &#125;;</span><br><span class="line">            del();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate void MyDel(string str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数不会显式声明返回值，但是实现代码必须通过返回一个与委托的返回值相同的值来匹配委托的返回类型。<br>当委托的参数列表不包含out参数并且匿名方法不适用任何参数时可以省略括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = delegate &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>如果委托声明的参数列表包含了params参数，那么匿名方法的参数列表将忽略params关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">delegate void MyDel(int x,params int[] ints);</span><br><span class="line">//声明</span><br><span class="line">MyDel del = delegate (int x, int[]ints) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>匿名方法可以访问他们外围作用域的局部变量和环境。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>匿名函数几乎被Lambda表达式替代了。<br>其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = (int x , int[] ints) =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>编译器可以从委托的声明中知道委托参数的类型，因此Lambda表达式语序省略类型参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = (x , ints) =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>如果只有一个参数就可以省略两端的圆括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = x =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>Lambda表达式允许表达式的主题是语句块或表达式。如果语句块包含了一个返回语句，我们可以将语句块替换为return关键字后的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = x  =&gt; x*10;</span><br></pre></td></tr></table></figure><p>是不是觉得这样的语法超级简洁</p><h2 id="Lambda表达式参数列表注意事项"><a href="#Lambda表达式参数列表注意事项" class="headerlink" title="Lambda表达式参数列表注意事项"></a>Lambda表达式参数列表注意事项</h2><p>表达式的参数列表不一定需要包含类型，除非委托有ref或out参数。<br>如果只有一个参数且这个参数是隐式类型则可以省略圆括号，否则必须有括号。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2023/08/29/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/08/29/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>事件是类的成员，是使对象或类具有通知能力的成员。<br>事件的组成：发布者、订阅者、事件处理程序、触发事件。<br>事件订阅本质上是一种以委托类型为基础的约定。</p><h2 id="事件相关的说明"><a href="#事件相关的说明" class="headerlink" title="事件相关的说明"></a>事件相关的说明</h2><p>事件包含了一个私有的委托，但是你无法直接访问委托。<br>事件中可用的操作比委托少，我们只能添加、删除或调用事件处理程序。<br>事件被触发时，它调用委托来一次调用调用列表中的方法。<br>+&#x3D;、-&#x3D;是事件唯一允许的操作。<br>委托类型声明：事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。<br>事件处理程序声明：订阅者类中会在事件触发时执行的方法声明。他们不一定是显示命名的方法，还可以是Lambda表达式或匿名方法。<br>事件声明：订阅者必须注册事件才能在事件被触发时得到通知。这是将事件处理程序与事件相连的代码。<br>触发事件的代码：发布者类中“触发”事件并导致调用注册的所有事件处理程序的代码。</p><h2 id="创建发布者类"><a href="#创建发布者类" class="headerlink" title="创建发布者类"></a>创建发布者类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件委托"><a href="#声明事件委托" class="headerlink" title="声明事件委托"></a>声明事件委托</h2><p>订阅者的事件处理程序需要满足该委托。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">public delegate void ClickEventHandle(Button sender, ClickEventArgs e);//定义委托类型 Button：触发事件的对象ClickEventArgs：事件附带的信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件附带信息"><a href="#声明事件附带信息" class="headerlink" title="声明事件附带信息"></a>声明事件附带信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">            public int Width &#123; get; private set; &#125;</span><br><span class="line">            public int Height &#123; get; private set; &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="将触发事件时应执行的函数存放于发布者类的事件委托中"><a href="#将触发事件时应执行的函数存放于发布者类的事件委托中" class="headerlink" title="将触发事件时应执行的函数存放于发布者类的事件委托中"></a>将触发事件时应执行的函数存放于发布者类的事件委托中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">public ClickEventHandle Event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><p>发布者类必须提供事件对象，这需要委托类型和名称。<br>事件是类的成员，并且必须声明为public，这样其他类和结构才可以在它上面注册事件处理程序。<br>不能用new来创建该事件的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        public event ClickEventHandle Click &#123;</span><br><span class="line">        //add添加事件处理程序，remove移除事件处理程序，value外部传入的事件处理程序</span><br><span class="line">            add &#123;</span><br><span class="line">                this.Event += value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove &#123;</span><br><span class="line">                this.Event -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//event：关键字 ClickEventHandler：委托类型 Click：事件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布者触发事件"><a href="#发布者触发事件" class="headerlink" title="发布者触发事件"></a>发布者触发事件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Event != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Event.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建订阅者类并编写事件处理程序"><a href="#创建订阅者类并编写事件处理程序" class="headerlink" title="创建订阅者类并编写事件处理程序"></a>创建订阅者类并编写事件处理程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;//绑定事件处理程序</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(Button sender, ClickEventArgs e) &#123;//事件处理程序</span><br><span class="line">            Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">            Console.WriteLine($&quot;按钮名：&#123;e.Name&#125;，按钮宽度：&#123;e.Width&#125;，按钮高度：&#123;e.Height&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="事件的完整写法"><a href="#事件的完整写法" class="headerlink" title="事件的完整写法"></a>事件的完整写法</h2><p>假设有一个按钮和一个屏幕，三秒后按钮自动按下，屏幕收到按钮按下的事件，在屏幕上显示按钮的信息。<br>结合上面讲述的内容，构成事件的完整写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Button button = new Button();</span><br><span class="line">            Screen screen = new Screen(button);</span><br><span class="line">            await button.Button_Click();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">        public int Width &#123; get; set; &#125;</span><br><span class="line">        public int Height &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(Button sender, ClickEventArgs e) &#123;//事件处理程序</span><br><span class="line">            Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">            Console.WriteLine($&quot;按钮名：&#123;e.Name&#125;，按钮宽度：&#123;e.Width&#125;，按钮高度：&#123;e.Height&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Button &#123;</span><br><span class="line">        public ClickEventHandle Event;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">        public delegate void ClickEventHandle(Button sender, ClickEventArgs e);//定义委托类型 Button：触发事件的对象ClickEventArgs：事件附带的信息</span><br><span class="line">        public event ClickEventHandle Click &#123;</span><br><span class="line">            add &#123;</span><br><span class="line">                this.Event += value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove &#123;</span><br><span class="line">                this.Event -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//event：关键字 ClickEventHandler：委托类型 Click：事件名</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Event != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Event.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件的简单写法"><a href="#事件的简单写法" class="headerlink" title="事件的简单写法"></a>事件的简单写法</h2><p>对于事件的使用.Net提供了一个标准模式，该标准模式的基础就是System名称空间中声明的EventHandler委托类型。<br>在之后声明事件就不需要自己定义事件委托类型了。<br>EventHandler委托需要注意以下几点：<br>第一个参数用来保存触发事件的对象的引用，由于它是object类型的，所以可以匹配任何类型的实例。<br>第二个参数用来保存状态信息，指明什么类型适用于该应用程序。<br>返回类型是void。<br>EventHandler的第二个参数是EventArgs类的对象，它声明在System名称空间中，但是EventArgs不能传递任何数据，它用于不需要传递数据的事件处理程序，通常会被忽略。如果你希望传递数据，必须声明一个派生自EventArgs的类，并使用合适的字段来保存需要传递的数据。<br>事件访问器add和remove可以省路，事件名同时担任事件委托和事件名两个职责，可以简单理解成public event EventHandler Click;声明了一个委托类型成员（但其实不是）<br>了解了上述的概念，我们就可以简化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">using System;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Button button = new Button();</span><br><span class="line">            Screen screen = new Screen(button);</span><br><span class="line">            await button.Button_Click();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">        public int Width &#123; get; set; &#125;</span><br><span class="line">        public int Height &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(object? sender, EventArgs e) &#123;//事件处理程序</span><br><span class="line">            ClickEventArgs ClickArg = e as ClickEventArgs;</span><br><span class="line">            if (ClickArg != null) &#123;</span><br><span class="line">                Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">                Console.WriteLine($&quot;按钮名：&#123;ClickArg.Name&#125;，按钮宽度：&#123;ClickArg.Width&#125;，按钮高度：&#123;ClickArg.Height&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Button &#123;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">        public event EventHandler Click;</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Click != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Click.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托</title>
      <link href="/2023/08/29/%E5%A7%94%E6%89%98/"/>
      <url>/2023/08/29/%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>可以认为委托是持有一个或多个方法的对象，但委托与对象不同，可以执行委托，这时委托会执行它所持有的方法。<br>如果学过C&#x2F;C++可以将委托理解成函数指针的升级版。</p><h2 id="初识委托"><a href="#初识委托" class="headerlink" title="初识委托"></a>初识委托</h2><p>委托与类平级，所以一般声明在类声明的位置，委托的访问性默认是internal。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyDel del = new MyDel(SayHello);</span><br><span class="line">        del.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;Hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate int MyDel(int i);</span><br></pre></td></tr></table></figure><p>创建委托实例时，可以传入实例方法或者静态方法的方法名。</p><h2 id="初始化委托"><a href="#初始化委托" class="headerlink" title="初始化委托"></a>初始化委托</h2><p>我们已经见到了new的赋值方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = new MyDel(Ix10);</span><br></pre></td></tr></table></figure><p>也可以使用委托赋值的快捷方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = SayHello;</span><br></pre></td></tr></table></figure><h2 id="组合委托"><a href="#组合委托" class="headerlink" title="组合委托"></a>组合委托</h2><p>委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表连接了作为操作数的两个委托的调用列表副本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del1 = SayHello;</span><br><span class="line">MyDel del2 = Human.Eat;</span><br><span class="line">MyDel del3 = del1+del2;</span><br></pre></td></tr></table></figure><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>我们已经展示过了组合委托，通过+运算符可以将两个委托组合起来，+和+&#x3D;运算符还可以给委托增加方法到委托的调用队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyDel del = SayHello;</span><br><span class="line">        del += Human.Eat;</span><br><span class="line">        del = del +SayHello;</span><br><span class="line">        del();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void MyDel();</span><br><span class="line">public class Human &#123;</span><br><span class="line">    public static void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用+&#x3D;运算符时，实际上发生的是创建了一个新的委托，其调用列表是左边的委托加上右边方法的组合，然后将这个委托赋值给del。<br>由代码的执行结果来看，其调用顺序与添加方法的顺序相同。</p><h2 id="移除委托方法"><a href="#移除委托方法" class="headerlink" title="移除委托方法"></a>移除委托方法</h2><p>可以使用-和-&#x3D;运算符从委托移除方法 。<br>如果在调用列表中的方法有多个实例，-&#x3D;运算符将从列表最后开始搜索，并且移除第一个与方法匹配的实例。<br>试图删除委托中不存在的方法将无效。<br>试图调用空委托会抛出异常，可以通过将委托和null进行比较来判断委托的调用列表是否为空。如果为空则委托是null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        Action action = SayHello;</span><br><span class="line">        action += Human.Eat;</span><br><span class="line">        action = action + SayHello;</span><br><span class="line">        action = action - SayHello;</span><br><span class="line">        action -= Human.Eat;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void MyDel();</span><br><span class="line">public class Human &#123;</span><br><span class="line">    public static void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式异步调用多播委托"><a href="#显式异步调用多播委托" class="headerlink" title="显式异步调用多播委托"></a>显式异步调用多播委托</h2><p>多播委托默认是同步调用的，但我们可以使用Thread或Task显式异步调用。<br>Thread：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//using System.Threading;</span><br><span class="line">MyDel del = SayHello;</span><br><span class="line">del += Human.Eat;</span><br><span class="line">Thread thread = new Thread(new ThreadStart(del));//可以直接传入方法名或委托实例</span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure><p>Task：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">      Action action = SayHello;</span><br><span class="line">      action += Human.Eat;</span><br><span class="line">      Task task = new Task(action);</span><br><span class="line">      task.Start();</span><br><span class="line">      await Task.Delay(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步调用看不懂没关系，我会在异步编程中介绍的。Task之所以加了Delay是因为如果不await，代码会在执行Human.Eat或者SayHello之前退出。</p><h2 id="Action委托"><a href="#Action委托" class="headerlink" title="Action&lt;&gt;委托"></a>Action&lt;&gt;委托</h2><p>Action委托无需自己定义，由C#语言定义只需要使用即可。<br>Action委托是泛型委托用于无返回值的函数，泛型列表中是被委托函数的参数列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Action&lt;string&gt; action = Say;</span><br><span class="line">        action(&quot;你好世界&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void Say(string str) &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Func委托"><a href="#Func委托" class="headerlink" title="Func&lt;&gt;委托"></a>Func&lt;&gt;委托</h2><p>Func&lt;&gt;委托无需自己定义，由C#语言定义只需要使用即可。<br>Func&lt;&gt;委托是泛型委托用于有返回值的函数，泛型列表中最后一个是方法返回值类型，前几个是被委托函数的参数类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Func&lt;int, int, int&gt; func = new Func&lt;int, int, int&gt;(add);</span><br><span class="line">            int res = func(3,4);</span><br><span class="line">            Console.WriteLine(res);</span><br><span class="line">        &#125;</span><br><span class="line">        static int add(int a,int b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 委托 </tag>
            
            <tag> 多播委托 </tag>
            
            <tag> Action </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dictionary字典</title>
      <link href="/2023/08/28/Dictionary%E5%AD%97%E5%85%B8/"/>
      <url>/2023/08/28/Dictionary%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="字典（dictionary）的声明"><a href="#字典（dictionary）的声明" class="headerlink" title="字典（dictionary）的声明"></a>字典（dictionary）的声明</h2><p>声明字典时,需同时声明字典内的键和值的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br></pre></td></tr></table></figure><h2 id="字典的读取与增加"><a href="#字典的读取与增加" class="headerlink" title="字典的读取与增加"></a>字典的读取与增加</h2><p>键和值可以是任何类型，但键必须是唯一的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br><span class="line">        dic.Add(1, &quot;hi&quot;);</span><br><span class="line">        dic.Add(2, &quot;你好&quot;);</span><br><span class="line">        dic[3] = &quot;hello&quot;;</span><br><span class="line">        Console.WriteLine(dic[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int, string&gt; &#123;</span><br><span class="line">            &#123;1,&quot;hello world&quot; &#125;,</span><br><span class="line">            &#123;2,&quot;字典的基本用法&quot; &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h2 id="dic-Remove-key"><a href="#dic-Remove-key" class="headerlink" title="dic.Remove(key)"></a>dic.Remove(key)</h2><p>用于移除键对应的成员，返回bool，成功为true，失败为false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br><span class="line">        dic.Add(1, &quot;hi&quot;);</span><br><span class="line">        dic.Add(2, &quot;你好&quot;);</span><br><span class="line">        dic.Remove(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Dictionary </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型List类</title>
      <link href="/2023/08/28/%E6%B3%9B%E5%9E%8BList%E7%B1%BB/"/>
      <url>/2023/08/28/%E6%B3%9B%E5%9E%8BList%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>泛型list的底层是动态数组，其容量可自动或手动调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        List&lt;int&gt; IntList = new List&lt;int&gt;();</span><br><span class="line">        IntList.Add(1);</span><br><span class="line">        IntList.Add(2);</span><br><span class="line">        IntList.Add(3);</span><br><span class="line">        Console.WriteLine(IntList.Count);//集合元素的数量</span><br><span class="line">        Console.WriteLine(IntList.Capacity);//底层数组长度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以向（）中传入一个整数来限制list的底层数组大小。</p><h2 id="List常用API"><a href="#List常用API" class="headerlink" title="List常用API"></a>List常用API</h2><p>list.Add(int value)     添加元素</p><p>list.AddRange(IEnumerable <code>&lt;int&gt;</code> list)      添加一组元素</p><p>list.Insert(int index,int value)            插入元素</p><p>list.InsertRange(int index,IEnumerable <code>&lt;int&gt;</code>list)         插入一组元素</p><p>list.Clear()           清空（底层数组长度不变）</p><p>list.Remove(int index)      移除</p><p>list.RemoveRange(int index,int length)      移除length个元素</p><p>list.RemoveAll(e&#x3D;&gt;e&#x3D;&#x3D;400)     接受一个返回值为bool的委托，移除满足条件的成员</p><p>list.GetRange(int index,int length)       返回一个List <code>&lt;int&gt;</code>类型的对象，包含被截取的成员</p><p>list.GetEnumerator()          返回List <code>&lt;int&gt;</code>类型对象的Enumerator迭代器，迭代器会在之后的篇章中介绍。</p><p>list.ForEach(e&#x3D;&gt;e*10)       遍历</p><p>list.Contain(100)           返回bool，检测一个值是否存在于list中</p><p>list.Exists(e&#x3D;&gt;e&gt;500))      返回bool，用来检测list中是否有满足条件的元素</p><p>list.TrueForAll(e&#x3D;&gt;e&lt;&#x3D;40)        返回bool，检测所有元素是否都满足要求</p><p>list.IndexOf(300)        返回第一个值为300的成员的索引，底层调用&#x3D;&#x3D;，没有则返回-1</p><p>list.IndexOf(value,index)         从index位置开始，往后找value所在的索引,index最大为list.Count,再大就报错了</p><p>list.IndexOf(value,startIndex,much)     从stratIndex位置开始，到其往后much个元素位置，查找是否有value，返回value的索引</p><p>list.Find(e&#x3D;&gt;e%3&#x3D;&#x3D;0)      返回第一个满足要求的值</p><p>list.FindLast(e&#x3D;&gt;e%4&#x3D;&#x3D;0)          返回最后一个满足要求的值</p><p>list.FindAll(e&#x3D;&gt;e%3&#x3D;&#x3D;0)         返回一个由满足要求的值组成的新集合</p><p>list.FindIndex(e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindIndex(index,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindIndex(index,much,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(index,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(index,much,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.BinarySearch(value)          在排好序的list中用二分查找value所在的位置</p><h2 id="list-Contain"><a href="#list-Contain" class="headerlink" title="list.Contain()"></a>list.Contain()</h2><p>其底层原理是&#x3D;&#x3D;，如果是引用类型则用Equals方法，自定义类型没有Equals方法需要覆写object的Equals方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        List&lt;Book&gt; list = new List&lt;Book&gt;();</span><br><span class="line">        Book book1 = new Book();</span><br><span class="line">        Book book2 = new Book();</span><br><span class="line">        book1.id = 1;</span><br><span class="line">        book2.id = 2;</span><br><span class="line">        list.Add(book1);</span><br><span class="line">        list.Add(book2);</span><br><span class="line">        Console.WriteLine(list.Contains(book1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book &#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public override bool Equals(object? obj) &#123;</span><br><span class="line">        if(obj ==null) return false;</span><br><span class="line">        Book other = obj as Book;</span><br><span class="line">        if(other == null) return false;</span><br><span class="line">        return this.id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list-Sort"><a href="#list-Sort" class="headerlink" title="list.Sort()"></a>list.Sort()</h2><p>其底层用CompareTo方法，引用类型没有CompareTo方法所以要自己写，要求该引用类型实现IComparable&lt;&gt;接口&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Book book1 = new Book();</span><br><span class="line">        Book book2 = new Book();</span><br><span class="line">        Book book3 = new Book();</span><br><span class="line">        book1.ID = 9;</span><br><span class="line">        book2.ID=4;</span><br><span class="line">        book3.ID=15;</span><br><span class="line">        List&lt;Book&gt; list = new List&lt;Book&gt;&#123; book1,book2,book3&#125;;</span><br><span class="line">        list.Sort();</span><br><span class="line">        foreach (Book book in list) &#123;</span><br><span class="line">            Console.WriteLine(book.ID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book:IComparable&lt;Book&gt; &#123;</span><br><span class="line">    public int ID &#123; get; set; &#125;</span><br><span class="line">    public int CompareTo(Book? obj) &#123;</span><br><span class="line">        if (obj == null) return 1;</span><br><span class="line">        return this.ID - obj.ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList类</title>
      <link href="/2023/08/28/ArrayList%E7%B1%BB/"/>
      <url>/2023/08/28/ArrayList%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList类在System.Collections名称空间中，ArrayList存放的是object类型成员。<br>ArrayList的大小是按照其中存储的数据来动态扩充与收缩的。<br>ArrayList不是类型安全的，使用时可能会出现类型不匹配的错误。<br>就算都插入了同一类型的数据，在使用时也需要将它转成对应的袁类型来处理。<br>ArrayList的存储存在装箱、拆箱导致性能低下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        ArrayList arrayList = new ArrayList();</span><br><span class="line">        arrayList.Add(&quot;abc&quot;);</span><br><span class="line">        arrayList.Add(123);</span><br><span class="line">        arrayList[2] = 12.4;</span><br><span class="line">        arrayList.Remove(12.4);</span><br><span class="line">        arrayList.RemoveAt(1);</span><br><span class="line">        arrayList.Insert(0, &quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/08/28/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/08/28/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>C#不支持动态数组，如果想实现类似JS数组的效果，可以参考ArralList或者List。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>矩形数组：<br>某个维度的所有子数组具有相同长度的多维数组。<br>不管有多少维度，总是使用一组方括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mayArray[4,6,1];//一组方括号</span><br></pre></td></tr></table></figure><p>交错数组：<br>每一个子数组都是独立数组的多维数组。<br>可以有不同长度的子数组。<br>为数组的每一个维度使用一对方括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jagArray[2][7][4];</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%95%B0%E7%BB%84/1.jpg"></p><h2 id="声明一维数组与矩形数组"><a href="#声明一维数组与矩形数组" class="headerlink" title="声明一维数组与矩形数组"></a>声明一维数组与矩形数组</h2><p>一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr;</span><br></pre></td></tr></table></figure><p>矩形数组：<br>可以使用多个秩说明符。<br>不能在数组类型区域中放数组维度长度。秩是数组类型的一部分，而维度长度不是类型的一部分。<br>数组声明后维度数就是固定的了，然而数组长度直到数组实例化时才会确定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[,,] arr1;</span><br><span class="line">int[,] arr2;</span><br><span class="line">int[3,2,6] arr3;//编译错误</span><br></pre></td></tr></table></figure><h2 id="实例化一维数组与矩形数组"><a href="#实例化一维数组与矩形数组" class="headerlink" title="实例化一维数组与矩形数组"></a>实例化一维数组与矩形数组</h2><p>一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = new int[4];</span><br><span class="line">int[] arr2 = new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">int[] arr3 = &#123;1,2,3,4&#125;;</span><br><span class="line">var intArr1 = new []&#123;1,2,3,4&#125;;//隐式数组，类型由编译器推断</span><br></pre></td></tr></table></figure><p>矩形数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[,,] arr4 = new int[3,6,2];</span><br><span class="line">int[,] arr5 = new int[,]&#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;</span><br><span class="line">int[,] arr6 = &#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;</span><br><span class="line">var intArr2 = new [,]&#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;//隐式数组，类型由编译器推断</span><br></pre></td></tr></table></figure><p>当数组被创建之后，每一个元素被自动初始化为类型的默认值</p><h2 id="声明交错数组"><a href="#声明交错数组" class="headerlink" title="声明交错数组"></a>声明交错数组</h2><p>方括号的数量决定了数组的秩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[][] SomeArr;</span><br><span class="line">int[][][] OtherArr;</span><br></pre></td></tr></table></figure><h2 id="实例化交错数组"><a href="#实例化交错数组" class="headerlink" title="实例化交错数组"></a>实例化交错数组</h2><p>不能在声明语句中初始化顶层数组之外的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] jagArr = new int[3][];</span><br></pre></td></tr></table></figure><h2 id="初始化交错数组"><a href="#初始化交错数组" class="headerlink" title="初始化交错数组"></a>初始化交错数组</h2><p>交错数组的初始化不能在一个步骤中完成，每一个数组必须独立创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[3][];</span><br><span class="line">arr[0] = new int[]&#123;1,2,3&#125;;</span><br><span class="line">arr[1] = new int[]&#123;4,5,6&#125;;</span><br><span class="line">arr[2] = new int[]&#123;7,8,9&#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组的子数组"><a href="#交错数组的子数组" class="headerlink" title="交错数组的子数组"></a>交错数组的子数组</h2><p>交错数组的子数组本事就是数组，因此子数组可能有矩形数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[][,]Arr;</span><br><span class="line">Arr = new int[3][,];</span><br><span class="line">Arr[0] = new int[]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;</span><br><span class="line">Arr[1] = new int[]&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;;</span><br><span class="line">Arr[2] = new int[]&#123;&#123;9,10&#125;,&#123;11,12&#125;&#125;;</span><br></pre></td></tr></table></figure><p>System.Array的GetLength(int n)方法可以获取数组中指定维度的长度。</p><h2 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h2><p>foreach语句会遍历实现IEnumerable接口的迭代对象，foreach遍历是只读的，不能在foreach中对迭代对象做修改。<br>想要遍历交错数组需要对交错数组中每一个维度使用独立的foreach语句。foreach语句必须嵌套以确保每一个嵌套数组都被正确处理。</p><h2 id="数组协变"><a href="#数组协变" class="headerlink" title="数组协变"></a>数组协变</h2><p>在某些情况下，即使某个对象不是数组的基类型，也可以把它赋值给数组元素这种属性称为协变，以下情况可以使用数组协变：<br>数组是引用类型数组。<br>在赋值的对象类型和数组基类型之间有隐式转换或显式转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        A[] AArr1 = new A[3];</span><br><span class="line">        A[] AArr2 = new A[3];</span><br><span class="line">        //普通</span><br><span class="line">        AArr1[0] = new A(); AArr1[1] = new A(); AArr1[2] = new A();</span><br><span class="line">        //协变</span><br><span class="line">        AArr2[0] = new (); AArr2[1] = new B(); AArr2[2] = new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123; &#125;</span><br><span class="line">class B:A &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="有用的数组成员"><a href="#有用的数组成员" class="headerlink" title="有用的数组成员"></a>有用的数组成员</h2><p>Rank属性实例获取数组维度数<br>Length属性实例获取所有维度的元素总数<br>GetLength 方法实例返回数组的指定维度的长度<br>Clear方法静态将某一范围内的元素设置为0或null<br>Sort 方法静态在一维数组中对元素进行排序<br>BinarySerach方法静态使用二分查找搜索一维数组中的值<br>Clone方法实例进行数组的浅复制——对于值类型数组复制元素对于引用类型则产生指向相同元素的两个数组<br>IndexOf方法静态返回一维数组中遇到的第一个值<br>Reverse方法静态反转一维数组中某一范围内的元素<br>GetUpperBound方法实例获取指定维度的上限</p><h2 id="Clone方法"><a href="#Clone方法" class="headerlink" title="Clone方法"></a>Clone方法</h2><p>对于值类型克隆产生两个数组<br>对于引用类型产生指向相同对象的两个数组<br>克隆方法返回object类型的引用，它必须被强制转换成数组类型！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int[] intArr1 = &#123; 1, 2, 3, &#125;;</span><br><span class="line">        var intArr2 = (int[])intArr1.Clone();</span><br><span class="line">        A[] AArr1 = &#123; new A(),new A(),new A() &#125;;</span><br><span class="line">        var AArr2 = (A[]) AArr1.Clone();</span><br><span class="line">        AArr2[0].val = 12;</span><br><span class="line">        Console.WriteLine(AArr1[0].val);//12</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">    public int val = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 数组 </tag>
            
            <tag> 矩形数组 </tag>
            
            <tag> 交错数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/08/28/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/08/28/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举的简单使用"><a href="#枚举的简单使用" class="headerlink" title="枚举的简单使用"></a>枚举的简单使用</h2><p>枚举是值类型，枚举只有一种类型成员——命名的整数值常量。<br>默认情况下第一个成员为0，每一个后继成员赋的值都比前一个成员多1。<br>枚举成员是静态的，他们和枚举有着相同的可访问性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum TrafficLight&#123;</span><br><span class="line">Green,Yellow,Red</span><br><span class="line">&#125;</span><br><span class="line">TrafficLight t = TrafficLight.Green;</span><br><span class="line">Console.WriteLine($&quot; &#123;t&#125; , &#123; (int)t &#125; &quot;);//Green,0</span><br></pre></td></tr></table></figure><p>注意枚举成员的ToString()方法返回的是成员名，强制转换才能看到枚举值。</p><h2 id="枚举底层类型与显示值"><a href="#枚举底层类型与显示值" class="headerlink" title="枚举底层类型与显示值"></a>枚举底层类型与显示值</h2><p>可以设置底层类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum TrraggicLight : ulong &#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以显式指定成员的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum TrafficLight&#123;</span><br><span class="line">Green,Yellow=12,Red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位标志"><a href="#位标志" class="headerlink" title="位标志"></a>位标志</h2><p>程序员经常使用单个字的不同位作为一组开&#x2F;关标志的紧凑方法，枚举为这样的使用提供了便利。<br>使用Flags特性装饰枚举实际上是不必要的，但可以带来一些额外的遍历。<br>要判断标志字是否包含特定的位标志集，可以使用枚举类型的HasFlag布尔方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        CardDeckSetting ops = CardDeckSetting.SingleDeck | CardDeckSetting.FancyNumber | CardDeckSetting.Animation;</span><br><span class="line">        bool useFancyNumbers = ops.HasFlag(CardDeckSetting.FancyNumber);</span><br><span class="line">        if(useFancyNumbers) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ok&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[Flags]</span><br><span class="line">enum CardDeckSetting : uint &#123;</span><br><span class="line">    SingleDeck = 0x01,</span><br><span class="line">    LargePictures = 0x02,</span><br><span class="line">    FancyNumber = 0x04,</span><br><span class="line">    Animation = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flags特性"><a href="#Flags特性" class="headerlink" title="Flags特性"></a>Flags特性</h2><p>它通知编译器、对象浏览器以及其他查看这段代码的工具，该枚举的成员不仅可以用作单独的值，还可以组合成位标志，这样浏览器就可以更恰当地解释该枚举类型的变量了。<br>其次，它允许枚举的ToString方法为位标志的值提供更多格式化信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        CardDeckSetting ops = CardDeckSetting.SingleDeck | CardDeckSetting.FancyNumber | CardDeckSetting.Animation;</span><br><span class="line">        bool useFancyNumbers = ops.HasFlag(CardDeckSetting.FancyNumber);</span><br><span class="line">        //有Flags特性：SingleDeck, FancyNumber, Animation</span><br><span class="line">        //没有Flages特性：13</span><br><span class="line">        Console.WriteLine(ops);</span><br><span class="line">    &#125;                                           </span><br><span class="line">&#125;</span><br><span class="line">[Flags]</span><br><span class="line">enum CardDeckSetting : uint &#123;</span><br><span class="line">    SingleDeck = 0x01,</span><br><span class="line">    LargePictures = 0x02,</span><br><span class="line">    FancyNumber = 0x04,</span><br><span class="line">    Animation = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum类型的一些静态方法"><a href="#Enum类型的一些静态方法" class="headerlink" title="Enum类型的一些静态方法"></a>Enum类型的一些静态方法</h2><p>Enum.GetName：<br>参数：枚举类型对象，整数<br>返回：对应成员的名称<br>Enum.GetNames：<br>参数：枚举类型对象<br>返回：所有成员的名称且实现IEnumerable接口</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 枚举 </tag>
            
            <tag> Flags特性 </tag>
            
            <tag> 位标志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="结构体的声明和使用"><a href="#结构体的声明和使用" class="headerlink" title="结构体的声明和使用"></a>结构体的声明和使用</h2><p>结构体是值类型，无法派生其他结构。<br>结构体变量不能为null，两个结构体变量不能引用同一对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Simple&#123;</span><br><span class="line">public int a;</span><br><span class="line">public int b;</span><br><span class="line">&#125;</span><br><span class="line">Simple simple = new Simple();</span><br></pre></td></tr></table></figure><p>把一个结构体赋值给另一个结构体，就是将一个结构体的值复制给你另一个结构体。<br>结构体可以有实例构造函数和静态构造函数，但不允许有析构函数。<br>结构体隐式含有一个无参构造函数，不可删除或重定义，结构体的值成员设置为默认值，引用成员设置为null。<br>对于类，编译器只在没有声明其他构造函数时提供隐式的无参构造函数。<br>可以不使用new来创建结构体实例，但这样做只有显式设置数据成员后才能使用它们的值并且在对所有数据成员赋值后，才能调用结构的函数成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple s1,s2;</span><br><span class="line">s1.a=3;</span><br><span class="line">s1.b=4;</span><br><span class="line">Console.WriteLine(s1.a);</span><br></pre></td></tr></table></figure><p>注意：声明结构体时不允许使用实例属性和字段初始化语句，但是静态属性和字段可以在声明时初始化即使结构体本身不是静态的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Simple&#123;</span><br><span class="line">public int a = 3;//报错</span><br><span class="line">public static int b = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构本身派生自System.ValueType，当创建一个和基类成员同名的成员时可以使用new或override修饰符。</p><h2 id="结构作为返回值和参数"><a href="#结构作为返回值和参数" class="headerlink" title="结构作为返回值和参数"></a>结构作为返回值和参数</h2><p>返回值：<br>当结构作为返回值时将创建副本从函数成员返回。<br>值参数：<br>创建副本传入函数。<br>ref和out：<br>传入结构的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结构代替类有时可以提高性能，但同时也要注意装箱拆箱的成本。<br>可以使用分部结构就像分部类一样。<br>结构可以实现接口。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式、运算符、语句、转换</title>
      <link href="/2023/08/28/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/08/28/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>基本的表达式、运算符、语句、转换在这就不过多介绍，有几个比较少见的就在这多提一嘴吧。</p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量@"></a>字符串字面量@</h2><p>逐字字符串字面量以@字符为前缀，而且该字符串中的转义序列不会被求值。<br>逐字字符串字面量的唯一例外是相邻的双引号组会被解释成单个双引号字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string vst1 = @&quot;Hello world&quot;&quot;&quot;;</span><br><span class="line">string vst2 = @&quot;H\tell\no\tworld&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><h2 id="委托的比较"><a href="#委托的比较" class="headerlink" title="委托的比较"></a>委托的比较</h2><p>如果两个委托都是null，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，那么比较返回true。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载不能创建新的运算符，不能改变运算符的语法，不能重新定义运算符如何处理预定义类型，不能改变运算符的优先级或结合性。<br>注意：对于引用类型的对象，前置操作没有问题，因为没有进行复制。但是对于后置操作，因为保存的副本是引用的副本，所以这意味着原始引用和引用副本指向相同的对象。</p><p>声明时必须使用public static。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        LimitedInt limitedInt = new LimitedInt();</span><br><span class="line">        Console.WriteLine((limitedInt + 8).TheValue);</span><br><span class="line">        Console.WriteLine((-limitedInt).TheValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int TheValue = 20;</span><br><span class="line">    public static LimitedInt operator +(LimitedInt x,double y) &#123;</span><br><span class="line">        LimitedInt li =new LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue + (int)y;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">    public static LimitedInt operator -(LimitedInt x) &#123;</span><br><span class="line">        LimitedInt li = new LimitedInt();</span><br><span class="line">        li.TheValue = 0;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只可以为类和结构定义用户自定义转换，不能重定义标准隐式或显式转换。</p><p>源类型和目标类型必须是不同类型，且不能通过继承关联。</p><p>源类型和目标类型不能是接口类型或object类型。</p><p>转换运算符必须是源类型或目标类型的成员。</p><p>对于相同的源类型和目标类型不能声明隐式和显式转换。</p><h2 id="using语句"><a href="#using语句" class="headerlink" title="using语句"></a>using语句</h2><p>某些类型的非托管对象有数量限制或很耗费系统资源，需要使用完尽快释放，using语言有助于简化该过程并确保这些资源被适当处理。<br>资源是指实现了System.IDisposable接口的类或结构，IDisposable接口含有单独一个名为Dispose的方法。<br>使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using(TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))&#123;</span><br><span class="line">    tw.WriteLine(&quot;Four score and seven years age...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用于相同的多个类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using(TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;),</span><br><span class="line">      TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))&#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>typeof运算符返回作为其参数的任何类型的System.Type对象，可以理解成该实例对应类型的说明，Type类型是反射和依赖注入的基础，之后我会详细介绍。</p><h2 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h2><p>有些转换是不成功的，并且在运行时抛出InvalidCastException异常。可以用is运算符检查转换是否成功完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expr is TargetType</span><br></pre></td></tr></table></figure><p>返回布尔值，如果Expr可以通过引用转换、装箱、拆箱成功转换为目标值，则运算符返回true。</p><p>is运算符只可以用于引用转换以及装箱拆箱，不能用于用户自定义转换。</p><h2 id="as运算符"><a href="#as运算符" class="headerlink" title="as运算符"></a>as运算符</h2><p>as运算符和强制转换相似，只是它不抛出异常，如果转换失败，它返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exper as TargetType</span><br></pre></td></tr></table></figure><p>as运算符只可以用于引用转换以及装箱拆箱，不能用于用户自定义转换。</p><h2 id="checked-unchecked语句和checked-unchecked运算符"><a href="#checked-unchecked语句和checked-unchecked运算符" class="headerlink" title="checked&#x2F;unchecked语句和checked&#x2F;unchecked运算符"></a>checked&#x2F;unchecked语句和checked&#x2F;unchecked运算符</h2><p>check语句用来检查转换结果是否溢出，如果我们指定一个表达式或一个代码片段为checked，当转换产生溢出时会抛出OverflowException异常。</p><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked((int)3.14);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checked&#123;</span><br><span class="line">int a = 12.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户定义类型转换"><a href="#用户定义类型转换" class="headerlink" title="用户定义类型转换"></a>用户定义类型转换</h2><p>public和static是用户定义类型转换所必须的。<br>隐式转换（implicit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public static implicit operator int (LimitedInt li) &#123;//隐式转换LimitedInt——&gt;int</span><br><span class="line">        return li.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static implicit operator LimitedInt (int val) &#123;//隐式转换int——&gt;LimitedInt</span><br><span class="line">        LimitedInt li = new LimitedInt ();</span><br><span class="line">        li.value = val;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式转换（explicit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public static explicit operator int (LimitedInt li) &#123;//显式转换LimitedInt——&gt;int</span><br><span class="line">        return li.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static explicit operator LimitedInt (int val) &#123;//显式转换int——&gt;LimitedInt</span><br><span class="line">        LimitedInt li = new LimitedInt ();</span><br><span class="line">        li.value = val;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 运算符重载 </tag>
            
            <tag> 字符串字面量 </tag>
            
            <tag> using语句 </tag>
            
            <tag> is </tag>
            
            <tag> as </tag>
            
            <tag> checked </tag>
            
            <tag> 自定义类型转换 </tag>
            
            <tag> typeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2023/08/28/%E5%A4%9A%E6%80%81/"/>
      <url>/2023/08/28/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>原本打算抽象类和接口一起讲的，但是抽象类也属于多态的章节，而多态又是C#中很重要的部分，所以我觉得还是抽象类和多态一起讲吧。</p><h2 id="虚方法与覆写方法（virtual）"><a href="#虚方法与覆写方法（virtual）" class="headerlink" title="虚方法与覆写方法（virtual）"></a>虚方法与覆写方法（virtual）</h2><p>虚方法可以使基类的引用访问升至派生类内。<br>基类的方法用virtual标注。<br>派生类的方法用override标注。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Human human = new Man();</span><br><span class="line">        human.Eat();//我可以吃方便面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    virtual public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man : Human &#123;</span><br><span class="line">   override public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃方便面&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆写和被覆写的方法必须有相同的可访问性。<br>不能复写static方法和非虚方法。<br>方法、属性、索引器、事件都可以声明virtual和override。<br>方法的调用被沿着派生层次上溯之中，一直到标记为override的方法的最高派生版本。</p><h2 id="抽象（abstract）"><a href="#抽象（abstract）" class="headerlink" title="抽象（abstract）"></a>抽象（abstract）</h2><p>抽象成员指的是必须被覆写的函数成员用abstract，与虚拟成员不同，虚拟成员是可以被覆写抽象成员则是必须被复写，两者都只能覆写函数成员且虚拟成员和抽象成员都不能是私有的。<br>有了abstract就不能写virtual了。<br>含有抽象成员的类被称为抽象类，抽象类只能被用作其他类的基类不能创建实例，被abstract修饰。<br>派生类中的抽象成员必须指定override修饰符，除非这个派生类也是抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract protected void Use();</span><br><span class="line">&#125;</span><br><span class="line">class Human : Animal &#123;</span><br><span class="line">    override protected void Use() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以生火和制造工具&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类常用来解耦，抽象类的进一步抽象便是接口。</p><h2 id="密封类（sealed）"><a href="#密封类（sealed）" class="headerlink" title="密封类（sealed）"></a>密封类（sealed）</h2><p>密封类不能用作基类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealed class Human&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类（static）"><a href="#静态类（static）" class="headerlink" title="静态类（static）"></a>静态类（static）</h2><p>静态类中所有成员都是静态的。<br>可以有一个静态构造函数但是不能有实例构造函数，因为静态类不能创建实例。<br>不能继承静态类。<br>常用的静态类比如Math类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Math.Max(12,99));</span><br><span class="line">Console.WriteLine(Math.Round(12.567));</span><br></pre></td></tr></table></figure><p>静态类常用来做扩展方法：<br>扩展方法是Linq中常用的方法，用来给类增加静态方法和实例方法，以下是int类型的扩展方法演示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int a = 3;</span><br><span class="line">        if (a.Max(4)||) &#123;</span><br><span class="line">            Console.WriteLine(&quot;a更大&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            Console.WriteLine(&quot;a更小&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static class ExtendInt &#123;</span><br><span class="line">    public static bool Max(this int a,int b) &#123;</span><br><span class="line">        return a &gt; b ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须包裹在一个静态类中，拓展方法必须是静态的，拓展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它拓展的类的名称。<br>扩展方法同时扩展了静态方法和实例方法，如果想静态调用，则第一个参数应为拓展类型的实例。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> virtual </tag>
            
            <tag> abstract </tag>
            
            <tag> sealed </tag>
            
            <tag> static </tag>
            
            <tag> 多态 </tag>
            
            <tag> 扩展方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的继承</title>
      <link href="/2023/08/28/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/08/28/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="屏蔽基类的成员"><a href="#屏蔽基类的成员" class="headerlink" title="屏蔽基类的成员"></a>屏蔽基类的成员</h2><p>派生类不能删除它继承的成员但是可以用与基类成员名称相同的成员来屏蔽基类成员。<br>要让编译器知道你是故意屏蔽，可使用new操作符。<br>也可以屏蔽静态成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    public string name = &quot;爸爸&quot;;</span><br><span class="line">    public void MakeMoney() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以赚钱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son : Father &#123;</span><br><span class="line">    new public string name = &quot;儿子&quot;;</span><br><span class="line">    new public void MakeMoney() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我也可以赚钱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基类访问"><a href="#基类访问" class="headerlink" title="基类访问"></a>基类访问</h2><p>如果需要访问被隐藏的继承成员，可使用基类访问表达式：base.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(base.name);</span><br></pre></td></tr></table></figure><h2 id="基类引用"><a href="#基类引用" class="headerlink" title="基类引用"></a>基类引用</h2><p>可以声明基类变量引用子类实例，但是产生的变量仅能访问到基类身上的成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father father = new Son();</span><br></pre></td></tr></table></figure><h2 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h2><p>初始化实例成员——&gt;调用基类构造函数——&gt;执行实例构造函数方法体。<br>注意：强烈反对在构造函数中调用虚方法。在执行基类的构造函数时，基类的虚方法会调用派生类的复写方法，但这是在执行派生类的构造函数方法体之前。因此，调用会在派生类完全初始化之前传递到派生类。</p><h2 id="初始化构造函数"><a href="#初始化构造函数" class="headerlink" title="初始化构造函数"></a>初始化构造函数</h2><p>可以指定用某个基类的构造函数来初始化子类的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Man man1 = new Man();</span><br><span class="line">        Console.WriteLine(man1.Height);</span><br><span class="line">        Man man2 = new Man(180);</span><br><span class="line">        Console.WriteLine(man2.Height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    public int Height;</span><br><span class="line">    public Human(int height) &#123;</span><br><span class="line">        this.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public Human() &#123;</span><br><span class="line">        this.Height = 165;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man : Human &#123;</span><br><span class="line">    public Man() :base() &#123;&#125;</span><br><span class="line">    public Man(int height) : base(height) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以让构造过程使用当前类中其他的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Human human = new Human(75,180);</span><br><span class="line">        Console.WriteLine($&quot;身高&#123;human.Height&#125;，体重&#123;human.Weight&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    public int Height;</span><br><span class="line">    public int Weight;</span><br><span class="line">    private Human(int height) &#123;</span><br><span class="line">        this.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public Human(int weight,int height) :this(height)&#123;</span><br><span class="line">        this.Weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有好几个构造函数，并且它们都需要在对象构造的过程开始时执行公共的代码，可以把公共代码抽取出来作为一个构造函数。<br>readonly字段只能在构造函数中初始化，但是readonly属性不受这个限制。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 屏蔽 </tag>
            
            <tag> 基类访问 </tag>
            
            <tag> 基类引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的参数</title>
      <link href="/2023/08/28/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2023/08/28/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引用参数（ref）"><a href="#引用参数（ref）" class="headerlink" title="引用参数（ref）"></a>引用参数（ref）</h2><p>当参数类型为引用参数时，实参必须是变量，在用作实参前必须被赋值！如果是引用类型变量，可以赋值为一个引用或null。<br>函数声明和调用时都需要在ref参数前加上”ref”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void RefTest(ref int a)&#123; ... &#125;</span><br><span class="line">int a = 3;</span><br><span class="line">RefTest(ref a);</span><br><span class="line">RefTest(3);//报错，必须为变量</span><br></pre></td></tr></table></figure><p>对于值参数，系统会在栈上为形参分配内存，而引用参数不会在栈上分配内存，形参的参数名将作为实参变量的别名指向相同的内存位置。<br>将引用类型对象作为值参数传递时：如果在方法内创建一个新对象并赋值给形参，在方法调用结束后，将切断形参和实参的关联，新对象也不复存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        //调用前</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.age = 20;</span><br><span class="line">        Console.WriteLine(&quot;执行前&quot;+std.age);</span><br><span class="line">        MakeStd(std);</span><br><span class="line">        Console.WriteLine(&quot;执行后&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeStd(Student std) &#123;</span><br><span class="line">std.age = 50;</span><br><span class="line">        Student std2 = new Student();</span><br><span class="line">        std2.age = 20;</span><br><span class="line">        std = std2;</span><br><span class="line">        Console.WriteLine(&quot;执行中：&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/1.jpg" alt="值参数"><br>将引用类型的对象作为引用参数传递时：如果在方法内创建一个新对象并赋值给形参，在方法调用结束后，该对象依然存在，并且是实参所引用的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        //调用前</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.age = 20;</span><br><span class="line">        Console.WriteLine(&quot;执行前&quot;+std.age);</span><br><span class="line">        MakeStd(ref std);</span><br><span class="line">        Console.WriteLine(&quot;执行后&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeStd(ref Student std) &#123;</span><br><span class="line">std.age = 50;</span><br><span class="line">        Student std2 = new Student();</span><br><span class="line">        std2.age = 20;</span><br><span class="line">        std = std2;</span><br><span class="line">        Console.WriteLine(&quot;执行中：&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/2.jpg" alt="应用参数"></p><h2 id="输出参数（out）"><a href="#输出参数（out）" class="headerlink" title="输出参数（out）"></a>输出参数（out）</h2><p>函数声明和调用时都需要在out参数前加上”out”。<br>实参必须是变量。<br>在方法内部，给输出参数赋值之后才能读取它。<br>方法返回之前，每条可能的路径都必须为输出参数赋值。<br>不可能使用输出参数把数据传入方法。<br>形参的名称被设置为实参的别名，可以认为形参实参指向相同内存位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass a1 = null;</span><br><span class="line">        int a2;</span><br><span class="line">        MyMethod(out a1, out a2);</span><br><span class="line">        Console.WriteLine(a1.val);</span><br><span class="line">        Console.WriteLine(a2);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MyMethod(out MyClass f1 , out int f2) &#123;</span><br><span class="line">        f1 = new MyClass();</span><br><span class="line">        f1.val = 25;</span><br><span class="line">        f2 = 15;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    public int val = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main()&#123;</span><br><span class="line">MyMethod(out MyClass a1 , out int a2);</span><br><span class="line">Cosole.WriteLine(a2);</span><br><span class="line">Cosole.WriteLine(a1.val);</span><br><span class="line">a2++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/3.jpg" alt="out"></p><h2 id="参数数组（params）"><a href="#参数数组（params）" class="headerlink" title="参数数组（params）"></a>参数数组（params）</h2><p>一个参数列表中只能有一个参数数组，并且它必须是列表最后一个。<br>参数数组表示的所有参数必须是同一类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        ParamsTest(9, 8, 7, 6, 5, 4, 3, 2, 1);</span><br><span class="line">        int[] ints = &#123;7,6,5,4,3,2,1&#125;;</span><br><span class="line">        ParamsTest(9,8,ints);</span><br><span class="line">    &#125;</span><br><span class="line">    static void ParamsTest(int a, int b ,params int[] vals) &#123;</span><br><span class="line">        foreach(int i in vals) &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref局部变量与ref返回"><a href="#ref局部变量与ref返回" class="headerlink" title="ref局部变量与ref返回"></a>ref局部变量与ref返回</h2><p>ref局部变量：<br>相当于一个变量的别名，即使引用的对象是值类型。<br>对任意一个变量的赋值都会反映到另一个变量上。<br>ref变量声明时必须初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">reg int y = ref x;</span><br></pre></td></tr></table></figure><p>ref返回：<br>ref返回提供了一种使方法返回变量引用而不是变量值的方法。<br>函数声明返回值类型前有ref。<br>函数内部return后有ref。<br>函数调用时函数名前有ref。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int a = 3, b = 4;</span><br><span class="line">        ref int max = ref Max(ref a, ref b);</span><br><span class="line">        Console.WriteLine(++max);</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">        Console.WriteLine(b);</span><br><span class="line">    &#125;</span><br><span class="line">    static ref int Max(ref int a, ref int b) &#123;</span><br><span class="line">        if (a &gt; b)  return ref a; </span><br><span class="line">        else return ref b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>只要显式指定参数的名字，就可以以任意顺序在方法中列出实参。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">    int val;</span><br><span class="line">        val = Calc(c: 4, a: 1, b: 8);</span><br><span class="line">        Console.WriteLine(val);</span><br><span class="line">    &#125;</span><br><span class="line">    static int Calc(int a, int b,int c) &#123;</span><br><span class="line">        return (a+b) * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数（参数默认值）"><a href="#可选参数（参数默认值）" class="headerlink" title="可选参数（参数默认值）"></a>可选参数（参数默认值）</h2><p>不是所有参数类型都可以作为可选参数：<br>只要值类型的默认值在编译的时候可以确定，就可以使用值类型作为可选参数。<br>只有在默认值为null的时候，引用类型才可以用作可选参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int val;</span><br><span class="line">        val = Calc(1,2);</span><br><span class="line">        Console.WriteLine(val);</span><br><span class="line">    &#125;</span><br><span class="line">    static int Calc(int a, int b , int c = 4) &#123;</span><br><span class="line">        return (a+b) * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 参数 </tag>
            
            <tag> ref </tag>
            
            <tag> out </tag>
            
            <tag> params </tag>
            
            <tag> ref返回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数重载</title>
      <link href="/2023/08/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/08/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>当我们调用Console.WriteLine()函数时，我们有时候向这个函数传入整型数字，有时传入浮点数字，有时传入字符串。<br>为什么Console.WirteLine()函数可以接受不同的参数呢？<br>因为在C#语言中有着名为函数重载的功能。</p><h2 id="函数的签名"><a href="#函数的签名" class="headerlink" title="函数的签名"></a>函数的签名</h2><p>函数的签名包括：函数名，函数参数的种类、个数和顺序，还有它所在的类和名称空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">public void study(string name,int school)&#123;</span><br><span class="line">Console.WriteLine($&quot;我叫&#123;name&#125;，我在&#123;school&#125;读计算机专业。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！！！！！！方法的返回值不属于函数签名的一部分！！！！！！</p><h2 id="实现函数重载"><a href="#实现函数重载" class="headerlink" title="实现函数重载"></a>实现函数重载</h2><p>当函数的签名不同时，就可以实现函数的重载，我们可以声明多个同名函数保证他们的参数列表不同，在调用时传入想要执行的那个函数的参数，就可以做到实现不同的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public void study(string name, string school) &#123;</span><br><span class="line">        Console.WriteLine($&quot;我叫&#123;name&#125;，我在&#123;school&#125;读计算机专业。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void study(string name ,int age,string school) &#123;</span><br><span class="line">        Console.WriteLine($&quot;我叫&#123;name&#125;，我今年&#123;age&#125;岁了，我在&#123;school&#125;读幼儿园&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的构造函数也是函数，所以依然可以使用构造函数重载，实现对类成员不同方式的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解类</title>
      <link href="/2023/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB/"/>
      <url>/2023/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类与类成员"><a href="#类与类成员" class="headerlink" title="类与类成员"></a>类与类成员</h1><p>C#类访问限制：</p><p>public class可以被任意程序集所见、internal class仅能被自身程序集所见、static class常用来封装静态属性方法和扩展方法。</p><p>C#类的成员分为：</p><p>静态成员：字段、常量。</p><p>函数成员：属性、方法、索引器、事件、运算符、构造函数、析构函数。</p><p>C#成员访问限制：</p><p>public、static（静态）、private（仅限当前类内）、internal（仅限当前程序集）、protected（仅限当前类与该类的子类）</p><p>非静态成员就是函数成员。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>只用成员既有get又有set时才允许使用访问修饰符。<br>虽然两个访问器都必须出现但他们中只能有一个有访问修饰符。<br>访问器的修饰符限制必须比成员访问级别更严格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.age = -10;</span><br><span class="line">        Console.WriteLine(student.age);// 1</span><br><span class="line">        student.age = 10;</span><br><span class="line">        Console.WriteLine(student.age);// 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private int _age=1;</span><br><span class="line">    public int age &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return _age;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if(value &gt; 0 &amp;&amp; value &lt; 150) &#123;</span><br><span class="line">                _age = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public string name &#123; get; private set; &#125;//自动实现属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.Eat();//实例方法</span><br><span class="line">        Student.Study();//静态方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    public static void Study() &#123;</span><br><span class="line">        Console.WriteLine(&quot;I can study&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;I can eat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数必须和类名相同，且不能有返回值（连void都没有）。静态构造函数用static声明，类只能有有一个静态构造函数且不能带参数，静态构造函数不能有访问修饰符。<br>静态构造函数不能访问所在类的实例成员，因此不能使用this访问器，不能显式调用静态构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public static string school&#123; get; set; &#125;</span><br><span class="line">    public Student(string name) &#123; //构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    static Student() &#123;//静态构造函数</span><br><span class="line">        school = &quot;清北大学&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象初始化语句"><a href="#对象初始化语句" class="headerlink" title="对象初始化语句"></a>对象初始化语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student std = new Student() &#123; name = &quot;张三&quot; &#125;;</span><br><span class="line">Student std - new Student &#123; name = &quot;张三&quot; &#125;;</span><br></pre></td></tr></table></figure><p>注意静态字段和属性不能通过该方式初始化。</p><h2 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h2><p>const修饰符用于字段声明时，const字段使用方式和静态字段一样，几遍没有实例依然可以使用。<br>如果是static字段，初始化必须在静态构造函数中完成。<br>const字段相当于C&#x2F;C++中的#define，它在内存中没有存储位置</p><h2 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h2><p>const只能在字段声明中初始化，const的行为总是静态的。readonly字段可以使实例字段，也可以是静态字段，它在内存中有存储位置。<br>readonly允许在不同环境或不同构造函数中设置不同的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    public const string School = &quot;山河大学&quot;;</span><br><span class="line">    public readonly string Principal;//未初始化</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        this.Principal = &quot;刘校长&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.Principal = &quot;高校长&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会好奇为什么会有两个构造函数，别担心，我会在之后的章节中介绍的函数重载详细说明。</p><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>索引器可以帮助我们以自己想要的方式调用和读取类的成员，索引器不用分配内存在这点索引器和属性的原理一样，不过属性用来表示单个数据成员而索引器用来表示多个成员。<br>索引的是一组get和set访问器。<br>索引器的参数列表在方括号中间，至少声明一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student[0] = &quot;学号:2002220115&quot;;</span><br><span class="line">        student[1] = &quot;姓名:张三&quot;;</span><br><span class="line">        Console.WriteLine(student[0]);</span><br><span class="line">        Console.WriteLine(student[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">    public string this[int i] &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            switch(i) &#123;</span><br><span class="line">                case 0:return id; </span><br><span class="line">                case 1:return name;</span><br><span class="line">                default: return &quot;请在0-1中选择索引&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case 0: id = value;break;</span><br><span class="line">                case 1: name = value;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器重载"><a href="#索引器重载" class="headerlink" title="索引器重载"></a>索引器重载</h2><p>只要索引器的参数列表不同（返回值不同是不够的），类就可以有多个索引器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">public string this[int index]&#123;</span><br><span class="line">get&#123;...&#125;</span><br><span class="line">set&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">public string this[int index1 , int index2]&#123;</span><br><span class="line">get&#123;...&#125;</span><br><span class="line">set&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分部类与分部方法（partial-class）"><a href="#分部类与分部方法（partial-class）" class="headerlink" title="分部类与分部方法（partial class）"></a>分部类与分部方法（partial class）</h2><p>分部类：<br>类的声明可以分割成几个分部类的声明。<br>每个分部类的声明都含有一些类成员的声明。<br>类的分部类声明可以在同一文件中也可以在不同文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">&#125;</span><br><span class="line">partial class Student &#123;</span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分部方法：<br>方法的不同部分可以声明在分部类的不同部分中。<br>声明的实现部分只是一个分号，在实现部分以语句块方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partial class Student &#123;</span><br><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">    public void study(int x);//定义分部方法</span><br><span class="line">&#125;</span><br><span class="line">partial class Student &#123;</span><br><span class="line">    public int age;</span><br><span class="line">    public void study(int x)&#123;//实现分部方法</span><br><span class="line">Console.WriteLine(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 类 </tag>
            
            <tag> 属性 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态构造函数 </tag>
            
            <tag> 索引器 </tag>
            
            <tag> const </tag>
            
            <tag> readonly </tag>
            
            <tag> 分部类 </tag>
            
            <tag> 分部方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>从今天开始我就要开始写自己的博客了，我会在博客中记录并分享我在学习C#、前端开发、单片机、数据库或其他课程中遇到的问题和解决方案还有一些课堂笔记，如果有遇到同样问题或者想学习以上技术的小伙伴，希望我的博客可以帮助到你们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;%s&quot;,&quot;欢迎来到我的博客&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/%E6%99%BA%E5%95%86+1.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
