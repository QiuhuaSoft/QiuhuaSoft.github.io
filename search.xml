<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>配置系统</title>
      <link href="/2023/09/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JSON配置"><a href="#一、JSON配置" class="headerlink" title="一、JSON配置"></a>一、JSON配置</h1><p>.Net配置系统支持丰富的配置源包括文件、注册表、环境变量、命令行、Azure Key Vault等，还可以配置自定义配置源。可以跟踪配置的改变，可以按照优先级覆盖。<br>安装Microsoft.Extensions.Configuration（配置框架的包）和Microsoft.Extensions.Configuration.Json（读json的包）<br>新建json文件，设置属性如果较新就赋值。<br>config.json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;18&quot;,</span><br><span class="line">  &quot;proxy&quot;: &#123;&quot;address&quot;: &quot;aa&quot;,&quot;port&quot;: &quot;8080&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、原始使用方式"><a href="#1、原始使用方式" class="headerlink" title="1、原始使用方式"></a>1、原始使用方式</h2><p>AddJsonFile()命名参数介绍<br>optional表示文件是否可选<br>reloadOnChange参数表示如果文件修改了，是否重新加载设置（可以不重启就加载）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">            configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">            IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">            //原始方式</span><br><span class="line">            string name = configurationRoot[&quot;name&quot;];</span><br><span class="line">            string address = configurationRoot.GetSection(&quot;proxy:address&quot;).Value;</span><br><span class="line">            Console.WriteLine($&quot;name = &#123;name&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;address = &#123;address&#125;&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="2、绑定对象方式"><a href="#2、绑定对象方式" class="headerlink" title="2、绑定对象方式"></a>2、绑定对象方式</h2><p>安装Microsoft.Extensions.Configuration.Binder<br>有自动类型转换，自定义的类的属性名应与配置文件中的键名一致（拼写一致就行，不区分大小写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">            configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">            IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">            //绑定对象方式</span><br><span class="line">            Proxy proxy = configurationRoot.GetSection(&quot;proxy&quot;).Get&lt;Proxy&gt;();</span><br><span class="line">            Console.WriteLine($&quot;&#123;proxy.Address&#125;:&#123;proxy.Port&#125;&quot;);</span><br><span class="line">            Config config = configurationRoot.Get&lt;Config&gt;();</span><br><span class="line">            Console.WriteLine($&quot;&#123;config.Name&#125;,&#123;config.Age&#125;,&#123;config.Proxy.Address&#125;,&#123;config.Proxy.Port&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Config &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public string Age &#123; get; set; &#125;</span><br><span class="line">        public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Proxy &#123;</span><br><span class="line">        public string Address &#123; get; set; &#125;</span><br><span class="line">        public int Port &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3、依赖注入方式（更推荐）"><a href="#3、依赖注入方式（更推荐）" class="headerlink" title="3、依赖注入方式（更推荐）"></a>3、依赖注入方式（更推荐）</h2><p>安装：<br>Microsoft.Extensions.Configuration.Binder<br>Microsoft.Extensions.Configuration<br>Microsoft.Extensions.Configuration.Json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           ServiceCollection services = new ServiceCollection();</span><br><span class="line">           services.AddScoped&lt;TestController&gt;();</span><br><span class="line">           services.AddScoped&lt;Test2&gt;();</span><br><span class="line"> </span><br><span class="line">           ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">           configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">           IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line"></span><br><span class="line">           services.AddOptions()</span><br><span class="line">               .Configure&lt;Config&gt;(e =&gt; configurationRoot.Bind(e))</span><br><span class="line">               .Configure&lt;Proxy&gt;(e=&gt; configurationRoot.GetSection(&quot;proxy&quot;).Bind(e));//DI将根节点绑定到Config对象上</span><br><span class="line"></span><br><span class="line">           using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               //因为我们使用了IOptionSnapshot，所以修改文件时不会改变，相当于在一个大scope中</span><br><span class="line">               while (true) &#123;</span><br><span class="line">                   //如果想改变时获取新的数据，可以手动新建scope</span><br><span class="line">                   using(var scope = sp.CreateScope()) &#123;</span><br><span class="line">                       var c = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                       c.Test();</span><br><span class="line">                       Console.WriteLine(&quot;改一下age&quot;);</span><br><span class="line">                       Console.ReadLine();</span><br><span class="line">                       c.Test();</span><br><span class="line">                       var c2 = scope.ServiceProvider.GetRequiredService&lt;Test2&gt;();</span><br><span class="line">                       c2.Test();</span><br><span class="line">                   &#125;</span><br><span class="line">                   Console.WriteLine(&quot;点击任意键继续&quot;);</span><br><span class="line">                   Console.ReadLine();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Config &#123;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">       public string Age &#123; get; set; &#125;</span><br><span class="line">       public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Proxy &#123;</span><br><span class="line">       public string Address &#123; get; set; &#125;</span><br><span class="line">       public int Port &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class TestController &#123;</span><br><span class="line">       public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">       public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">           this.optConfig = optConfig;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(this.optConfig.Value.Age);</span><br><span class="line">           Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class Test2 &#123;</span><br><span class="line">       private readonly IOptionsSnapshot&lt;Proxy&gt; optProxy;</span><br><span class="line">       public Test2(IOptionsSnapshot&lt;Proxy&gt; optProxy) &#123;</span><br><span class="line">           this.optProxy = optProxy;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(optProxy.Value.Address);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="二、命令行配置"><a href="#二、命令行配置" class="headerlink" title="二、命令行配置"></a>二、命令行配置</h1><h2 id="命令行简单配置："><a href="#命令行简单配置：" class="headerlink" title="命令行简单配置："></a>命令行简单配置：</h2><p>安装Microsoft.Extensions.Configuration.CommandLine<br>支持 server &#x3D; 127.0.0.1、–server&#x3D;127.0.0.1、 –server 127.0.0.1等，注意在键值之间加空格，格式不能混用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddScoped&lt;TestController&gt;();</span><br><span class="line">            services.AddScoped&lt;Test2&gt;();</span><br><span class="line">            ConfigurationBuilder configBuder = new ConfigurationBuilder();</span><br><span class="line">            configBuder.AddCommandLine(args);//推荐传这个</span><br><span class="line">            IConfigurationRoot configRoot = configBuder.Build();</span><br><span class="line">            services.AddOptions()</span><br><span class="line">                .Configure&lt;Config&gt;(e =&gt; configRoot.Bind(e))</span><br><span class="line">                .Configure&lt;Proxy&gt;(e =&gt; configRoot.GetSection(&quot;Proxy&quot;));</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                while(true) &#123;</span><br><span class="line">                    using(var scope = sp.CreateScope()) &#123;</span><br><span class="line">                        var c1 = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                        var c2 = scope.ServiceProvider.GetRequiredService&lt;Test2&gt;();</span><br><span class="line">                        c1.Test();</span><br><span class="line">                        c2.Test();</span><br><span class="line">                        Console.ReadLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Config &#123;</span><br><span class="line">            public string Name &#123; get; set; &#125;</span><br><span class="line">            public int Age &#123; get; set; &#125;</span><br><span class="line">            public Proxy proxy &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public class Proxy &#123;</span><br><span class="line">            public string Address &#123; get; set; &#125;</span><br><span class="line">            public int Port &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以这样运行：<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/1.jpg"><br>或者使用vs右键项目-&gt;属性-&gt;调试-&gt;启动配置文件：<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/2.jpg"><br>如果要写入多重结构的配置，需要进行扁平化处理</p><h2 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h2>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 配置系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元检测</title>
      <link href="/2023/09/04/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/"/>
      <url>/2023/09/04/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h2><p>当我们要查看某个方法是否有错误，我们可以创建一个专门用来测试的类，用于不调用主程序的情况下，在测试类中检测方法是否符合所期待的那样。这样的行为称为单元检测或单元测试。</p><h2 id="单元检测演示"><a href="#单元检测演示" class="headerlink" title="单元检测演示"></a>单元检测演示</h2><p>一台电脑如果想玩3A游戏的话当然需要一个好的显卡，能玩游戏的显卡就是好显卡，我们可以使用单元检测来判断。<br>主程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            IGraphicsCard card = new NVIDIA();</span><br><span class="line">            Console.WriteLine(card.Show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface IGraphicsCard &#123;</span><br><span class="line">        string Show();</span><br><span class="line">    &#125;</span><br><span class="line">    public class NVIDIA:IGraphicsCard &#123; </span><br><span class="line">        public string Show() &#123;</span><br><span class="line">            return &quot;正在玩原神&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class AMD:IGraphicsCard &#123; </span><br><span class="line">        public string Show() &#123;</span><br><span class="line">            return &quot;正在玩星穹铁道&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元检测程序：<br>请先创建单元测试项目<br><img src="/images/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using Test;//引用主程序名称空间</span><br><span class="line">namespace GraphicsCardTest &#123;</span><br><span class="line">    public class GraphicsCardTest &#123;//测试类</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test1() &#123;//测试方法</span><br><span class="line">            var gc = new NVIDIA();</span><br><span class="line">            var expected = &quot;正在玩原神&quot;;//如果NVIDIA显卡能玩原神则成功</span><br><span class="line">            var actual = gc.Show();</span><br><span class="line">            Assert.Equal(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test2() &#123;//测试方法</span><br><span class="line">            var gc = new AMD();</span><br><span class="line">            var expected = &quot;正在玩星穹铁道&quot;;//如果AMD显卡能玩星穹铁道则成功</span><br><span class="line">            var actual = gc.Show();</span><br><span class="line">            Assert.Equal(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="/images/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 单元检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2023/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>依赖注入的原理是——反射<br>如果想用依赖注入框架需要：<br>先用NuGet下载Microsoft.Extensions.DependencyInjection。<br>使用名称空间using Microsoft.Extensions.DependencyInjection;</p><h1 id="依赖注入框架的简单使用"><a href="#依赖注入框架的简单使用" class="headerlink" title="依赖注入框架的简单使用"></a>依赖注入框架的简单使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var sc = new ServiceCollection();//创建容器</span><br><span class="line">            sc.AddScoped(typeof(IStudent),typeof(Student));//接口描述，绑定该接口的类型的描述</span><br><span class="line">            var sp = sc.BuildServiceProvider();</span><br><span class="line">            // ==============================以下不再有new操作符</span><br><span class="line">            IStudent student = sp.GetService&lt;IStudent&gt;();</span><br><span class="line">            student.Study();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStudent &#123;</span><br><span class="line">        void Study();</span><br><span class="line">    &#125;</span><br><span class="line">    class Student : IStudent &#123;</span><br><span class="line">        public void Study() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我要学习&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 依赖注入的几个概念<br> 服务：就是你需要的对象；<br> 注册服务：对象不能凭空出现，需要先注册；<br> 服务容器：负责管理注册的服务<br> 查询服务：创建对象及关联对象；<br> 对象生命周期：Transient（瞬态）、Scoped（范围内单例）、Singleton（单例）；<br> 可以指定服务类型和实现类型，或者服务类型和实现类型是同一类型<br> 服务类型尽量用接口<br> 微软的控制反转组件（DependencyInjection）包含服务定位器和依赖反转</p><h1 id="服务定位器的写法"><a href="#服务定位器的写法" class="headerlink" title="服务定位器的写法"></a>服务定位器的写法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            //1、创建容器</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //2、注册服务</span><br><span class="line">            services.AddTransient&lt;TestServiceImp1&gt;();</span><br><span class="line">            //3、创建服务提供者（相当于服务定位器）</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //4、从提供者获取服务</span><br><span class="line">                TestServiceImp1 t1 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t1.Name = &quot;Test1&quot;;</span><br><span class="line">                t1.SayHi();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public void SayHi();</span><br><span class="line">    &#125;</span><br><span class="line">    public class TestServiceImp1 : ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public void SayHi() &#123;</span><br><span class="line">            Console.WriteLine(&quot;hi&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class TestServiceImp2 : ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public void SayHi() &#123;</span><br><span class="line">            Console.WriteLine(&quot;你好&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="瞬时模式与单例模式Transient、Singleton"><a href="#瞬时模式与单例模式Transient、Singleton" class="headerlink" title="瞬时模式与单例模式Transient、Singleton"></a>瞬时模式与单例模式Transient、Singleton</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //Transient</span><br><span class="line">            //services.AddTransient&lt;TestServiceImp1&gt;();</span><br><span class="line">            //Singleton</span><br><span class="line">            //services.AddSingleton&lt;TestServiceImp1&gt;();</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                TestServiceImp1 t1 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t1.Name = &quot;Test1&quot;;</span><br><span class="line">                TestServiceImp1 t2 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t2.Name = &quot;Test2&quot;;</span><br><span class="line">                Console.WriteLine(object.ReferenceEquals(t1, t2));//判断是否为同一对象</span><br><span class="line">                Console.WriteLine(t1.Name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="范围模式Scope"><a href="#范围模式Scope" class="headerlink" title="范围模式Scope"></a>范围模式Scope</h2><p>Scope<br>如果一个类实现了IDisposable接口，则离开作用域之后，容器会自动调用对象的Dispose方法<br>不要在长生命周期的对象中引用比它短的声明周期的对象<br>生命周期的选择：<br>如果类无状态（无属性，无成员变量），建议为Singleton；如果类有状态，且有Scope控制，建议为Scoped，因为通常这种Scope控制下的代码都是运行在同一线程中，没有并发修改的问题；使用Transient要谨慎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //Scoped</span><br><span class="line">            services.AddScoped&lt;TestServiceImp1&gt;();</span><br><span class="line">            //老大sp</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //老大创造了小弟scope1</span><br><span class="line">                //创建范围，这个范围就是using的代码块</span><br><span class="line">                using (IServiceScope scope1 = sp.CreateScope()) &#123;</span><br><span class="line">                    //在scope中获取Scope相关的对象，scope1.ServiceProvider而不是sp</span><br><span class="line">                    //想获取服务不能直接问老大要，应该问小弟scope1要</span><br><span class="line">                    TestServiceImp1 t1 = scope1.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    TestServiceImp1 t2 = scope1.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    Console.WriteLine(object.ReferenceEquals(t1, t2));</span><br><span class="line">                &#125;</span><br><span class="line">                //老大创造小弟scope2</span><br><span class="line">                //创建范围，这个范围就是using的代码块</span><br><span class="line">                using (IServiceScope scope2 = sp.CreateScope()) &#123;</span><br><span class="line">                    //在scope中获取Scope相关的对象，scope1.ServiceProvider而不是sp</span><br><span class="line">                    //想获取服务不能直接问老大要，应该问小弟scope2要</span><br><span class="line">                    TestServiceImp1 t1 = scope2.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    TestServiceImp1 t2 = scope2.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    Console.WriteLine(object.ReferenceEquals(t1, t2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h2><p>当服务类型与实现类型不一致时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //泛型方法</span><br><span class="line">            services.AddScoped&lt;ITestService, TestServiceImp1&gt;();</span><br><span class="line">            services.AddScoped&lt;ITestService, TestServiceImp2&gt;();</span><br><span class="line">            //非泛型方法</span><br><span class="line">            //services.AddScoped(typeof(ITestService),typeof(TestServiceImp1));</span><br><span class="line">            //自定义单例对象</span><br><span class="line">            //services.AddSingleton(typeof(ITestService),new TestServiceImp1());</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //获取服务时，&lt;&gt;里面是注册类型而不是实现类型</span><br><span class="line">                //如果找不到服务就返回null</span><br><span class="line">                ITestService ts1 = sp.GetService&lt;ITestService&gt;();</span><br><span class="line">                //如果找不到直接抛异常而不是返回null</span><br><span class="line">                //ITestService ts1 = sp.GetRequiredService&lt;ITestService&gt;();</span><br><span class="line">                //非泛型方法，返回object，使用时需要手动转换</span><br><span class="line">                //ITestService ts1 = (ITestService)sp.GetService(typeof(ITestService));</span><br><span class="line">                //一个注册类型对应多个实现类型时，可以获取全部</span><br><span class="line">                //如果不用GetServices而用GetService就以最后一个添加进来的为准</span><br><span class="line">                IEnumerable&lt;ITestService&gt; tests = sp.GetServices&lt;ITestService&gt;();</span><br><span class="line">                foreach (ITestService test in tests) &#123;</span><br><span class="line">                    Console.WriteLine(test.GetType());</span><br><span class="line">                &#125;</span><br><span class="line">                ts1.Name = &quot;Test1&quot;;</span><br><span class="line">                ts1.SayHi();</span><br><span class="line">                Console.WriteLine(ts1.GetType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="依赖注入写法"><a href="#依赖注入写法" class="headerlink" title="依赖注入写法"></a>依赖注入写法</h1><p>依赖注入是有传染性的，如果一个类的对象是通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值；但如果一个对象是程序员手动创建的，那么这个类就和DI没有关系，它的构造函数中声明的服务类型参数就不会被自动赋值。<br>.Net的DI默认是构造函数注入<br>你只管声明，其余交给DI<br>降低模块之间的耦合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //日志服务或者配置服务需要替换只需要在这里更改就行了</span><br><span class="line">            services.AddScoped&lt;Controller&gt;();</span><br><span class="line">            services.AddScoped&lt;ILog, LogImp1&gt;();</span><br><span class="line">            services.AddScoped&lt;IStorage, StorageImp1&gt;();</span><br><span class="line">            //如果从本地读取配置</span><br><span class="line">            //services.AddScoped&lt;IConfig, ConfigImp1&gt;();</span><br><span class="line">            //如果从数据库读取配置</span><br><span class="line">            services.AddScoped&lt;IConfig, DbConfig&gt;();</span><br><span class="line">            using(var sp =  services.BuildServiceProvider()) &#123;</span><br><span class="line">                var c = sp.GetRequiredService&lt;Controller&gt;();</span><br><span class="line">                c.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Controller &#123;</span><br><span class="line">        private readonly ILog log;</span><br><span class="line">        private readonly IStorage storage;</span><br><span class="line">        public Controller(ILog log, IStorage storage) &#123;</span><br><span class="line">            this.log = log;</span><br><span class="line">            this.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Test() &#123;</span><br><span class="line">            this.log.Log(&quot;开始上传&quot;);</span><br><span class="line">            this.storage.Save(&quot;asdfa&quot;, &quot;1.txt&quot;);</span><br><span class="line">            this.log.Log(&quot;上传完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface ILog &#123;</span><br><span class="line">        public void Log(string msg);</span><br><span class="line">    &#125;</span><br><span class="line">    class LogImp1 : ILog &#123;</span><br><span class="line">        public void Log(string msg) &#123;</span><br><span class="line">            Console.WriteLine($&quot;日志：&#123;msg&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IConfig &#123;</span><br><span class="line">        public string GetValue(string name);</span><br><span class="line">    &#125;</span><br><span class="line">    class ConfigImp1 : IConfig &#123;</span><br><span class="line">        public string GetValue(string name) &#123;</span><br><span class="line">            return &quot;SqlServer&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStorage &#123;</span><br><span class="line">        public void Save(string content,string name);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果从本地配置文件读取配置</span><br><span class="line">    class StorageImp1 : IStorage &#123;</span><br><span class="line">        private readonly IConfig config;</span><br><span class="line">        public StorageImp1(IConfig config) &#123;</span><br><span class="line">            this.config = config;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Save(string content, string name) &#123;</span><br><span class="line">            string server = config.GetValue(&quot;server&quot;);</span><br><span class="line">            Console.WriteLine($&quot;向服务器&#123;server&#125;的文件名为&#123;name&#125;上传&#123;content&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果从数据库读取配置</span><br><span class="line">    class DbConfig : IConfig &#123;</span><br><span class="line">        public string GetValue(string name) &#123;</span><br><span class="line">            return &quot;MySql&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/09/04/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/09/04/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>对某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。<br>有关程序及其类型的数据称为元数据，被保存在程序的程序集中。<br>程序在运行时，可以查看其他程序集或本身的元数据。这种行为叫做反射。<br>使用反射要使用System.Reflection命名空间。</p><h2 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h2><p>blc声明了一个Type抽象类，用来包含类型的特征，使用这个类的对象能获取程序使用的类型信息。<br>Type类成员<br><img src="/images/%E5%8F%8D%E5%B0%84/1.jpg"></p><h2 id="获取Type对象"><a href="#获取Type对象" class="headerlink" title="获取Type对象"></a>获取Type对象</h2><p>实例对象的GetType()方法和typeof()运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           Student std = new Student();</span><br><span class="line">           Type type1 = std.GetType();</span><br><span class="line">           Type type2 = typeof(Student);</span><br><span class="line">           Type type3 = typeof(int);</span><br><span class="line">           Console.WriteLine(type1.Name);</span><br><span class="line">           Console.WriteLine(type1.Namespace);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Student &#123;</span><br><span class="line">       public int Id &#123; get; set; &#125;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            IStudent std = new Student();</span><br><span class="line">            Type s = std.GetType();//获取类型信息</span><br><span class="line">            object o = Activator.CreateInstance(s);//通过获取的类型信息创建object类型实例</span><br><span class="line">            MethodInfo stuMi = s.GetMethod(&quot;Study&quot;);//获取该类型的Study方法</span><br><span class="line">            stuMi.Invoke(o, null);//在指定对象上调用该方法，第二个参数是参数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStudent &#123;</span><br><span class="line">        int Id &#123; get; set; &#125;</span><br><span class="line">        string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Student : IStudent &#123;</span><br><span class="line">        public int Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public void Study() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我要学习&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="插件程序的开发"><a href="#插件程序的开发" class="headerlink" title="插件程序的开发"></a>插件程序的开发</h2><p>主体程序：<br>请先在程序目录下创建Animals文件夹，该文件用来存放插件，请将插件生成的dll放在该文件夹中，主体程序会遍历文件夹中的dll，从dll中通过反射获取类库的中所有具有Voice方法的类型信息，存放在animaTypes中，最后通过反射调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.Loader;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(Environment.CurrentDirectory);//请在该路径下创建Animals文件夹</span><br><span class="line">            var floder = Path.Combine(Environment.CurrentDirectory, &quot;Animals&quot;);</span><br><span class="line">            var files = Directory.GetFiles(floder);</span><br><span class="line">            var animalTypes = new List&lt;Type&gt;();</span><br><span class="line">            foreach (var file in files) &#123;</span><br><span class="line">                var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(file);</span><br><span class="line">                var types = assembly.GetTypes();</span><br><span class="line">                foreach (var t in types) &#123;</span><br><span class="line">                    if(t.GetMethod(&quot;Voice&quot;)!=null) &#123;</span><br><span class="line">                        animalTypes.Add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (true) &#123;</span><br><span class="line">                for(int i = 0; i&lt; animalTypes.Count; i++) &#123;</span><br><span class="line">                    Console.WriteLine($&quot;&#123;i+1&#125;,&#123;animalTypes[i].Name&#125;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;====================&quot;);</span><br><span class="line">                Console.WriteLine(&quot;Please choose animal&quot;);</span><br><span class="line">                int index = int.Parse(Console.ReadLine());</span><br><span class="line">                if(index&gt;animalTypes.Count || index&lt;1) &#123;</span><br><span class="line">                    Console.WriteLine(&quot;No such an animal.Try again!&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;How many times?&quot;);</span><br><span class="line">                int times = int.Parse(Console.ReadLine());</span><br><span class="line">                var t = animalTypes[index-1];</span><br><span class="line">                var m = t.GetMethod(&quot;Voice&quot;);</span><br><span class="line">                var o = Activator.CreateInstance(t);</span><br><span class="line">                m.Invoke(o, new object[] &#123; times &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace Animals &#123;</span><br><span class="line">    public class Cat &#123;</span><br><span class="line">        public void Voice(int times) &#123;</span><br><span class="line">            for(int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">                Console.WriteLine(&quot;喵&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 反射 </tag>
            
            <tag> Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程</title>
      <link href="/2023/08/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/08/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h2><p>默认情况下一个进程只包含一个线程。<br>线程可以派生其他线程，因此在任意时刻，一个进程可能包含不同状态的多个线程，它们执行程序的不同部分。<br>如果一个进程拥有多个线程，它们将共享进程的资源。<br>系统为处理器执行所调度的单元是线程，不是进程。</p><h2 id="异步编程演示"><a href="#异步编程演示" class="headerlink" title="异步编程演示"></a>异步编程演示</h2><p>异步获取百度的html然后异步写入test.txt文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            string str = await client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            string fileName = @&quot;F:\test.txt&quot;;</span><br><span class="line">            await File.WriteAllTextAsync(fileName,str);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方法在其完成所有工作之前就返回到调用方法。<br>主函数调用异步方法，然后主函数在异步方法执行时继续执行（可能在相同的线程也可能在不同的线程）<br>async：声明这种方法是异步的。<br>await：在异步方法内等待。</p><h2 id="异步方法的注意点"><a href="#异步方法的注意点" class="headerlink" title="异步方法的注意点"></a>异步方法的注意点</h2><p>异步方法头中用async修饰符，即使返回结果为空也应该将结果声明为Task.<br>异步方法包含一个或多个await。<br>异步方法必须返回void、Task、Task&lt;T&gt;、ValueTask&lt;T&gt;的其中之一。<br>异步方法应具有公开可访问的GetAwaiter方法类型。<br>异步方法名称一般以Async为后缀。<br>Lambda表达式和匿名方法也可以作为异步对象。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await操作符帮我们提供异步等待，并且可以将Task&lt;T&gt;所封装的真实值取出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            //不用await帮忙，我就要自己取</span><br><span class="line">            Task&lt;string&gt; str1 = client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            await Console.Out.WriteLineAsync(str1.Result);</span><br><span class="line">            //await帮我取值</span><br><span class="line">            string str2 = await client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            await Console.Out.WriteLineAsync(str2);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>await表达式制订了一个异步执行的任务，这个任务可能是Task也可能不是，默认情况下这个任务在当前线程上异步运行。<br>一个空闲对象既是一个awaitable类型的实例，awaitable类型是指包含GetAwaiter方法的类型，该方法没有参数，返回一个awaiter类型的对象。awaiter类型包含以下成员：<br>bool IsCompleted{get}<br>void OnCompleted(Action);<br>还包含以下成员之一：<br>void GetResult();<br>T GetResult();<br>实际上，你不需要构建自己的awaitable，相反，你应该使用Task或ValueTask类，它们是awaitable类型</p><h2 id="Task-Run"><a href="#Task-Run" class="headerlink" title="Task.Run"></a>Task.Run</h2><p>异步方法不等于多线程，异步方法的代码并不会自动在新线程中执行，除非把代码放到新线程中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            await Repeat(100);</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; Repeat(int times) &#123;</span><br><span class="line">            int i = 0;</span><br><span class="line">            for(int j = 0; j &lt; times; j++) &#123;</span><br><span class="line">                i = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Task.Run()方法可以创建一个Task，并且在不同线程上运行你的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            await Repeat(100);</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; Repeat(int times) &#123;</span><br><span class="line">            return await Task.Run(() =&gt; &#123;</span><br><span class="line">                int i = 0;</span><br><span class="line">                for (int j = 0; j &lt; times; j++) &#123;</span><br><span class="line">                    i = i + j;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">                return i;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它接受一个委托，委托类型可以是：<br><img src="/images/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/1.jpg"></p><h2 id="为什么有些异步方法没标async"><a href="#为什么有些异步方法没标async" class="headerlink" title="为什么有些异步方法没标async"></a>为什么有些异步方法没标async</h2><p>如果不需要传递异步结果，不需要包装成Task，就没必要async，在哪await都是await。<br>这样写对优化有帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string str = await GetBaidu();</span><br><span class="line">            await Console.Out.WriteLineAsync(str);</span><br><span class="line">        &#125;</span><br><span class="line">        static  Task&lt;string&gt; GetBaidu() &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            return client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="取消异步操作CancellationToken和CancellationTokenSource"><a href="#取消异步操作CancellationToken和CancellationTokenSource" class="headerlink" title="取消异步操作CancellationToken和CancellationTokenSource"></a>取消异步操作CancellationToken和CancellationTokenSource</h2><p>位于System.Threading.Tasks名称空间下。<br>很多异步方法都有CancellationToken参数用于获得提前终止执行的信号。<br>CancellationToken是一个结构体，它包含着一个任务是否应被取消的信息。<br>拥有CancellationToken对象的任务应定期检查其令牌状态也就是IsCancellationRequested属性是否为true，任务需停止其操作并返回。<br>CancellationToken是不可逆的只能使用一次。<br>CancellationTokenSource对象创建可分配给不同任务的CancellationToken对象。任何持有CancellationTokenSource的对象都可以调用其Cancel方法，这会将CancellationToken的IsCancellationRequested设置为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();</span><br><span class="line">            CancellationToken token = cancellationTokenSource.Token;</span><br><span class="line">            cancellationTokenSource.CancelAfter(3000);</span><br><span class="line">            Task&lt;int&gt; res = GetBaidu(token);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (Console.ReadLine() != &quot;p&quot;) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                cancellationTokenSource.Cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; GetBaidu(CancellationToken token) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            for(int i = 0; i &lt; 65533; i++) &#123;</span><br><span class="line">                if(token.IsCancellationRequested) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(&quot;请求被取消&quot;);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                string str = await client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">                await Console.Out.WriteLineAsync(str);</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="同步等待任务"><a href="#同步等待任务" class="headerlink" title="同步等待任务"></a>同步等待任务</h2><p>可以使用task对象的Wait()方法在调用方法中同步等待：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            t.Wait();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Task.WaitAll()静态方法用于等待一组任务都完成<br>Task.WaitAny()静态方法用于等待一组任务中的某一个完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t1 = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            Task t2 = File.ReadAllTextAsync(@&quot;F:\test.txt&quot;);</span><br><span class="line">            //Task.WaitAll(t1, t2);</span><br><span class="line">            Task.WaitAny(t1, t2);</span><br><span class="line">            Console.WriteLine($&quot;t1是否完成:&#123;t1.IsCompleted&#125;,t2是否完成&#123;t2.IsCompleted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们的重载还有：<br><img src="/images/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/2.jpg"></p><h2 id="在异步方法中异步等待"><a href="#在异步方法中异步等待" class="headerlink" title="在异步方法中异步等待"></a>在异步方法中异步等待</h2><p>有时在异步方法中，你会希望用await表达式来等待Task，这时异步方法会返回调用方法，但该异步方法会等待一个或所有任务完成。可以通过Task.WhenAll()和Task.WhenAny()来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            await Test();</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task Test() &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t1 = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            Task t2 = File.ReadAllTextAsync(@&quot;F:\test.txt&quot;);</span><br><span class="line">            //await Task.WhenAll(t1, t2);</span><br><span class="line">            await Task.WhenAny(t1, t2);</span><br><span class="line">            await Console.Out.WriteLineAsync($&quot;t1是否完成:&#123;t1.IsCompleted&#125;,t2是否完成&#123;t2.IsCompleted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Delay"><a href="#Task-Delay" class="headerlink" title="Task.Delay"></a>Task.Delay</h2><p>该方法创建Task对象，将对象暂停在其线程中，一定时间后再完成，该方法不会阻塞主线程.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Delay(3000);</span><br></pre></td></tr></table></figure><h2 id="GUI程序中的异步"><a href="#GUI程序中的异步" class="headerlink" title="GUI程序中的异步"></a>GUI程序中的异步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void Button_Click(object sender, RoutedEventArgs e) &#123;</span><br><span class="line">            this.input.Text = &quot;Watting&quot;;</span><br><span class="line">            this.btn.IsEnabled = false;</span><br><span class="line">            Thread.Sleep(4000);</span><br><span class="line">            this.input.Text = &quot;没有任务&quot;;</span><br><span class="line">            this.btn.IsEnabled = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在wpf中当点击按钮，文本框文字没有改变，按钮也没有被禁用，但是页面卡住了三秒，期间无法拖动也无法进行其他活动。<br>原因是GUI需要处理很多事情，当点击按钮时，按钮的Click被放入消息队列，消息泵从队列中移除该消息并开始执行事件处理函数。事件处理函数将改变文本框文字、禁用按钮、移动窗体、改变文本框文字、启用按钮放入消息泵，消息泵还未刷新页面时，被Thread.Sleep()阻塞了主线程，当三秒之后再处理消息泵的内容，但是这一切发生的太快。<br>将上述代码修改如下即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private async void Button_Click(object sender, RoutedEventArgs e) &#123;</span><br><span class="line">            this.input.Text = &quot;Watting&quot;;</span><br><span class="line">            this.btn.IsEnabled = false;</span><br><span class="line">            await Task.Delay(4000);        </span><br><span class="line">            this.input.Text = &quot;没有任务&quot;;</span><br><span class="line">            this.btn.IsEnabled = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Yield"><a href="#Task-Yield" class="headerlink" title="Task.Yield"></a>Task.Yield</h2><p>该方法创建一个立即返回的awaitable。等待一个Yield可以让异步方法在执行后续部分的同时返回到调用方法，可以将其理解成李凯当前的消息队列、回到队伍末尾、让处理器有时间处理其他任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Task&lt;int&gt; value = DoStuff.FindSeriesSum(100000);</span><br><span class="line">            CountBig(100000); CountBig(100000);</span><br><span class="line">            CountBig(100000); CountBig(100000);</span><br><span class="line">            Console.WriteLine($&quot;Sum:&#123;value.Result&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        private static void CountBig(int value) &#123;</span><br><span class="line">            for (int i = 0; i &lt; value; i++) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class DoStuff &#123;</span><br><span class="line">        public static async Task&lt;int&gt;FindSeriesSum(int i1) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for(int i = 0; i &lt; i1; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                if(i%1000 ==0)await Task.Yield();</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Yield方法在GUI程序中非常有用，可以中断大量工作，让其他任务使用处理器。</p><h2 id="异步Lambda表达式"><a href="#异步Lambda表达式" class="headerlink" title="异步Lambda表达式"></a>异步Lambda表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button.Click+=async(sender,e)=&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 异步编程 </tag>
            
            <tag> async </tag>
            
            <tag> await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINQ</title>
      <link href="/2023/08/30/LINQ/"/>
      <url>/2023/08/30/LINQ/</url>
      
        <content type="html"><![CDATA[<p>Linq表示语言集成查询，它是.Net框架的扩展，允许我们以使用sql查询数据库的类似方法来查询集合。<br>Linq的查询语法有方法语法和查询语法。方法语法是命令式的，查询语法是声明式的。<br>位于System.Linq名称空间。<br>Linq查询可以返回两种类型的结果——可以是一个枚举，它是满足查询参数的项列表；也可以是一个叫标量的单一值，它是满足查询条件的结果的某种摘要形式。</p><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>学习Linq之前，让我们先来认识一下匿名类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var student = new &#123;</span><br><span class="line">                age = 18,</span><br><span class="line">                name = &quot;张三&quot;,</span><br><span class="line">                major = &quot;数字电路&quot;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>匿名类型的成员类型由编译器推断，只需要在对象初始化语句中初始化即可。<br>注意事项：<br>匿名类型只能用于局部变量，不能用于类成员。<br>必须使用var作为变量类型。<br>编译器为匿名类型创建的属性是只读的。<br>可以使用投影初始化语句来初始化匿名对象（与JS一样）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            int age = 18;</span><br><span class="line">            string name = &quot;张三&quot;;</span><br><span class="line">            string major = &quot;数字电路&quot;;</span><br><span class="line">            var student = new &#123;</span><br><span class="line">                age, name, major</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果编译器遇到了另一个具有相同参数名，相同的推断类型和相同顺序的匿名类型对象初始化语句，它会重用这个类型并直接创建新的实例，不会创建新的匿名类型。</p><h2 id="查询语法（微软推荐，我不推荐）"><a href="#查询语法（微软推荐，我不推荐）" class="headerlink" title="查询语法（微软推荐，我不推荐）"></a>查询语法（微软推荐，我不推荐）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new List&lt;int&gt;() &#123; 1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">            var result = from n in list</span><br><span class="line">                         where n&gt;5</span><br><span class="line">                         select n;</span><br><span class="line">            foreach(var n in result) &#123;</span><br><span class="line">                Console.WriteLine(n);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>如果查询表达式返回枚举，则查询一直到处理枚举时才会执行。<br>如果枚举被处理多次，查询就会执行多次。<br>如果在进行遍历之后，查询执行之前数据有改动，则查询会使用新的数据。<br>如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。<br>查询表达式由from子句和查询主题组成。<br>子句必须按照一定的顺序出现。<br>from子句和select…group子句这两部分是必须的，其他子句是可选的。<br>select子句在表达式最后。<br>可以有任意多的from…let…where子句。</p><h2 id="from子句"><a href="#from子句" class="headerlink" title="from子句"></a>from子句</h2><p>指定要作为数据源使用的数据集合（必须是可枚举的），它还引入了迭代变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from n in list where n&gt;5 select n;</span><br><span class="line">from l1 in list1 from l2 in list2 where l1&lt;l2 select </span><br></pre></td></tr></table></figure><h2 id="join子句（联结）"><a href="#join子句（联结）" class="headerlink" title="join子句（联结）"></a>join子句（联结）</h2><p>接受两个集合，然后创建一个新的集合，其中每一个元素包含两个原始集合中的元素成员。<br>必须使用上下文关键字equals来比较字段，不能用&#x3D;&#x3D;运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var query = from s in students </span><br><span class="line">join c in studentsInCourses on s.StID equals c.StID</span><br></pre></td></tr></table></figure><h2 id="let子句"><a href="#let子句" class="headerlink" title="let子句"></a>let子句</h2><p>接受一个表达式的运算并把它赋值给一个需要在其他运算中使用的标识符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 3, 4, 5, 6 &#125;;</span><br><span class="line">            List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6,7,8,9 &#125;;</span><br><span class="line">            var res = from l1 in list1</span><br><span class="line">                      from l2 in list2</span><br><span class="line">                      let sum = l1+ l2</span><br><span class="line">                      where sum==12</span><br><span class="line">                      select new &#123; l1,l2,sum &#125;;</span><br><span class="line">            foreach(var a in res) &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><p>根据之后的运算来去除不符合指定条件的项</p><h2 id="orderby子句"><a href="#orderby子句" class="headerlink" title="orderby子句"></a>orderby子句</h2><p>接受一个表达式并根据表达式按顺序返回结果项。<br>可选ascending（升序）descending（降序），默认是升序<br>可以有任意多个子句，他们必须用逗号分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 16,8,146,95,3,24 &#125;;</span><br><span class="line">            var res = from l1 in list1</span><br><span class="line">                      orderby l1</span><br><span class="line">                      select l1;</span><br><span class="line">            foreach(var a in res) &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="select子句"><a href="#select子句" class="headerlink" title="select子句"></a>select子句</h2><p>select子句指定应该选择所选对象的哪些部分。<br>查询结果可以由原始集合的项，原始集合中项的字段或匿名类型组成。</p><h2 id="group子句"><a href="#group子句" class="headerlink" title="group子句"></a>group子句</h2><p>group…by是可选的，用来指定选择的项如何被分组。<br>如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组。作为字段分组依据的属性叫做键（key）<br>group子句返回的不是原始数据源中项的枚举，而是返回可以枚举已经形成的项的分组的可枚举类型。<br>分组本身是可枚举类型，他们可以枚举实际的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Student[] students = new Student[] &#123; </span><br><span class="line">            new Student()&#123;Lname = &quot;三&quot;,Fname = &quot;张&quot;, age = 18,Major = &quot;计算机网络&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;四&quot;,Fname = &quot;李&quot;, age = 18,Major = &quot;数据结构与算法&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;五&quot;,Fname = &quot;王&quot;, age = 18,Major = &quot;计算机网络&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;人甲&quot;,Fname = &quot;路&quot;, age = 18,Major = &quot;数据库原理&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;灰乙&quot;,Fname = &quot;炮&quot;, age = 18,Major = &quot;数据库原理&quot;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            var query = from student in students</span><br><span class="line">                        group student by student.Major;</span><br><span class="line">            foreach(var q in query) &#123;</span><br><span class="line">                Console.WriteLine(q.Key);</span><br><span class="line">                foreach(var s in q) &#123;</span><br><span class="line">                    Console.WriteLine(s.Fname+s.Lname+&quot;选修&quot;+s.Major);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Student &#123;</span><br><span class="line">        public string Lname &#123; get; set; &#125;</span><br><span class="line">        public string Fname &#123; get; set; &#125;</span><br><span class="line">        public string Major &#123; get; set; &#125;</span><br><span class="line">        public int age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每一个分组由一个叫做键的字段区分<br>每一个分组本身是可枚举类型并且可以枚举它的项。</p><h2 id="into语句"><a href="#into语句" class="headerlink" title="into语句"></a>into语句</h2><p>into语句是查询延续子句，可以接受查询一部分的结果并赋予一个名字，从而可以在查询的另一部分中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            var groupA = new[]&#123; 3, 4, 5, 6, &#125;;</span><br><span class="line">            var groupB = new[] &#123; 4,5,6,7 &#125;;</span><br><span class="line">            var res = from a in groupA</span><br><span class="line">                      join b in groupB on a equals b</span><br><span class="line">                      into groupAB</span><br><span class="line">                      from c in groupAB</span><br><span class="line">                      select c;</span><br><span class="line">            foreach(var r in res) &#123;</span><br><span class="line">                Console.WriteLine(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="方法语法（标准查询运算符）"><a href="#方法语法（标准查询运算符）" class="headerlink" title="方法语法（标准查询运算符）"></a>方法语法（标准查询运算符）</h2><p>标准查询运算符由一系列API方法组成，一些运算符返回IEnumerable对象（或其他序列），而其他运算符返回标量，返回标量的运算符立即执行查询，并返回一个值，而不是一个可枚举类型对象。ToArray()、ToList()等ToCollection运算符也会立即执行。<br>许多操作都以一个谓词作为参数，谓词是一个方法，它以对象为参数，根据对象是否满足某个条件返回true或false。<br>被查询的集合对象叫序列，它必须实现IEnumerable&lt;T&gt;接口，其中T是类型。<br><img src="/images/LINQ/1.jpg"><br><img src="/images/LINQ/2.jpg"><br><img src="/images/LINQ/3.jpg"><br>System.Linq.Enumerable类声明了标准查询运算符方法，然而这些方法不仅仅是普通方法，他们是拓展了IEnumerable&lt;T&gt;泛型类的扩展方法。</p><h2 id="常用标准查询运算符"><a href="#常用标准查询运算符" class="headerlink" title="常用标准查询运算符"></a>常用标准查询运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var group = new[] &#123;1,2,3,4,5,6,7,8,9,0 &#125;;</span><br><span class="line">            Student[] students = new Student[] &#123; </span><br><span class="line">                new Student()&#123;name = &quot;路人甲&quot;,age =18 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人乙&quot;,age =18 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人丙&quot;,age =19 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人丁&quot;,age =120 &#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">            var res1 = group.Where(e =&gt; e &gt; 6);</span><br><span class="line">            var res2 = group.Count(e=&gt;e&lt;5);</span><br><span class="line">            var res3 = group.Any(e=&gt;e&lt;0);</span><br><span class="line">            var res4 = group.Single(e=&gt;e==6);</span><br><span class="line">            var res5 = group.SingleOrDefault(e=&gt;e==7);</span><br><span class="line">            var res6 = group.First(e=&gt;e&gt;3);</span><br><span class="line">            var res7 = group.FirstOrDefault(e=&gt;e&gt;15);</span><br><span class="line">            var res8 = group.OrderBy(e=&gt;e);</span><br><span class="line">            var res9  = students.OrderBy(e=&gt;e.age);</span><br><span class="line">            var res10 = students.OrderByDescending(e=&gt;e.age);</span><br><span class="line">            var res11 = students.OrderBy(e =&gt; Guid.NewGuid());//随机排序</span><br><span class="line">            var res12 = students.OrderBy(e =&gt; e.age).ThenBy(e=&gt;e.name);</span><br><span class="line">            var res13 = students.OrderBy(e =&gt; e.age).ThenByDescending(e=&gt;e.name);</span><br><span class="line">            var res14 = group.Skip(2).Take(3);//跳过2条，取2条</span><br><span class="line">            var res15 = students.Max(e =&gt; e.age);</span><br><span class="line">            var res16 = students.Min(e =&gt; e.age);</span><br><span class="line">            var res17 = students.Average(e =&gt; e.age);</span><br><span class="line">            var res18 = students.Sum(e =&gt; e.age);</span><br><span class="line">            var res19 = students.Count();</span><br><span class="line">            var res20 = students.GroupBy(e =&gt; e.age);</span><br><span class="line">            var res21 = students.Select(e =&gt; e.age);</span><br><span class="line">            var res22 = students.ToList();</span><br><span class="line">            var res23 = students.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Student &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public int age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Linq </tag>
            
            <tag> 匿名类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举器与迭代器</title>
      <link href="/2023/08/30/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2023/08/30/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>为什么数组可以被foreach遍历呢？<br>原因是数组可以按需提供一个叫做枚举器的对象，枚举器可以依次返回请求数组中的元素，枚举器知道项的次序并且追踪它在序列中的位置，然后返回请求的当前项。<br>获取对象枚举器的方法是调用对象的GetEnumerator方法。实现GetEnumerator方法的类型叫做可枚举类型。</p><h2 id="IEnumerator接口"><a href="#IEnumerator接口" class="headerlink" title="IEnumerator接口"></a>IEnumerator接口</h2><p>位于System.Collections。<br>实现了IEnumerator接口的枚举器包含3个函数成员：Current、MoveNext以及Reset。<br>Current是返回序列中当前位置项的属性，它是只读的，它返回object类型的引用，我们必须把它转成实际类型的实例。<br>MoveNext是把枚举器位置前进到集合中下一项的方法。它也返回布尔值，指示新的位置是有效位置还是已经超过了序列的尾部，MoveNext必须在第一次使用Current之前调用。<br>Reset是把位置重置为原始状态的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//using System.Collections;</span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            int[] arr = &#123; 10, 11, 12, 13 &#125;;</span><br><span class="line">            IEnumerator ie = arr.GetEnumerator();</span><br><span class="line">            while (ie.MoveNext()) &#123;</span><br><span class="line">                int item = (int) ie.Current;</span><br><span class="line">                Console.WriteLine($&quot;Item value：&#123;item&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerable接口"><a href="#IEnumerable接口" class="headerlink" title="IEnumerable接口"></a>IEnumerable接口</h2><p>位于System.Collections。<br>可枚举类是实现了IEnumerable接口的类，IEnumerable只有一个成员——GetEnumerator方法，它返回对象的枚举器。<br>枚举器与迭代器完整写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Spectrum spectrum = new Spectrum();</span><br><span class="line">            foreach (var color in spectrum) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ColorEnumerator : IEnumerator &#123;</span><br><span class="line">        string[] colors;</span><br><span class="line">        int position = -1;</span><br><span class="line">        public ColorEnumerator(string[] theColors) &#123;</span><br><span class="line">            colors = new string[theColors.Length];</span><br><span class="line">            for(int i = 0;i &lt; theColors.Length; i++) &#123;</span><br><span class="line">                colors[i] = theColors[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public object Current &#123;</span><br><span class="line">            get &#123;</span><br><span class="line">                if(position == -1) &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                if(position&gt;= colors.Length) &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                return colors[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public bool MoveNext() &#123;</span><br><span class="line">            if(position&lt;colors.Length-1) &#123;</span><br><span class="line">                position++;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else &#123; return false; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Reset() &#123;</span><br><span class="line">            position = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Spectrum : IEnumerable &#123;</span><br><span class="line">        string[] Colors = &#123; &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yello&quot;, &quot;pink&quot; &#125;;</span><br><span class="line">        public IEnumerator GetEnumerator() &#123;</span><br><span class="line">            return new ColorEnumerator(Colors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>大多数情况下你应该使用泛型版本的IEnumerable&lt;T&gt;和IEnumerator&lt;T&gt;。<br>IEnumerable&lt;T&gt;接口的GetEnumerator方法返回实现IEnumator&lt;T&gt;的枚举器类的实例，这些接口是协变接口。<br>泛型接口的枚举器是类型安全的，它自动将返回结果转换成实际类型的引用。<br><img src="/images/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/1.jpg"></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器需要System.Collections.Generic名称空间。<br>从C#2.0开始提供了更简单的创建枚举器和可枚举类型的方式，这种结构称为迭代器，我们可以把手动编码的可枚举类型和枚举器替换为由迭代器生成的可枚举类型和枚举器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样的有迭代器产生的枚举器简化了很多代码。<br>迭代器块是有一个或多个yield语句的代码块。<br>迭代器块不是需要在同一时间执行的一串命令式命令，而是声明性的。<br>迭代器块有两个特殊的语句：<br>yield return 指定了序列中要返回的下一项。<br>yield break  指定在序列中没有其他项。<br>根据迭代器块的返回类型，可以让迭代器产生枚举器或可枚举类型<br>使用迭代器创建枚举器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">        public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">            return this.BlackAndWhite();</span><br><span class="line">        &#125;</span><br><span class="line">        public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用迭代器创建可枚举对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass mc = new MyClass();</span><br><span class="line">        foreach (string color in mc) &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass &#123;</span><br><span class="line">    public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">        return this.BlackAndWhite();</span><br><span class="line">    &#125;</span><br><span class="line">    public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">        yield return &quot;black&quot;;</span><br><span class="line">        yield return &quot;gray&quot;;</span><br><span class="line">        yield return &quot;white&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代器创建可枚举类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyClass mc = new MyClass();</span><br><span class="line">            foreach (string color in mc) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">            foreach (string color in mc.BlackAndWhite()) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyClass &#123;</span><br><span class="line">        public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">            return this.BlackAndWhite().GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line">        public IEnumerable&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><p>当我们实现返回枚举器的迭代器时，必须通过实现GetEnumerator来让类可枚举，它返回由迭代器返回的枚举器。<br>在类中实现返回可枚举类型的迭代器时，我们可以让类实现GetEnumerator来让类本身可枚举，或不实现让类不可枚举。<br>如果实现GetEnumerator，让它调用迭代器方法以获取自动生成的实现IEnumerable的类实例，然后从IEnumerable对象返回由GetEnumerator创建的枚举器。<br>如果不实现GetEnumerator使类本身不可枚举，仍然可以使用由迭代器返回的可枚举类，只需要直接调用迭代器方法。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> IEnumerator </tag>
            
            <tag> IEnumerable </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 枚举器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协变与逆变</title>
      <link href="/2023/08/30/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
      <url>/2023/08/30/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>大家通常会犯一个错误，就是将派生类型的委托分配给基类型委托的变量，下面来看这个主题叫做可变性，它分为三种——协变、逆变、不变。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p>如果类型参数只用做输出值与构造委托有效性之间的常数关系叫做协变。<br>你也许知道，你可以将派生类型的对象赋值给基类型的变量，这称作类型兼容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Factory&lt;Cat&gt; catMaker = MakeCat;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = catMaker;//报错</span><br><span class="line">    &#125;</span><br><span class="line">    static Cat MakeCat() &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        return cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate T Factory&lt;T&gt;();</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public int NumberOfLegs = 4;</span><br><span class="line">&#125;</span><br><span class="line">class Cat:Animal &#123; &#125;</span><br></pre></td></tr></table></figure><p>出现以上问题的原因很简单，Cat虽然是Animal的子类，但是Factory&lt;Cat&gt;不是Factory&lt;Animal&gt;的子类，必然无法赋值。<br>如果我们想用这样的赋值，就需要告诉编译器我要使用协变。<br>使用协变的前提：类型参数只用做输出值与构造委托有效性之间的常数关系，必须使用out关键字标记委托声明中的类型参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate T Factory&lt;out T&gt;();</span><br></pre></td></tr></table></figure><p>可能会觉得协变的定义很难懂，接下来我来解释一下什么叫输出值。<br>输出值就是返回值，上面的MakeCat函数的返回值是一个Cat类型的对象，Factory&lt;Animal&gt;接收一个Animal类型的返回值，用Animal来接受返回值为Cat的对象，并声明成out协变保证这个派生类对象只用来当做函数返回值，这样当然没问题。</p><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p>逆变用于在期望传入基类时允许传入派生类对象的特性称作逆变。<br>如果上面的函数变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = MakeAnimal;</span><br><span class="line">        Factory&lt;Cat&gt; CatMaker = animalMaker;</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeAnimal(Animal animal) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void Factory&lt; T &gt;(T t);</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public int NumberOfLegs = 4;</span><br><span class="line">&#125;</span><br><span class="line">class Cat:Animal &#123; &#125;</span><br></pre></td></tr></table></figure><p>这次我们用一个MakeAnimal函数接受一个Animal类或其派生类的对象，当我们传入了Cat时，虽然Cat是Animal的派生类，但是Factory&lt;Cat&gt;与Factory&lt;Animal&gt;平级，所以不能直接赋值。<br>如果就想这样做，就需要告诉编译器我要使用逆变。使用协变的前提：类型参数只用做输入值与构造委托有效性之间的常数关系，必须使用in关键字标记委托声明中的类型参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate T Factory&lt;in T&gt;();</span><br></pre></td></tr></table></figure><p>MakeAnimal函数接受一个animal的对象，我们传入了animal的派生类对象并声明成in逆变保证这个派生类对象只用来当做函数传参，这样做当然没问题</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>可变性处理的是可以使用基类型替换派生类型的安全情况，反之亦然。因此可变性只适用于引用类型。</p><p>in和out关键字的显式变化只适用于委托和接口，不适用于类、结构、方法。</p><p>不包括in和out关键字的委托和接口类型参数是不变的。这些类型参数不能用于协变或逆变。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 可变性 </tag>
            
            <tag> 协变 </tag>
            
            <tag> 逆变 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2023/08/29/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/08/29/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>大家有没有觉得一个类的成员类型或者一个方法的返回值类型和参数类型一旦写好就不太方便修改，如果一个经常使用的类，它的某个成员类型有时候需要int，有时候需要string，我们需要不停的修改这个类，或者声明一个与其名字相似但成员类型不同的新的类，这样做非常麻烦。<br>另外还有一个函数，它的参数类型有时候需要int，有时候需要double，虽然我们可以进行函数重载，但代码挺多的。<br>为了解决上述问题，提供了新的解决方案——泛型。<br>我们可以使用“类型占位符”书写代码，然后在创建类的实例时知名真实的类型。<br>泛型类型不是类型，而是类型的模板。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            MyClass&lt;int, double&gt; myClass = new MyClass&lt;int, double&gt;() &#123; Value1 = 12 ,Value2 = new double[] &#123; 1,2,3&#125; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class MyClass&lt;T1 , T2&gt; &#123;</span><br><span class="line">        public T1 Value1 &#123; get; set; &#125;</span><br><span class="line">        public T2[] Value2;</span><br><span class="line">        public void Fun1(T1 x) &#123; ... &#125;</span><br><span class="line">        public T2 Fun2() &#123; ...&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码，如果我们想要修改MyClass类成员的类型，只需要在声明时修改&lt;&gt;内的内容，也就是类型参数就行。<br>泛型的声明有点长可以使用var进行简化。</p><h2 id="类型参数的约束（where）"><a href="#类型参数的约束（where）" class="headerlink" title="类型参数的约束（where）"></a>类型参数的约束（where）</h2><p>由于泛型栈不知道它们保存的项的类型是什么，所以也就不会知道这些类型实现的成员。<br>栈可以确认的是，这些保存的项都实现了object类的成员，包括ToString、Equals、以及GetType方法，除此之外，它不知道还有哪些成员可用。<br>为了让泛型变得更有用，我们需要提供额外的信息让编译器知道参数可以接受哪种类型，这样的信息称为约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass&lt;int, double[]&gt; myClass = new MyClass&lt;int, double[]&gt;() &#123; Value1 = 12 ,Value2 = new double[] &#123; 1,2,3&#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass&lt;T1 , T2&gt;where T1: struct </span><br><span class="line">                             where T2 : class, IEnumerable&lt;double&gt; &#123;</span><br><span class="line">    public T1 Value1 &#123; get; set; &#125;</span><br><span class="line">    public T2 Value2;</span><br><span class="line">    public void Fun1(T1 x) &#123;</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">    &#125;</span><br><span class="line">    public T2 Fun2() &#123;</span><br><span class="line">        return Value2 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约束类型：</p><table><thead><tr><th>约束类型</th><th>描述</th></tr></thead><tbody><tr><td>类名</td><td>只有这个类型的类或从它派生的类才能用作类型实参</td></tr><tr><td>class</td><td>任何引用类型，包括类、数组、委托和接口都可以用作类型实参</td></tr><tr><td>struct</td><td>任何值类型都可以用作类型实参</td></tr><tr><td>接口名</td><td>只有这个接口或实现这个接口的类型才能用作类型实参</td></tr><tr><td>new()</td><td>任何具有无参公共构造函数的类型都可以用作类型实参</td></tr><tr><td>where子句可以以任何次序列出，但是where字句中的约束必须有特定的顺序：</td><td></td></tr><tr><td>最多只能有一个主约束，而且必须放在第一位。</td><td></td></tr><tr><td>可以有任意多的接口名称约束。</td><td></td></tr><tr><td>如果存在构造函数约束，则必须放在最后。</td><td></td></tr><tr><td>主约束</td><td>次约束</td></tr><tr><td>–</td><td>–</td></tr><tr><td>ClassName</td><td>InterfaceName</td></tr><tr><td>class</td><td></td></tr><tr><td>struct</td><td></td></tr></tbody></table><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var intArray = new int[] &#123; 3, 5, 7, 9, 11 &#125;;</span><br><span class="line">            var stringArray = new string[] &#123; &quot;first&quot;, &quot;second&quot;, &quot;third&quot; &#125;;</span><br><span class="line">            Simple.ReverseAndPrint&lt;int&gt;(intArray);</span><br><span class="line">            Simple.ReverseAndPrint(stringArray);//自动推断</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple &#123;</span><br><span class="line">        static public void ReverseAndPrint&lt;T&gt;(T[] arr) &#123;</span><br><span class="line">            Array.Reverse(arr);</span><br><span class="line">            foreach (var item in arr) &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译器可以帮我们从方法参数的类型中推断出应用作为泛型方法的类型参数的类型，简化调用时书写的代码。</p><h2 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct&lt;T1,T2&gt; &#123;</span><br><span class="line">            public T1 Value1;</span><br><span class="line">            public T2 Value2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyDel&lt;int&gt; del = func;</span><br><span class="line">            del.Invoke(0);</span><br><span class="line">        &#125;</span><br><span class="line">        static void func(int i) &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate void MyDel&lt;T&gt;(T t);</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>如果一个类实现了泛型接口，那么这个类本身也是泛型的。<br>如果一个类实现了特化之后的泛型接口，那么这个类就不再是泛型类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Simple&lt;string&gt; simple = new Simple&lt;string&gt;();</span><br><span class="line">            Simple&lt;int&gt; int1 = new Simple&lt;int&gt;();</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(&quot;hello world&quot;));</span><br><span class="line">            Console.WriteLine(int1.ReturnIt(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IMyIf&lt;T&gt; &#123;</span><br><span class="line">        T  ReturnIt( T inValue);</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple&lt;S&gt; : IMyIf&lt;S&gt; &#123;</span><br><span class="line">        public S ReturnIt(S inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用不同类型参数实例化的泛型接口的实例是不同的接口。<br>我们可以在非泛型类型中实现泛型接口。<br>必须实现每一个接口的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Simple simple = new Simple();</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(&quot;hello world&quot;));</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IMyIf&lt;T&gt; &#123;</span><br><span class="line">        T  ReturnIt( T inValue);</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple : IMyIf&lt;int&gt;, IMyIf&lt;string&gt; &#123;</span><br><span class="line">        public int ReturnIt(int inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public string ReturnIt(string inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。<br>泛型接口的名字不会与非泛型冲突。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 泛型 </tag>
            
            <tag> 泛型约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/08/29/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/08/29/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么我们需要接口"><a href="#为什么我们需要接口" class="headerlink" title="为什么我们需要接口"></a>为什么我们需要接口</h2><p>接口是指定一组函数成员而不实现它们的引用类型，只有类和结构可以实现接口。<br>接口是抽象类的进一步抽象。<br>可以很好的帮助我们解决类的耦合。<br>接下来我会一步步推出来为什么要使用接口。</p><h2 id="抽象类解耦"><a href="#抽象类解耦" class="headerlink" title="抽象类解耦"></a>抽象类解耦</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            HuaWei huaWei = new HuaWei();</span><br><span class="line">            Man man = new Man();</span><br><span class="line">            man.huaWei = huaWei;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Man &#123;</span><br><span class="line">        public HuaWei huaWei &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class HuaWei &#123;</span><br><span class="line">        public void Call() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个代码表示一个人拿了一部华为手机，当这个人想换成小米手机的时候，就不得不修改成一下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        XiaoMi xiaoMi = new XiaoMi();</span><br><span class="line">        Man man = new Man();</span><br><span class="line">        man.xiaoMi = xiaoMi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man &#123;</span><br><span class="line">    public XiaoMi xiaoMi &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class XiaoMi &#123; </span><br><span class="line">    public void Call() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现一个问题，这个人可能会换很多部不同的手机，难道我们每次都要重写Man类就为了让这个人打电话吗？当然不可能，所以我们想了一个方法，用抽象类封装一下，再通过多态来实现不就可以了吗：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">      static void Main(string[] args) &#123;</span><br><span class="line">          Man man = new Man();</span><br><span class="line">          Phone phone = new XiaoMi();</span><br><span class="line">          phone.Call();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Man &#123;</span><br><span class="line">      public Phone phone &#123; get; set; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract class Phone &#123;</span><br><span class="line">      public abstract void Call();</span><br><span class="line">  &#125;</span><br><span class="line">  class XiaoMi:Phone &#123; </span><br><span class="line">      override public void Call() &#123;</span><br><span class="line">          Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class HuaWei:Phone &#123;</span><br><span class="line">      override public void Call() &#123;</span><br><span class="line">          Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就好多了，这下我们只需要每次给man换手机就行了，Call方法给每个手机厂商自己实现就行了。</p><h2 id="接口解耦"><a href="#接口解耦" class="headerlink" title="接口解耦"></a>接口解耦</h2><p>当我们声明一个抽象类的时候，我们必须要写非常多的public abstract 用来声明抽象方法，还必须在子类中写好多override，况且随着手机的功能越来越多，手机可以当游戏机，可以当手电筒，可以当记事本，难道我们要在Phone中加入不属于手机初衷的功能吗？这样一点都不优雅，有没有优雅一点的办法？<br>有！就是使用接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           Man man = new Man();</span><br><span class="line">           IPhone phone = new XiaoMi();</span><br><span class="line">           phone.Call();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Man &#123;</span><br><span class="line">       public IPhone phone &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   interface IPhone &#123;</span><br><span class="line">       void Call();</span><br><span class="line">   &#125;</span><br><span class="line">   class XiaoMi:IPhone &#123; </span><br><span class="line">       public void Call() &#123;</span><br><span class="line">           Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class HuaWei:IPhone &#123;</span><br><span class="line">       public void Call() &#123;</span><br><span class="line">           Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>interface声明接口，接口内的成员隐式都是public abstract的所以无需再写也不能写了。还可以看到在实现接口的类中不用再写override了，优雅太优雅了。</p><h2 id="声明接口的注意事项"><a href="#声明接口的注意事项" class="headerlink" title="声明接口的注意事项"></a>声明接口的注意事项</h2><p>接口成员不能是数据成员或静态成员<br>接口声明只能包含如下类型非静态成员函数声明：<br>方法<br>属性<br>事件<br>索引器<br>接口成员的声明不能包含任何实现代码，必须用分号代替每一个成员声明的主体。<br>按照惯例接口名称应以大写I开始。<br>接口声明可以分隔成分部接口声明。<br>接口声明可以有任何访问修饰符，但是接口成员都是隐式public的，不允许有任何修饰符包括public。<br>接口不能实例化，只能用来声明变量，但不能调用不属于这个接口成员的类成员。<br>接口可以继承一个或多个接口</p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>类和结构可以实现接口，而且可以实现多个接口。<br>实现接口的类或结构需要在基类列表中包含接口名称基类在前接口在后，必须为每一个接口成员提供实现。<br>如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。<br>实现接口的类可以从它的基类继承实现的代码。</p><h2 id="显式接口成员实现"><a href="#显式接口成员实现" class="headerlink" title="显式接口成员实现"></a>显式接口成员实现</h2><p>使用限定接口名称来声明，由接口名称和成员名称以及它们中间的点分隔号构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        IKiller man1 = new Man();</span><br><span class="line">        man1.Kill();</span><br><span class="line">        IGoodMan man2 = new Man();</span><br><span class="line">        man2.Smile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface IKiller &#123;</span><br><span class="line">    void Kill();</span><br><span class="line">&#125;</span><br><span class="line">interface IGoodMan &#123;</span><br><span class="line">    void Smile();</span><br><span class="line">&#125;</span><br><span class="line">class Man : IKiller, IGoodMan &#123;</span><br><span class="line">     void IKiller.Kill() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我是个杀手&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     void IGoodMan.Smile() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我是个好人&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式实现接口成员的函数不应该有访问修饰符，因为其是隐式public的。<br>显式接口成员实现只可以通过指向接口的引用来访问，其他的类成员都不可以直接访问他们。<br>由于其他类成员不能直接访问显式接口成员的实现，派生类的成员也不能直接访问他们，他们必须总是通过接口的引用来访问。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数</title>
      <link href="/2023/08/29/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2023/08/29/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>匿名方法是在实例化委托是内联声明的方法。</p><h2 id="匿名函数使用位置"><a href="#匿名函数使用位置" class="headerlink" title="匿名函数使用位置"></a>匿名函数使用位置</h2><p>声明委托变量时作为初始化表达式</p><p>组合委托时在赋值语句的右边</p><p>为委托增加事件时在赋值语句的右边</p><h2 id="匿名函数语法"><a href="#匿名函数语法" class="headerlink" title="匿名函数语法"></a>匿名函数语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyDel del = delegate (string str) &#123;</span><br><span class="line">                Console.WriteLine(str);</span><br><span class="line">            &#125;;</span><br><span class="line">            del();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate void MyDel(string str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数不会显式声明返回值，但是实现代码必须通过返回一个与委托的返回值相同的值来匹配委托的返回类型。<br>当委托的参数列表不包含out参数并且匿名方法不适用任何参数时可以省略括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = delegate &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>如果委托声明的参数列表包含了params参数，那么匿名方法的参数列表将忽略params关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">delegate void MyDel(int x,params int[] ints);</span><br><span class="line">//声明</span><br><span class="line">MyDel del = delegate (int x, int[]ints) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>匿名方法可以访问他们外围作用域的局部变量和环境。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>匿名函数几乎被Lambda表达式替代了。<br>其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = (int x , int[] ints) =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>编译器可以从委托的声明中知道委托参数的类型，因此Lambda表达式语序省略类型参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = (x , ints) =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>如果只有一个参数就可以省略两端的圆括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = x =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>Lambda表达式允许表达式的主题是语句块或表达式。如果语句块包含了一个返回语句，我们可以将语句块替换为return关键字后的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = x  =&gt; x*10;</span><br></pre></td></tr></table></figure><p>是不是觉得这样的语法超级简洁</p><h2 id="Lambda表达式参数列表注意事项"><a href="#Lambda表达式参数列表注意事项" class="headerlink" title="Lambda表达式参数列表注意事项"></a>Lambda表达式参数列表注意事项</h2><p>表达式的参数列表不一定需要包含类型，除非委托有ref或out参数。<br>如果只有一个参数且这个参数是隐式类型则可以省略圆括号，否则必须有括号。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2023/08/29/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/08/29/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>事件是类的成员，是使对象或类具有通知能力的成员。<br>事件的组成：发布者、订阅者、事件处理程序、触发事件。<br>事件订阅本质上是一种以委托类型为基础的约定。</p><h2 id="事件相关的说明"><a href="#事件相关的说明" class="headerlink" title="事件相关的说明"></a>事件相关的说明</h2><p>事件包含了一个私有的委托，但是你无法直接访问委托。<br>事件中可用的操作比委托少，我们只能添加、删除或调用事件处理程序。<br>事件被触发时，它调用委托来一次调用调用列表中的方法。<br>+&#x3D;、-&#x3D;是事件唯一允许的操作。<br>委托类型声明：事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。<br>事件处理程序声明：订阅者类中会在事件触发时执行的方法声明。他们不一定是显示命名的方法，还可以是Lambda表达式或匿名方法。<br>事件声明：订阅者必须注册事件才能在事件被触发时得到通知。这是将事件处理程序与事件相连的代码。<br>触发事件的代码：发布者类中“触发”事件并导致调用注册的所有事件处理程序的代码。</p><h2 id="创建发布者类"><a href="#创建发布者类" class="headerlink" title="创建发布者类"></a>创建发布者类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件委托"><a href="#声明事件委托" class="headerlink" title="声明事件委托"></a>声明事件委托</h2><p>订阅者的事件处理程序需要满足该委托。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">public delegate void ClickEventHandle(Button sender, ClickEventArgs e);//定义委托类型 Button：触发事件的对象ClickEventArgs：事件附带的信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件附带信息"><a href="#声明事件附带信息" class="headerlink" title="声明事件附带信息"></a>声明事件附带信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">            public int Width &#123; get; private set; &#125;</span><br><span class="line">            public int Height &#123; get; private set; &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="将触发事件时应执行的函数存放于发布者类的事件委托中"><a href="#将触发事件时应执行的函数存放于发布者类的事件委托中" class="headerlink" title="将触发事件时应执行的函数存放于发布者类的事件委托中"></a>将触发事件时应执行的函数存放于发布者类的事件委托中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">public ClickEventHandle Event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><p>发布者类必须提供事件对象，这需要委托类型和名称。<br>事件是类的成员，并且必须声明为public，这样其他类和结构才可以在它上面注册事件处理程序。<br>不能用new来创建该事件的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        public event ClickEventHandle Click &#123;</span><br><span class="line">        //add添加事件处理程序，remove移除事件处理程序，value外部传入的事件处理程序</span><br><span class="line">            add &#123;</span><br><span class="line">                this.Event += value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove &#123;</span><br><span class="line">                this.Event -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//event：关键字 ClickEventHandler：委托类型 Click：事件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布者触发事件"><a href="#发布者触发事件" class="headerlink" title="发布者触发事件"></a>发布者触发事件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Event != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Event.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建订阅者类并编写事件处理程序"><a href="#创建订阅者类并编写事件处理程序" class="headerlink" title="创建订阅者类并编写事件处理程序"></a>创建订阅者类并编写事件处理程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;//绑定事件处理程序</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(Button sender, ClickEventArgs e) &#123;//事件处理程序</span><br><span class="line">            Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">            Console.WriteLine($&quot;按钮名：&#123;e.Name&#125;，按钮宽度：&#123;e.Width&#125;，按钮高度：&#123;e.Height&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="事件的完整写法"><a href="#事件的完整写法" class="headerlink" title="事件的完整写法"></a>事件的完整写法</h2><p>假设有一个按钮和一个屏幕，三秒后按钮自动按下，屏幕收到按钮按下的事件，在屏幕上显示按钮的信息。<br>结合上面讲述的内容，构成事件的完整写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Button button = new Button();</span><br><span class="line">            Screen screen = new Screen(button);</span><br><span class="line">            await button.Button_Click();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">        public int Width &#123; get; set; &#125;</span><br><span class="line">        public int Height &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(Button sender, ClickEventArgs e) &#123;//事件处理程序</span><br><span class="line">            Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">            Console.WriteLine($&quot;按钮名：&#123;e.Name&#125;，按钮宽度：&#123;e.Width&#125;，按钮高度：&#123;e.Height&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Button &#123;</span><br><span class="line">        public ClickEventHandle Event;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">        public delegate void ClickEventHandle(Button sender, ClickEventArgs e);//定义委托类型 Button：触发事件的对象ClickEventArgs：事件附带的信息</span><br><span class="line">        public event ClickEventHandle Click &#123;</span><br><span class="line">            add &#123;</span><br><span class="line">                this.Event += value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove &#123;</span><br><span class="line">                this.Event -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//event：关键字 ClickEventHandler：委托类型 Click：事件名</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Event != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Event.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件的简单写法"><a href="#事件的简单写法" class="headerlink" title="事件的简单写法"></a>事件的简单写法</h2><p>对于事件的使用.Net提供了一个标准模式，该标准模式的基础就是System名称空间中声明的EventHandler委托类型。<br>在之后声明事件就不需要自己定义事件委托类型了。<br>EventHandler委托需要注意以下几点：<br>第一个参数用来保存触发事件的对象的引用，由于它是object类型的，所以可以匹配任何类型的实例。<br>第二个参数用来保存状态信息，指明什么类型适用于该应用程序。<br>返回类型是void。<br>EventHandler的第二个参数是EventArgs类的对象，它声明在System名称空间中，但是EventArgs不能传递任何数据，它用于不需要传递数据的事件处理程序，通常会被忽略。如果你希望传递数据，必须声明一个派生自EventArgs的类，并使用合适的字段来保存需要传递的数据。<br>事件访问器add和remove可以省路，事件名同时担任事件委托和事件名两个职责，可以简单理解成public event EventHandler Click;声明了一个委托类型成员（但其实不是）<br>了解了上述的概念，我们就可以简化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">using System;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Button button = new Button();</span><br><span class="line">            Screen screen = new Screen(button);</span><br><span class="line">            await button.Button_Click();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">        public int Width &#123; get; set; &#125;</span><br><span class="line">        public int Height &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(object? sender, EventArgs e) &#123;//事件处理程序</span><br><span class="line">            ClickEventArgs ClickArg = e as ClickEventArgs;</span><br><span class="line">            if (ClickArg != null) &#123;</span><br><span class="line">                Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">                Console.WriteLine($&quot;按钮名：&#123;ClickArg.Name&#125;，按钮宽度：&#123;ClickArg.Width&#125;，按钮高度：&#123;ClickArg.Height&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Button &#123;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">        public event EventHandler Click;</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Click != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Click.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托</title>
      <link href="/2023/08/29/%E5%A7%94%E6%89%98/"/>
      <url>/2023/08/29/%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>可以认为委托是持有一个或多个方法的对象，但委托与对象不同，可以执行委托，这时委托会执行它所持有的方法。<br>如果学过C&#x2F;C++可以将委托理解成函数指针的升级版。</p><h2 id="初识委托"><a href="#初识委托" class="headerlink" title="初识委托"></a>初识委托</h2><p>委托与类平级，所以一般声明在类声明的位置，委托的访问性默认是internal。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyDel del = new MyDel(SayHello);</span><br><span class="line">        del.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;Hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate int MyDel(int i);</span><br></pre></td></tr></table></figure><p>创建委托实例时，可以传入实例方法或者静态方法的方法名。</p><h2 id="初始化委托"><a href="#初始化委托" class="headerlink" title="初始化委托"></a>初始化委托</h2><p>我们已经见到了new的赋值方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = new MyDel(Ix10);</span><br></pre></td></tr></table></figure><p>也可以使用委托赋值的快捷方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = SayHello;</span><br></pre></td></tr></table></figure><h2 id="组合委托"><a href="#组合委托" class="headerlink" title="组合委托"></a>组合委托</h2><p>委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表连接了作为操作数的两个委托的调用列表副本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del1 = SayHello;</span><br><span class="line">MyDel del2 = Human.Eat;</span><br><span class="line">MyDel del3 = del1+del2;</span><br></pre></td></tr></table></figure><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>我们已经展示过了组合委托，通过+运算符可以将两个委托组合起来，+和+&#x3D;运算符还可以给委托增加方法到委托的调用队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyDel del = SayHello;</span><br><span class="line">        del += Human.Eat;</span><br><span class="line">        del = del +SayHello;</span><br><span class="line">        del();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void MyDel();</span><br><span class="line">public class Human &#123;</span><br><span class="line">    public static void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用+&#x3D;运算符时，实际上发生的是创建了一个新的委托，其调用列表是左边的委托加上右边方法的组合，然后将这个委托赋值给del。<br>由代码的执行结果来看，其调用顺序与添加方法的顺序相同。</p><h2 id="移除委托方法"><a href="#移除委托方法" class="headerlink" title="移除委托方法"></a>移除委托方法</h2><p>可以使用-和-&#x3D;运算符从委托移除方法 。<br>如果在调用列表中的方法有多个实例，-&#x3D;运算符将从列表最后开始搜索，并且移除第一个与方法匹配的实例。<br>试图删除委托中不存在的方法将无效。<br>试图调用空委托会抛出异常，可以通过将委托和null进行比较来判断委托的调用列表是否为空。如果为空则委托是null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        Action action = SayHello;</span><br><span class="line">        action += Human.Eat;</span><br><span class="line">        action = action + SayHello;</span><br><span class="line">        action = action - SayHello;</span><br><span class="line">        action -= Human.Eat;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void MyDel();</span><br><span class="line">public class Human &#123;</span><br><span class="line">    public static void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式异步调用多播委托"><a href="#显式异步调用多播委托" class="headerlink" title="显式异步调用多播委托"></a>显式异步调用多播委托</h2><p>多播委托默认是同步调用的，但我们可以使用Thread或Task显式异步调用。<br>Thread：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//using System.Threading;</span><br><span class="line">MyDel del = SayHello;</span><br><span class="line">del += Human.Eat;</span><br><span class="line">Thread thread = new Thread(new ThreadStart(del));//可以直接传入方法名或委托实例</span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure><p>Task：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">      Action action = SayHello;</span><br><span class="line">      action += Human.Eat;</span><br><span class="line">      Task task = new Task(action);</span><br><span class="line">      task.Start();</span><br><span class="line">      await Task.Delay(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步调用看不懂没关系，我会在异步编程中介绍的。Task之所以加了Delay是因为如果不await，代码会在执行Human.Eat或者SayHello之前退出。</p><h2 id="Action委托"><a href="#Action委托" class="headerlink" title="Action&lt;&gt;委托"></a>Action&lt;&gt;委托</h2><p>Action委托无需自己定义，由C#语言定义只需要使用即可。<br>Action委托是泛型委托用于无返回值的函数，泛型列表中是被委托函数的参数列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Action&lt;string&gt; action = Say;</span><br><span class="line">        action(&quot;你好世界&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void Say(string str) &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Func委托"><a href="#Func委托" class="headerlink" title="Func&lt;&gt;委托"></a>Func&lt;&gt;委托</h2><p>Func&lt;&gt;委托无需自己定义，由C#语言定义只需要使用即可。<br>Func&lt;&gt;委托是泛型委托用于有返回值的函数，泛型列表中最后一个是方法返回值类型，前几个是被委托函数的参数类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Func&lt;int, int, int&gt; func = new Func&lt;int, int, int&gt;(add);</span><br><span class="line">            int res = func(3,4);</span><br><span class="line">            Console.WriteLine(res);</span><br><span class="line">        &#125;</span><br><span class="line">        static int add(int a,int b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 委托 </tag>
            
            <tag> 多播委托 </tag>
            
            <tag> Action </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dictionary字典</title>
      <link href="/2023/08/28/Dictionary%E5%AD%97%E5%85%B8/"/>
      <url>/2023/08/28/Dictionary%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="字典（dictionary）的声明"><a href="#字典（dictionary）的声明" class="headerlink" title="字典（dictionary）的声明"></a>字典（dictionary）的声明</h2><p>声明字典时,需同时声明字典内的键和值的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br></pre></td></tr></table></figure><h2 id="字典的读取与增加"><a href="#字典的读取与增加" class="headerlink" title="字典的读取与增加"></a>字典的读取与增加</h2><p>键和值可以是任何类型，但键必须是唯一的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br><span class="line">        dic.Add(1, &quot;hi&quot;);</span><br><span class="line">        dic.Add(2, &quot;你好&quot;);</span><br><span class="line">        dic[3] = &quot;hello&quot;;</span><br><span class="line">        Console.WriteLine(dic[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int, string&gt; &#123;</span><br><span class="line">            &#123;1,&quot;hello world&quot; &#125;,</span><br><span class="line">            &#123;2,&quot;字典的基本用法&quot; &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h2 id="dic-Remove-key"><a href="#dic-Remove-key" class="headerlink" title="dic.Remove(key)"></a>dic.Remove(key)</h2><p>用于移除键对应的成员，返回bool，成功为true，失败为false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br><span class="line">        dic.Add(1, &quot;hi&quot;);</span><br><span class="line">        dic.Add(2, &quot;你好&quot;);</span><br><span class="line">        dic.Remove(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dictionary </tag>
            
            <tag> 字典 </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型List类</title>
      <link href="/2023/08/28/%E6%B3%9B%E5%9E%8BList%E7%B1%BB/"/>
      <url>/2023/08/28/%E6%B3%9B%E5%9E%8BList%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>泛型list的底层是动态数组，其容量可自动或手动调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        List&lt;int&gt; IntList = new List&lt;int&gt;();</span><br><span class="line">        IntList.Add(1);</span><br><span class="line">        IntList.Add(2);</span><br><span class="line">        IntList.Add(3);</span><br><span class="line">        Console.WriteLine(IntList.Count);//集合元素的数量</span><br><span class="line">        Console.WriteLine(IntList.Capacity);//底层数组长度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以向（）中传入一个整数来限制list的底层数组大小。</p><h2 id="List常用API"><a href="#List常用API" class="headerlink" title="List常用API"></a>List常用API</h2><p>list.Add(int value)     添加元素</p><p>list.AddRange(IEnumerable <code>&lt;int&gt;</code> list)      添加一组元素</p><p>list.Insert(int index,int value)            插入元素</p><p>list.InsertRange(int index,IEnumerable <code>&lt;int&gt;</code>list)         插入一组元素</p><p>list.Clear()           清空（底层数组长度不变）</p><p>list.Remove(int index)      移除</p><p>list.RemoveRange(int index,int length)      移除length个元素</p><p>list.RemoveAll(e&#x3D;&gt;e&#x3D;&#x3D;400)     接受一个返回值为bool的委托，移除满足条件的成员</p><p>list.GetRange(int index,int length)       返回一个List <code>&lt;int&gt;</code>类型的对象，包含被截取的成员</p><p>list.GetEnumerator()          返回List <code>&lt;int&gt;</code>类型对象的Enumerator迭代器，迭代器会在之后的篇章中介绍。</p><p>list.ForEach(e&#x3D;&gt;e*10)       遍历</p><p>list.Contain(100)           返回bool，检测一个值是否存在于list中</p><p>list.Exists(e&#x3D;&gt;e&gt;500))      返回bool，用来检测list中是否有满足条件的元素</p><p>list.TrueForAll(e&#x3D;&gt;e&lt;&#x3D;40)        返回bool，检测所有元素是否都满足要求</p><p>list.IndexOf(300)        返回第一个值为300的成员的索引，底层调用&#x3D;&#x3D;，没有则返回-1</p><p>list.IndexOf(value,index)         从index位置开始，往后找value所在的索引,index最大为list.Count,再大就报错了</p><p>list.IndexOf(value,startIndex,much)     从stratIndex位置开始，到其往后much个元素位置，查找是否有value，返回value的索引</p><p>list.Find(e&#x3D;&gt;e%3&#x3D;&#x3D;0)      返回第一个满足要求的值</p><p>list.FindLast(e&#x3D;&gt;e%4&#x3D;&#x3D;0)          返回最后一个满足要求的值</p><p>list.FindAll(e&#x3D;&gt;e%3&#x3D;&#x3D;0)         返回一个由满足要求的值组成的新集合</p><p>list.FindIndex(e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindIndex(index,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindIndex(index,much,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(index,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(index,much,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.BinarySearch(value)          在排好序的list中用二分查找value所在的位置</p><h2 id="list-Contain"><a href="#list-Contain" class="headerlink" title="list.Contain()"></a>list.Contain()</h2><p>其底层原理是&#x3D;&#x3D;，如果是引用类型则用Equals方法，自定义类型没有Equals方法需要覆写object的Equals方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        List&lt;Book&gt; list = new List&lt;Book&gt;();</span><br><span class="line">        Book book1 = new Book();</span><br><span class="line">        Book book2 = new Book();</span><br><span class="line">        book1.id = 1;</span><br><span class="line">        book2.id = 2;</span><br><span class="line">        list.Add(book1);</span><br><span class="line">        list.Add(book2);</span><br><span class="line">        Console.WriteLine(list.Contains(book1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book &#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public override bool Equals(object? obj) &#123;</span><br><span class="line">        if(obj ==null) return false;</span><br><span class="line">        Book other = obj as Book;</span><br><span class="line">        if(other == null) return false;</span><br><span class="line">        return this.id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list-Sort"><a href="#list-Sort" class="headerlink" title="list.Sort()"></a>list.Sort()</h2><p>其底层用CompareTo方法，引用类型没有CompareTo方法所以要自己写，要求该引用类型实现IComparable&lt;&gt;接口&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Book book1 = new Book();</span><br><span class="line">        Book book2 = new Book();</span><br><span class="line">        Book book3 = new Book();</span><br><span class="line">        book1.ID = 9;</span><br><span class="line">        book2.ID=4;</span><br><span class="line">        book3.ID=15;</span><br><span class="line">        List&lt;Book&gt; list = new List&lt;Book&gt;&#123; book1,book2,book3&#125;;</span><br><span class="line">        list.Sort();</span><br><span class="line">        foreach (Book book in list) &#123;</span><br><span class="line">            Console.WriteLine(book.ID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book:IComparable&lt;Book&gt; &#123;</span><br><span class="line">    public int ID &#123; get; set; &#125;</span><br><span class="line">    public int CompareTo(Book? obj) &#123;</span><br><span class="line">        if (obj == null) return 1;</span><br><span class="line">        return this.ID - obj.ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList类</title>
      <link href="/2023/08/28/ArrayList%E7%B1%BB/"/>
      <url>/2023/08/28/ArrayList%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList类在System.Collections名称空间中，ArrayList存放的是object类型成员。<br>ArrayList的大小是按照其中存储的数据来动态扩充与收缩的。<br>ArrayList不是类型安全的，使用时可能会出现类型不匹配的错误。<br>就算都插入了同一类型的数据，在使用时也需要将它转成对应的袁类型来处理。<br>ArrayList的存储存在装箱、拆箱导致性能低下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        ArrayList arrayList = new ArrayList();</span><br><span class="line">        arrayList.Add(&quot;abc&quot;);</span><br><span class="line">        arrayList.Add(123);</span><br><span class="line">        arrayList[2] = 12.4;</span><br><span class="line">        arrayList.Remove(12.4);</span><br><span class="line">        arrayList.RemoveAt(1);</span><br><span class="line">        arrayList.Insert(0, &quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/08/28/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/08/28/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>C#不支持动态数组，如果想实现类似JS数组的效果，可以参考ArralList或者List。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>矩形数组：<br>某个维度的所有子数组具有相同长度的多维数组。<br>不管有多少维度，总是使用一组方括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mayArray[4,6,1];//一组方括号</span><br></pre></td></tr></table></figure><p>交错数组：<br>每一个子数组都是独立数组的多维数组。<br>可以有不同长度的子数组。<br>为数组的每一个维度使用一对方括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jagArray[2][7][4];</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%95%B0%E7%BB%84/1.jpg"></p><h2 id="声明一维数组与矩形数组"><a href="#声明一维数组与矩形数组" class="headerlink" title="声明一维数组与矩形数组"></a>声明一维数组与矩形数组</h2><p>一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr;</span><br></pre></td></tr></table></figure><p>矩形数组：<br>可以使用多个秩说明符。<br>不能在数组类型区域中放数组维度长度。秩是数组类型的一部分，而维度长度不是类型的一部分。<br>数组声明后维度数就是固定的了，然而数组长度直到数组实例化时才会确定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[,,] arr1;</span><br><span class="line">int[,] arr2;</span><br><span class="line">int[3,2,6] arr3;//编译错误</span><br></pre></td></tr></table></figure><h2 id="实例化一维数组与矩形数组"><a href="#实例化一维数组与矩形数组" class="headerlink" title="实例化一维数组与矩形数组"></a>实例化一维数组与矩形数组</h2><p>一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = new int[4];</span><br><span class="line">int[] arr2 = new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">int[] arr3 = &#123;1,2,3,4&#125;;</span><br><span class="line">var intArr1 = new []&#123;1,2,3,4&#125;;//隐式数组，类型由编译器推断</span><br></pre></td></tr></table></figure><p>矩形数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[,,] arr4 = new int[3,6,2];</span><br><span class="line">int[,] arr5 = new int[,]&#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;</span><br><span class="line">int[,] arr6 = &#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;</span><br><span class="line">var intArr2 = new [,]&#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;//隐式数组，类型由编译器推断</span><br></pre></td></tr></table></figure><p>当数组被创建之后，每一个元素被自动初始化为类型的默认值</p><h2 id="声明交错数组"><a href="#声明交错数组" class="headerlink" title="声明交错数组"></a>声明交错数组</h2><p>方括号的数量决定了数组的秩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[][] SomeArr;</span><br><span class="line">int[][][] OtherArr;</span><br></pre></td></tr></table></figure><h2 id="实例化交错数组"><a href="#实例化交错数组" class="headerlink" title="实例化交错数组"></a>实例化交错数组</h2><p>不能在声明语句中初始化顶层数组之外的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] jagArr = new int[3][];</span><br></pre></td></tr></table></figure><h2 id="初始化交错数组"><a href="#初始化交错数组" class="headerlink" title="初始化交错数组"></a>初始化交错数组</h2><p>交错数组的初始化不能在一个步骤中完成，每一个数组必须独立创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[3][];</span><br><span class="line">arr[0] = new int[]&#123;1,2,3&#125;;</span><br><span class="line">arr[1] = new int[]&#123;4,5,6&#125;;</span><br><span class="line">arr[2] = new int[]&#123;7,8,9&#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组的子数组"><a href="#交错数组的子数组" class="headerlink" title="交错数组的子数组"></a>交错数组的子数组</h2><p>交错数组的子数组本事就是数组，因此子数组可能有矩形数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[][,]Arr;</span><br><span class="line">Arr = new int[3][,];</span><br><span class="line">Arr[0] = new int[]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;</span><br><span class="line">Arr[1] = new int[]&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;;</span><br><span class="line">Arr[2] = new int[]&#123;&#123;9,10&#125;,&#123;11,12&#125;&#125;;</span><br></pre></td></tr></table></figure><p>System.Array的GetLength(int n)方法可以获取数组中指定维度的长度。</p><h2 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h2><p>foreach语句会遍历实现IEnumerable接口的迭代对象，foreach遍历是只读的，不能在foreach中对迭代对象做修改。<br>想要遍历交错数组需要对交错数组中每一个维度使用独立的foreach语句。foreach语句必须嵌套以确保每一个嵌套数组都被正确处理。</p><h2 id="数组协变"><a href="#数组协变" class="headerlink" title="数组协变"></a>数组协变</h2><p>在某些情况下，即使某个对象不是数组的基类型，也可以把它赋值给数组元素这种属性称为协变，以下情况可以使用数组协变：<br>数组是引用类型数组。<br>在赋值的对象类型和数组基类型之间有隐式转换或显式转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        A[] AArr1 = new A[3];</span><br><span class="line">        A[] AArr2 = new A[3];</span><br><span class="line">        //普通</span><br><span class="line">        AArr1[0] = new A(); AArr1[1] = new A(); AArr1[2] = new A();</span><br><span class="line">        //协变</span><br><span class="line">        AArr2[0] = new (); AArr2[1] = new B(); AArr2[2] = new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123; &#125;</span><br><span class="line">class B:A &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="有用的数组成员"><a href="#有用的数组成员" class="headerlink" title="有用的数组成员"></a>有用的数组成员</h2><p>Rank属性实例获取数组维度数<br>Length属性实例获取所有维度的元素总数<br>GetLength 方法实例返回数组的指定维度的长度<br>Clear方法静态将某一范围内的元素设置为0或null<br>Sort 方法静态在一维数组中对元素进行排序<br>BinarySerach方法静态使用二分查找搜索一维数组中的值<br>Clone方法实例进行数组的浅复制——对于值类型数组复制元素对于引用类型则产生指向相同元素的两个数组<br>IndexOf方法静态返回一维数组中遇到的第一个值<br>Reverse方法静态反转一维数组中某一范围内的元素<br>GetUpperBound方法实例获取指定维度的上限</p><h2 id="Clone方法"><a href="#Clone方法" class="headerlink" title="Clone方法"></a>Clone方法</h2><p>对于值类型克隆产生两个数组<br>对于引用类型产生指向相同对象的两个数组<br>克隆方法返回object类型的引用，它必须被强制转换成数组类型！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int[] intArr1 = &#123; 1, 2, 3, &#125;;</span><br><span class="line">        var intArr2 = (int[])intArr1.Clone();</span><br><span class="line">        A[] AArr1 = &#123; new A(),new A(),new A() &#125;;</span><br><span class="line">        var AArr2 = (A[]) AArr1.Clone();</span><br><span class="line">        AArr2[0].val = 12;</span><br><span class="line">        Console.WriteLine(AArr1[0].val);//12</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">    public int val = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 数组 </tag>
            
            <tag> 矩形数组 </tag>
            
            <tag> 交错数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/08/28/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/08/28/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举的简单使用"><a href="#枚举的简单使用" class="headerlink" title="枚举的简单使用"></a>枚举的简单使用</h2><p>枚举是值类型，枚举只有一种类型成员——命名的整数值常量。<br>默认情况下第一个成员为0，每一个后继成员赋的值都比前一个成员多1。<br>枚举成员是静态的，他们和枚举有着相同的可访问性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum TrafficLight&#123;</span><br><span class="line">Green,Yellow,Red</span><br><span class="line">&#125;</span><br><span class="line">TrafficLight t = TrafficLight.Green;</span><br><span class="line">Console.WriteLine($&quot; &#123;t&#125; , &#123; (int)t &#125; &quot;);//Green,0</span><br></pre></td></tr></table></figure><p>注意枚举成员的ToString()方法返回的是成员名，强制转换才能看到枚举值。</p><h2 id="枚举底层类型与显示值"><a href="#枚举底层类型与显示值" class="headerlink" title="枚举底层类型与显示值"></a>枚举底层类型与显示值</h2><p>可以设置底层类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum TrraggicLight : ulong &#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以显式指定成员的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum TrafficLight&#123;</span><br><span class="line">Green,Yellow=12,Red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位标志"><a href="#位标志" class="headerlink" title="位标志"></a>位标志</h2><p>程序员经常使用单个字的不同位作为一组开&#x2F;关标志的紧凑方法，枚举为这样的使用提供了便利。<br>使用Flags特性装饰枚举实际上是不必要的，但可以带来一些额外的遍历。<br>要判断标志字是否包含特定的位标志集，可以使用枚举类型的HasFlag布尔方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        CardDeckSetting ops = CardDeckSetting.SingleDeck | CardDeckSetting.FancyNumber | CardDeckSetting.Animation;</span><br><span class="line">        bool useFancyNumbers = ops.HasFlag(CardDeckSetting.FancyNumber);</span><br><span class="line">        if(useFancyNumbers) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ok&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[Flags]</span><br><span class="line">enum CardDeckSetting : uint &#123;</span><br><span class="line">    SingleDeck = 0x01,</span><br><span class="line">    LargePictures = 0x02,</span><br><span class="line">    FancyNumber = 0x04,</span><br><span class="line">    Animation = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flags特性"><a href="#Flags特性" class="headerlink" title="Flags特性"></a>Flags特性</h2><p>它通知编译器、对象浏览器以及其他查看这段代码的工具，该枚举的成员不仅可以用作单独的值，还可以组合成位标志，这样浏览器就可以更恰当地解释该枚举类型的变量了。<br>其次，它允许枚举的ToString方法为位标志的值提供更多格式化信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        CardDeckSetting ops = CardDeckSetting.SingleDeck | CardDeckSetting.FancyNumber | CardDeckSetting.Animation;</span><br><span class="line">        bool useFancyNumbers = ops.HasFlag(CardDeckSetting.FancyNumber);</span><br><span class="line">        //有Flags特性：SingleDeck, FancyNumber, Animation</span><br><span class="line">        //没有Flages特性：13</span><br><span class="line">        Console.WriteLine(ops);</span><br><span class="line">    &#125;                                           </span><br><span class="line">&#125;</span><br><span class="line">[Flags]</span><br><span class="line">enum CardDeckSetting : uint &#123;</span><br><span class="line">    SingleDeck = 0x01,</span><br><span class="line">    LargePictures = 0x02,</span><br><span class="line">    FancyNumber = 0x04,</span><br><span class="line">    Animation = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum类型的一些静态方法"><a href="#Enum类型的一些静态方法" class="headerlink" title="Enum类型的一些静态方法"></a>Enum类型的一些静态方法</h2><p>Enum.GetName：<br>参数：枚举类型对象，整数<br>返回：对应成员的名称<br>Enum.GetNames：<br>参数：枚举类型对象<br>返回：所有成员的名称且实现IEnumerable接口</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 枚举 </tag>
            
            <tag> Flags特性 </tag>
            
            <tag> 位标志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="结构体的声明和使用"><a href="#结构体的声明和使用" class="headerlink" title="结构体的声明和使用"></a>结构体的声明和使用</h2><p>结构体是值类型，无法派生其他结构。<br>结构体变量不能为null，两个结构体变量不能引用同一对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Simple&#123;</span><br><span class="line">public int a;</span><br><span class="line">public int b;</span><br><span class="line">&#125;</span><br><span class="line">Simple simple = new Simple();</span><br></pre></td></tr></table></figure><p>把一个结构体赋值给另一个结构体，就是将一个结构体的值复制给你另一个结构体。<br>结构体可以有实例构造函数和静态构造函数，但不允许有析构函数。<br>结构体隐式含有一个无参构造函数，不可删除或重定义，结构体的值成员设置为默认值，引用成员设置为null。<br>对于类，编译器只在没有声明其他构造函数时提供隐式的无参构造函数。<br>可以不使用new来创建结构体实例，但这样做只有显式设置数据成员后才能使用它们的值并且在对所有数据成员赋值后，才能调用结构的函数成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple s1,s2;</span><br><span class="line">s1.a=3;</span><br><span class="line">s1.b=4;</span><br><span class="line">Console.WriteLine(s1.a);</span><br></pre></td></tr></table></figure><p>注意：声明结构体时不允许使用实例属性和字段初始化语句，但是静态属性和字段可以在声明时初始化即使结构体本身不是静态的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Simple&#123;</span><br><span class="line">public int a = 3;//报错</span><br><span class="line">public static int b = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构本身派生自System.ValueType，当创建一个和基类成员同名的成员时可以使用new或override修饰符。</p><h2 id="结构作为返回值和参数"><a href="#结构作为返回值和参数" class="headerlink" title="结构作为返回值和参数"></a>结构作为返回值和参数</h2><p>返回值：<br>当结构作为返回值时将创建副本从函数成员返回。<br>值参数：<br>创建副本传入函数。<br>ref和out：<br>传入结构的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结构代替类有时可以提高性能，但同时也要注意装箱拆箱的成本。<br>可以使用分部结构就像分部类一样。<br>结构可以实现接口。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式、运算符、语句、转换</title>
      <link href="/2023/08/28/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/08/28/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>基本的表达式、运算符、语句、转换在这就不过多介绍，有几个比较少见的就在这多提一嘴吧。</p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量@"></a>字符串字面量@</h2><p>逐字字符串字面量以@字符为前缀，而且该字符串中的转义序列不会被求值。<br>逐字字符串字面量的唯一例外是相邻的双引号组会被解释成单个双引号字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string vst1 = @&quot;Hello world&quot;&quot;&quot;;</span><br><span class="line">string vst2 = @&quot;H\tell\no\tworld&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><h2 id="委托的比较"><a href="#委托的比较" class="headerlink" title="委托的比较"></a>委托的比较</h2><p>如果两个委托都是null，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，那么比较返回true。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载不能创建新的运算符，不能改变运算符的语法，不能重新定义运算符如何处理预定义类型，不能改变运算符的优先级或结合性。<br>注意：对于引用类型的对象，前置操作没有问题，因为没有进行复制。但是对于后置操作，因为保存的副本是引用的副本，所以这意味着原始引用和引用副本指向相同的对象。</p><p>声明时必须使用public static。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        LimitedInt limitedInt = new LimitedInt();</span><br><span class="line">        Console.WriteLine((limitedInt + 8).TheValue);</span><br><span class="line">        Console.WriteLine((-limitedInt).TheValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int TheValue = 20;</span><br><span class="line">    public static LimitedInt operator +(LimitedInt x,double y) &#123;</span><br><span class="line">        LimitedInt li =new LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue + (int)y;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">    public static LimitedInt operator -(LimitedInt x) &#123;</span><br><span class="line">        LimitedInt li = new LimitedInt();</span><br><span class="line">        li.TheValue = 0;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只可以为类和结构定义用户自定义转换，不能重定义标准隐式或显式转换。</p><p>源类型和目标类型必须是不同类型，且不能通过继承关联。</p><p>源类型和目标类型不能是接口类型或object类型。</p><p>转换运算符必须是源类型或目标类型的成员。</p><p>对于相同的源类型和目标类型不能声明隐式和显式转换。</p><h2 id="using语句"><a href="#using语句" class="headerlink" title="using语句"></a>using语句</h2><p>某些类型的非托管对象有数量限制或很耗费系统资源，需要使用完尽快释放，using语言有助于简化该过程并确保这些资源被适当处理。<br>资源是指实现了System.IDisposable接口的类或结构，IDisposable接口含有单独一个名为Dispose的方法。<br>使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using(TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))&#123;</span><br><span class="line">    tw.WriteLine(&quot;Four score and seven years age...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用于相同的多个类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using(TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;),</span><br><span class="line">      TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))&#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>typeof运算符返回作为其参数的任何类型的System.Type对象，可以理解成该实例对应类型的说明，Type类型是反射和依赖注入的基础，之后我会详细介绍。</p><h2 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h2><p>有些转换是不成功的，并且在运行时抛出InvalidCastException异常。可以用is运算符检查转换是否成功完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expr is TargetType</span><br></pre></td></tr></table></figure><p>返回布尔值，如果Expr可以通过引用转换、装箱、拆箱成功转换为目标值，则运算符返回true。</p><p>is运算符只可以用于引用转换以及装箱拆箱，不能用于用户自定义转换。</p><h2 id="as运算符"><a href="#as运算符" class="headerlink" title="as运算符"></a>as运算符</h2><p>as运算符和强制转换相似，只是它不抛出异常，如果转换失败，它返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exper as TargetType</span><br></pre></td></tr></table></figure><p>as运算符只可以用于引用转换以及装箱拆箱，不能用于用户自定义转换。</p><h2 id="checked-unchecked语句和checked-unchecked运算符"><a href="#checked-unchecked语句和checked-unchecked运算符" class="headerlink" title="checked&#x2F;unchecked语句和checked&#x2F;unchecked运算符"></a>checked&#x2F;unchecked语句和checked&#x2F;unchecked运算符</h2><p>check语句用来检查转换结果是否溢出，如果我们指定一个表达式或一个代码片段为checked，当转换产生溢出时会抛出OverflowException异常。</p><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked((int)3.14);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checked&#123;</span><br><span class="line">int a = 12.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户定义类型转换"><a href="#用户定义类型转换" class="headerlink" title="用户定义类型转换"></a>用户定义类型转换</h2><p>public和static是用户定义类型转换所必须的。<br>隐式转换（implicit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public static implicit operator int (LimitedInt li) &#123;//隐式转换LimitedInt——&gt;int</span><br><span class="line">        return li.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static implicit operator LimitedInt (int val) &#123;//隐式转换int——&gt;LimitedInt</span><br><span class="line">        LimitedInt li = new LimitedInt ();</span><br><span class="line">        li.value = val;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式转换（explicit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public static explicit operator int (LimitedInt li) &#123;//显式转换LimitedInt——&gt;int</span><br><span class="line">        return li.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static explicit operator LimitedInt (int val) &#123;//显式转换int——&gt;LimitedInt</span><br><span class="line">        LimitedInt li = new LimitedInt ();</span><br><span class="line">        li.value = val;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 字符串字面量 </tag>
            
            <tag> using语句 </tag>
            
            <tag> is </tag>
            
            <tag> as </tag>
            
            <tag> checked </tag>
            
            <tag> 自定义类型转换 </tag>
            
            <tag> 运算符重载 </tag>
            
            <tag> typeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2023/08/28/%E5%A4%9A%E6%80%81/"/>
      <url>/2023/08/28/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>原本打算抽象类和接口一起讲的，但是抽象类也属于多态的章节，而多态又是C#中很重要的部分，所以我觉得还是抽象类和多态一起讲吧。</p><h2 id="虚方法与覆写方法（virtual）"><a href="#虚方法与覆写方法（virtual）" class="headerlink" title="虚方法与覆写方法（virtual）"></a>虚方法与覆写方法（virtual）</h2><p>虚方法可以使基类的引用访问升至派生类内。<br>基类的方法用virtual标注。<br>派生类的方法用override标注。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Human human = new Man();</span><br><span class="line">        human.Eat();//我可以吃方便面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    virtual public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man : Human &#123;</span><br><span class="line">   override public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃方便面&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆写和被覆写的方法必须有相同的可访问性。<br>不能复写static方法和非虚方法。<br>方法、属性、索引器、事件都可以声明virtual和override。<br>方法的调用被沿着派生层次上溯之中，一直到标记为override的方法的最高派生版本。</p><h2 id="抽象（abstract）"><a href="#抽象（abstract）" class="headerlink" title="抽象（abstract）"></a>抽象（abstract）</h2><p>抽象成员指的是必须被覆写的函数成员用abstract，与虚拟成员不同，虚拟成员是可以被覆写抽象成员则是必须被复写，两者都只能覆写函数成员且虚拟成员和抽象成员都不能是私有的。<br>有了abstract就不能写virtual了。<br>含有抽象成员的类被称为抽象类，抽象类只能被用作其他类的基类不能创建实例，被abstract修饰。<br>派生类中的抽象成员必须指定override修饰符，除非这个派生类也是抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract protected void Use();</span><br><span class="line">&#125;</span><br><span class="line">class Human : Animal &#123;</span><br><span class="line">    override protected void Use() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以生火和制造工具&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类常用来解耦，抽象类的进一步抽象便是接口。</p><h2 id="密封类（sealed）"><a href="#密封类（sealed）" class="headerlink" title="密封类（sealed）"></a>密封类（sealed）</h2><p>密封类不能用作基类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealed class Human&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类（static）"><a href="#静态类（static）" class="headerlink" title="静态类（static）"></a>静态类（static）</h2><p>静态类中所有成员都是静态的。<br>可以有一个静态构造函数但是不能有实例构造函数，因为静态类不能创建实例。<br>不能继承静态类。<br>常用的静态类比如Math类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Math.Max(12,99));</span><br><span class="line">Console.WriteLine(Math.Round(12.567));</span><br></pre></td></tr></table></figure><p>静态类常用来做扩展方法：<br>扩展方法是Linq中常用的方法，用来给类增加静态方法和实例方法，以下是int类型的扩展方法演示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int a = 3;</span><br><span class="line">        if (a.Max(4)||) &#123;</span><br><span class="line">            Console.WriteLine(&quot;a更大&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            Console.WriteLine(&quot;a更小&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static class ExtendInt &#123;</span><br><span class="line">    public static bool Max(this int a,int b) &#123;</span><br><span class="line">        return a &gt; b ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须包裹在一个静态类中，拓展方法必须是静态的，拓展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它拓展的类的名称。<br>扩展方法同时扩展了静态方法和实例方法，如果想静态调用，则第一个参数应为拓展类型的实例。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> virtual </tag>
            
            <tag> abstract </tag>
            
            <tag> sealed </tag>
            
            <tag> static </tag>
            
            <tag> 多态 </tag>
            
            <tag> 扩展方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的继承</title>
      <link href="/2023/08/28/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/08/28/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="屏蔽基类的成员"><a href="#屏蔽基类的成员" class="headerlink" title="屏蔽基类的成员"></a>屏蔽基类的成员</h2><p>派生类不能删除它继承的成员但是可以用与基类成员名称相同的成员来屏蔽基类成员。<br>要让编译器知道你是故意屏蔽，可使用new操作符。<br>也可以屏蔽静态成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    public string name = &quot;爸爸&quot;;</span><br><span class="line">    public void MakeMoney() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以赚钱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son : Father &#123;</span><br><span class="line">    new public string name = &quot;儿子&quot;;</span><br><span class="line">    new public void MakeMoney() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我也可以赚钱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基类访问"><a href="#基类访问" class="headerlink" title="基类访问"></a>基类访问</h2><p>如果需要访问被隐藏的继承成员，可使用基类访问表达式：base.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(base.name);</span><br></pre></td></tr></table></figure><h2 id="基类引用"><a href="#基类引用" class="headerlink" title="基类引用"></a>基类引用</h2><p>可以声明基类变量引用子类实例，但是产生的变量仅能访问到基类身上的成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father father = new Son();</span><br></pre></td></tr></table></figure><h2 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h2><p>初始化实例成员——&gt;调用基类构造函数——&gt;执行实例构造函数方法体。<br>注意：强烈反对在构造函数中调用虚方法。在执行基类的构造函数时，基类的虚方法会调用派生类的复写方法，但这是在执行派生类的构造函数方法体之前。因此，调用会在派生类完全初始化之前传递到派生类。</p><h2 id="初始化构造函数"><a href="#初始化构造函数" class="headerlink" title="初始化构造函数"></a>初始化构造函数</h2><p>可以指定用某个基类的构造函数来初始化子类的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Man man1 = new Man();</span><br><span class="line">        Console.WriteLine(man1.Height);</span><br><span class="line">        Man man2 = new Man(180);</span><br><span class="line">        Console.WriteLine(man2.Height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    public int Height;</span><br><span class="line">    public Human(int height) &#123;</span><br><span class="line">        this.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public Human() &#123;</span><br><span class="line">        this.Height = 165;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man : Human &#123;</span><br><span class="line">    public Man() :base() &#123;&#125;</span><br><span class="line">    public Man(int height) : base(height) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以让构造过程使用当前类中其他的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Human human = new Human(75,180);</span><br><span class="line">        Console.WriteLine($&quot;身高&#123;human.Height&#125;，体重&#123;human.Weight&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    public int Height;</span><br><span class="line">    public int Weight;</span><br><span class="line">    private Human(int height) &#123;</span><br><span class="line">        this.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public Human(int weight,int height) :this(height)&#123;</span><br><span class="line">        this.Weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有好几个构造函数，并且它们都需要在对象构造的过程开始时执行公共的代码，可以把公共代码抽取出来作为一个构造函数。<br>readonly字段只能在构造函数中初始化，但是readonly属性不受这个限制。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 屏蔽 </tag>
            
            <tag> 基类访问 </tag>
            
            <tag> 基类引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的参数</title>
      <link href="/2023/08/28/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2023/08/28/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引用参数（ref）"><a href="#引用参数（ref）" class="headerlink" title="引用参数（ref）"></a>引用参数（ref）</h2><p>当参数类型为引用参数时，实参必须是变量，在用作实参前必须被赋值！如果是引用类型变量，可以赋值为一个引用或null。<br>函数声明和调用时都需要在ref参数前加上”ref”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void RefTest(ref int a)&#123; ... &#125;</span><br><span class="line">int a = 3;</span><br><span class="line">RefTest(ref a);</span><br><span class="line">RefTest(3);//报错，必须为变量</span><br></pre></td></tr></table></figure><p>对于值参数，系统会在栈上为形参分配内存，而引用参数不会在栈上分配内存，形参的参数名将作为实参变量的别名指向相同的内存位置。<br>将引用类型对象作为值参数传递时：如果在方法内创建一个新对象并赋值给形参，在方法调用结束后，将切断形参和实参的关联，新对象也不复存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        //调用前</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.age = 20;</span><br><span class="line">        Console.WriteLine(&quot;执行前&quot;+std.age);</span><br><span class="line">        MakeStd(std);</span><br><span class="line">        Console.WriteLine(&quot;执行后&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeStd(Student std) &#123;</span><br><span class="line">std.age = 50;</span><br><span class="line">        Student std2 = new Student();</span><br><span class="line">        std2.age = 20;</span><br><span class="line">        std = std2;</span><br><span class="line">        Console.WriteLine(&quot;执行中：&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/1.jpg" alt="值参数"><br>将引用类型的对象作为引用参数传递时：如果在方法内创建一个新对象并赋值给形参，在方法调用结束后，该对象依然存在，并且是实参所引用的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        //调用前</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.age = 20;</span><br><span class="line">        Console.WriteLine(&quot;执行前&quot;+std.age);</span><br><span class="line">        MakeStd(ref std);</span><br><span class="line">        Console.WriteLine(&quot;执行后&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeStd(ref Student std) &#123;</span><br><span class="line">std.age = 50;</span><br><span class="line">        Student std2 = new Student();</span><br><span class="line">        std2.age = 20;</span><br><span class="line">        std = std2;</span><br><span class="line">        Console.WriteLine(&quot;执行中：&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/2.jpg" alt="应用参数"></p><h2 id="输出参数（out）"><a href="#输出参数（out）" class="headerlink" title="输出参数（out）"></a>输出参数（out）</h2><p>函数声明和调用时都需要在out参数前加上”out”。<br>实参必须是变量。<br>在方法内部，给输出参数赋值之后才能读取它。<br>方法返回之前，每条可能的路径都必须为输出参数赋值。<br>不可能使用输出参数把数据传入方法。<br>形参的名称被设置为实参的别名，可以认为形参实参指向相同内存位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass a1 = null;</span><br><span class="line">        int a2;</span><br><span class="line">        MyMethod(out a1, out a2);</span><br><span class="line">        Console.WriteLine(a1.val);</span><br><span class="line">        Console.WriteLine(a2);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MyMethod(out MyClass f1 , out int f2) &#123;</span><br><span class="line">        f1 = new MyClass();</span><br><span class="line">        f1.val = 25;</span><br><span class="line">        f2 = 15;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    public int val = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main()&#123;</span><br><span class="line">MyMethod(out MyClass a1 , out int a2);</span><br><span class="line">Cosole.WriteLine(a2);</span><br><span class="line">Cosole.WriteLine(a1.val);</span><br><span class="line">a2++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/3.jpg" alt="out"></p><h2 id="参数数组（params）"><a href="#参数数组（params）" class="headerlink" title="参数数组（params）"></a>参数数组（params）</h2><p>一个参数列表中只能有一个参数数组，并且它必须是列表最后一个。<br>参数数组表示的所有参数必须是同一类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        ParamsTest(9, 8, 7, 6, 5, 4, 3, 2, 1);</span><br><span class="line">        int[] ints = &#123;7,6,5,4,3,2,1&#125;;</span><br><span class="line">        ParamsTest(9,8,ints);</span><br><span class="line">    &#125;</span><br><span class="line">    static void ParamsTest(int a, int b ,params int[] vals) &#123;</span><br><span class="line">        foreach(int i in vals) &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref局部变量与ref返回"><a href="#ref局部变量与ref返回" class="headerlink" title="ref局部变量与ref返回"></a>ref局部变量与ref返回</h2><p>ref局部变量：<br>相当于一个变量的别名，即使引用的对象是值类型。<br>对任意一个变量的赋值都会反映到另一个变量上。<br>ref变量声明时必须初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">reg int y = ref x;</span><br></pre></td></tr></table></figure><p>ref返回：<br>ref返回提供了一种使方法返回变量引用而不是变量值的方法。<br>函数声明返回值类型前有ref。<br>函数内部return后有ref。<br>函数调用时函数名前有ref。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int a = 3, b = 4;</span><br><span class="line">        ref int max = ref Max(ref a, ref b);</span><br><span class="line">        Console.WriteLine(++max);</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">        Console.WriteLine(b);</span><br><span class="line">    &#125;</span><br><span class="line">    static ref int Max(ref int a, ref int b) &#123;</span><br><span class="line">        if (a &gt; b)  return ref a; </span><br><span class="line">        else return ref b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>只要显式指定参数的名字，就可以以任意顺序在方法中列出实参。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">    int val;</span><br><span class="line">        val = Calc(c: 4, a: 1, b: 8);</span><br><span class="line">        Console.WriteLine(val);</span><br><span class="line">    &#125;</span><br><span class="line">    static int Calc(int a, int b,int c) &#123;</span><br><span class="line">        return (a+b) * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数（参数默认值）"><a href="#可选参数（参数默认值）" class="headerlink" title="可选参数（参数默认值）"></a>可选参数（参数默认值）</h2><p>不是所有参数类型都可以作为可选参数：<br>只要值类型的默认值在编译的时候可以确定，就可以使用值类型作为可选参数。<br>只有在默认值为null的时候，引用类型才可以用作可选参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int val;</span><br><span class="line">        val = Calc(1,2);</span><br><span class="line">        Console.WriteLine(val);</span><br><span class="line">    &#125;</span><br><span class="line">    static int Calc(int a, int b , int c = 4) &#123;</span><br><span class="line">        return (a+b) * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 参数 </tag>
            
            <tag> ref </tag>
            
            <tag> out </tag>
            
            <tag> params </tag>
            
            <tag> ref返回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数重载</title>
      <link href="/2023/08/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/08/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>当我们调用Console.WriteLine()函数时，我们有时候向这个函数传入整型数字，有时传入浮点数字，有时传入字符串。<br>为什么Console.WirteLine()函数可以接受不同的参数呢？<br>因为在C#语言中有着名为函数重载的功能。</p><h2 id="函数的签名"><a href="#函数的签名" class="headerlink" title="函数的签名"></a>函数的签名</h2><p>函数的签名包括：函数名，函数参数的种类、个数和顺序，还有它所在的类和名称空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">public void study(string name,int school)&#123;</span><br><span class="line">Console.WriteLine($&quot;我叫&#123;name&#125;，我在&#123;school&#125;读计算机专业。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！！！！！！方法的返回值不属于函数签名的一部分！！！！！！</p><h2 id="实现函数重载"><a href="#实现函数重载" class="headerlink" title="实现函数重载"></a>实现函数重载</h2><p>当函数的签名不同时，就可以实现函数的重载，我们可以声明多个同名函数保证他们的参数列表不同，在调用时传入想要执行的那个函数的参数，就可以做到实现不同的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public void study(string name, string school) &#123;</span><br><span class="line">        Console.WriteLine($&quot;我叫&#123;name&#125;，我在&#123;school&#125;读计算机专业。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void study(string name ,int age,string school) &#123;</span><br><span class="line">        Console.WriteLine($&quot;我叫&#123;name&#125;，我今年&#123;age&#125;岁了，我在&#123;school&#125;读幼儿园&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的构造函数也是函数，所以依然可以使用构造函数重载，实现对类成员不同方式的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解类</title>
      <link href="/2023/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB/"/>
      <url>/2023/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类与类成员"><a href="#类与类成员" class="headerlink" title="类与类成员"></a>类与类成员</h1><p>C#类访问限制：</p><p>public class可以被任意程序集所见、internal class仅能被自身程序集所见、static class常用来封装静态属性方法和扩展方法。</p><p>C#类的成员分为：</p><p>静态成员：字段、常量。</p><p>函数成员：属性、方法、索引器、事件、运算符、构造函数、析构函数。</p><p>C#成员访问限制：</p><p>public、static（静态）、private（仅限当前类内）、internal（仅限当前程序集）、protected（仅限当前类与该类的子类）</p><p>非静态成员就是函数成员。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>只用成员既有get又有set时才允许使用访问修饰符。<br>虽然两个访问器都必须出现但他们中只能有一个有访问修饰符。<br>访问器的修饰符限制必须比成员访问级别更严格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.age = -10;</span><br><span class="line">        Console.WriteLine(student.age);// 1</span><br><span class="line">        student.age = 10;</span><br><span class="line">        Console.WriteLine(student.age);// 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private int _age=1;</span><br><span class="line">    public int age &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return _age;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if(value &gt; 0 &amp;&amp; value &lt; 150) &#123;</span><br><span class="line">                _age = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public string name &#123; get; private set; &#125;//自动实现属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.Eat();//实例方法</span><br><span class="line">        Student.Study();//静态方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    public static void Study() &#123;</span><br><span class="line">        Console.WriteLine(&quot;I can study&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;I can eat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数必须和类名相同，且不能有返回值（连void都没有）。静态构造函数用static声明，类只能有有一个静态构造函数且不能带参数，静态构造函数不能有访问修饰符。<br>静态构造函数不能访问所在类的实例成员，因此不能使用this访问器，不能显式调用静态构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public static string school&#123; get; set; &#125;</span><br><span class="line">    public Student(string name) &#123; //构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    static Student() &#123;//静态构造函数</span><br><span class="line">        school = &quot;清北大学&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象初始化语句"><a href="#对象初始化语句" class="headerlink" title="对象初始化语句"></a>对象初始化语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student std = new Student() &#123; name = &quot;张三&quot; &#125;;</span><br><span class="line">Student std - new Student &#123; name = &quot;张三&quot; &#125;;</span><br></pre></td></tr></table></figure><p>注意静态字段和属性不能通过该方式初始化。</p><h2 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h2><p>const修饰符用于字段声明时，const字段使用方式和静态字段一样，几遍没有实例依然可以使用。<br>如果是static字段，初始化必须在静态构造函数中完成。<br>const字段相当于C&#x2F;C++中的#define，它在内存中没有存储位置</p><h2 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h2><p>const只能在字段声明中初始化，const的行为总是静态的。readonly字段可以使实例字段，也可以是静态字段，它在内存中有存储位置。<br>readonly允许在不同环境或不同构造函数中设置不同的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    public const string School = &quot;山河大学&quot;;</span><br><span class="line">    public readonly string Principal;//未初始化</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        this.Principal = &quot;刘校长&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.Principal = &quot;高校长&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会好奇为什么会有两个构造函数，别担心，我会在之后的章节中介绍的函数重载详细说明。</p><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>索引器可以帮助我们以自己想要的方式调用和读取类的成员，索引器不用分配内存在这点索引器和属性的原理一样，不过属性用来表示单个数据成员而索引器用来表示多个成员。<br>索引的是一组get和set访问器。<br>索引器的参数列表在方括号中间，至少声明一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student[0] = &quot;学号:2002220115&quot;;</span><br><span class="line">        student[1] = &quot;姓名:张三&quot;;</span><br><span class="line">        Console.WriteLine(student[0]);</span><br><span class="line">        Console.WriteLine(student[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">    public string this[int i] &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            switch(i) &#123;</span><br><span class="line">                case 0:return id; </span><br><span class="line">                case 1:return name;</span><br><span class="line">                default: return &quot;请在0-1中选择索引&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case 0: id = value;break;</span><br><span class="line">                case 1: name = value;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器重载"><a href="#索引器重载" class="headerlink" title="索引器重载"></a>索引器重载</h2><p>只要索引器的参数列表不同（返回值不同是不够的），类就可以有多个索引器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">public string this[int index]&#123;</span><br><span class="line">get&#123;...&#125;</span><br><span class="line">set&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">public string this[int index1 , int index2]&#123;</span><br><span class="line">get&#123;...&#125;</span><br><span class="line">set&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分部类与分部方法（partial-class）"><a href="#分部类与分部方法（partial-class）" class="headerlink" title="分部类与分部方法（partial class）"></a>分部类与分部方法（partial class）</h2><p>分部类：<br>类的声明可以分割成几个分部类的声明。<br>每个分部类的声明都含有一些类成员的声明。<br>类的分部类声明可以在同一文件中也可以在不同文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">&#125;</span><br><span class="line">partial class Student &#123;</span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分部方法：<br>方法的不同部分可以声明在分部类的不同部分中。<br>声明的实现部分只是一个分号，在实现部分以语句块方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partial class Student &#123;</span><br><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">    public void study(int x);//定义分部方法</span><br><span class="line">&#125;</span><br><span class="line">partial class Student &#123;</span><br><span class="line">    public int age;</span><br><span class="line">    public void study(int x)&#123;//实现分部方法</span><br><span class="line">Console.WriteLine(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 类 </tag>
            
            <tag> 属性 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态构造函数 </tag>
            
            <tag> 索引器 </tag>
            
            <tag> const </tag>
            
            <tag> readonly </tag>
            
            <tag> 分部类 </tag>
            
            <tag> 分部方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/08/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>从今天开始我就要开始写自己的博客了，我会在博客中记录并分享我在学习C#、JS、单片机或其他课程中遇到的问题和解决方案还有一些课堂笔记，如果有遇到同样问题或者想学习以上技术的小伙伴，希望我的博客可以帮助到你们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;%s&quot;,&quot;欢迎来到我的博客&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/%E6%99%BA%E5%95%86+1.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 第一篇博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
