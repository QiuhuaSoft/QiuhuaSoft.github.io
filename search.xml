<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#新语法(下)</title>
      <link href="/2024/01/03/C-%E6%96%B0%E8%AF%AD%E6%B3%95-%E4%B8%8B/"/>
      <url>/2024/01/03/C-%E6%96%B0%E8%AF%AD%E6%B3%95-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> C#新语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#新语法(上)</title>
      <link href="/2024/01/03/C-%E6%96%B0%E8%AF%AD%E6%B3%95-%E4%B8%8A/"/>
      <url>/2024/01/03/C-%E6%96%B0%E8%AF%AD%E6%B3%95-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> C#新语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>停更一段时间</title>
      <link href="/2023/12/22/%E5%81%9C%E6%9B%B4%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4/"/>
      <url>/2023/12/22/%E5%81%9C%E6%9B%B4%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>亲爱的小伙伴们，今天是冬至啦，不知道大家有没有吃饺子。<br>由于本人面临期末考试和毕业设计等原因，技术博客不得不暂停更新一段时间，具体需要多久还不太清楚大概率年后会进行大量的更新，不过有一点可以肯定的是，我会在一月份的时候将之前EFCore和ASP.Net Core的坑填完，目前还有：</p><table><thead><tr><th>文章</th><th>进度</th></tr></thead><tbody><tr><td>Asp.Net Core_EFCore</td><td>未写完</td></tr><tr><td>Asp.Net Core_SignalR</td><td>未写完</td></tr><tr><td>EFCore_表达式树</td><td>未写完</td></tr><tr><td>C#新语法（上）</td><td>未写完</td></tr><tr><td>C#新语法（下）</td><td>未写完</td></tr></tbody></table><p>在这里想先给自己留几个坑等日后填上，由于我快毕业了，到了该进入社会的年纪，我希望在正式工作之前重温一下计算机的基础知识，所以会出一些关于数据结构、算法、计算机网络、操作系统等内容，具体如下：</p><table><thead><tr><th>科目</th><th>内容</th></tr></thead><tbody><tr><td>MySql</td><td>数据库基本操作、事务、索引、视图、锁等</td></tr><tr><td>git</td><td>项目管理基本操作</td></tr><tr><td>数据结构与算法</td><td>借鉴青岛大学王卓老师</td></tr><tr><td>计算机网络</td><td>借鉴王道老师计算机考研免费教程</td></tr><tr><td>操作系统</td><td>借鉴王道老师计算机考研免费教程</td></tr><tr><td>Linux</td><td>Linux基本使用，借鉴韩顺平老师Linux教程</td></tr></tbody></table><p>至于java和python的文章我还没想好写不写，估计写完上面的文章我就已经到了工作的时候，我的java只有初中的时候看书学到的一点内容，python更是完全没学过，如果到了公司遇到了需要使用java或者python，届时我会同步地给大家分享我的学习进度。<br>祝大家工作或者学习顺利！</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 停更 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_表达式树</title>
      <link href="/2023/12/22/EFCore-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
      <url>/2023/12/22/EFCore-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>敬请期待</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 表达式树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_并发控制</title>
      <link href="/2023/11/29/EFCore-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/11/29/EFCore-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="并发控制概念"><a href="#并发控制概念" class="headerlink" title="并发控制概念"></a>并发控制概念</h1><p>避免多个用户同时操作资源造成的并发冲突问题。<br>最好的解决方案：非数据库解决方案<br>数据库层面的两种策略：悲观、乐观。</p><h1 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h1><p>1、悲观并发控制一般采用行锁、表锁等排他锁对资源进行锁定，确保同时只有一个使用者操作被锁定的资源。<br>2、EF Core没有封装悲观并发控制的的使用，需要编写原生SQL语句来使用悲观并发控制。不同数据库的语法不一样。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>1、实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class House&#123;</span><br><span class="line">public long Id &#123;get;set;&#125;</span><br><span class="line">public string Name &#123;get;set;&#125;</span><br><span class="line">public string Owner &#123;get;set;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、MySql方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_Houses where Id=1 for update</span><br></pre></td></tr></table></figure><p>如果有其他的查询操作也使用for update来查询Id&#x3D;1的数据的话，那些查询会被挂起，一直到针对这条数据的更新操作完成从而释放这个行锁，代码才会继续执行。<br>3、事务：<br>锁是和事务相关的，因此通过BeginTransactionAsync()创建一个事务，并且在所有操作完成后调用CommitAsync()提交事务。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下代码会有并发冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入参赛者&quot;);</span><br><span class="line">            var o = Console.ReadLine();</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123; </span><br><span class="line">                var house = ctx.Houses.Single(h=&gt;h.Id==1);</span><br><span class="line">                if(!string.IsNullOrEmpty(house.Owner)) &#123;</span><br><span class="line">                    if (house.Owner == o) &#123;</span><br><span class="line">                        Console.WriteLine(&quot;房子已经被你抢到了&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Console.WriteLine($&quot;房子已被&#123;house.Owner&#125;占领&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                house.Owner = o;</span><br><span class="line">                Thread.Sleep(10000);</span><br><span class="line">                Console.WriteLine($&quot;恭喜&#123;o&#125;抢占成功&quot;);</span><br><span class="line">                ctx.SaveChanges();                </span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/EFCore_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/1.jpg"><br><img src="/images/EFCore_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/2.jpg"><br>更改后无并发冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入参赛者&quot;);</span><br><span class="line">            var o = Console.ReadLine();</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123; </span><br><span class="line">                using(var tx = ctx.Database.BeginTransaction()) &#123;</span><br><span class="line">                    var house = ctx.Houses.FromSqlInterpolated($&quot;select * from T_Houses where Id=1 for update&quot;).Single();//设锁</span><br><span class="line">                    if (!string.IsNullOrEmpty(house.Owner)) &#123;</span><br><span class="line">                        if (house.Owner == o) &#123;</span><br><span class="line">                            Console.WriteLine(&quot;房子已经被你抢到了&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Console.WriteLine($&quot;房子已经被【&#123;house.Owner&#125;】占了&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Console.ReadLine();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    house.Owner = o;</span><br><span class="line">                    Thread.Sleep(10000);</span><br><span class="line">                    ctx.SaveChanges();//在这里保存完成后才解锁</span><br><span class="line">                    Console.WriteLine(&quot;恭喜你抢占成功&quot;);</span><br><span class="line">                    tx.Commit();</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>悲观并发控制的使用比较简单，不同数据库的语法不一样，并且锁是独占、排他的，如果系统并发量很大的话，会严重影响性能，如果使用不当的话，甚至会导致死锁。</p><h1 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h1><h2 id="乐观并发原理"><a href="#乐观并发原理" class="headerlink" title="乐观并发原理"></a>乐观并发原理</h2><p>Update T_Houses set Owner&#x3D;新值 where Id&#x3D;1 and Owner&#x3D;旧值<br>当Update时，如果数据库中的Owner值已经被其他操作者更新为其他值，那么where语句的值就会为false，因此这个Update语句影响的行数就是0，EFCore就知道“发生并发冲突”了，因此SaveChanges()方法会抛出DbUpdateConcurrencyException异常</p><h2 id="并发令牌"><a href="#并发令牌" class="headerlink" title="并发令牌"></a>并发令牌</h2><p>如上述，关于Owner的并发操作需要进行并发控制，Owner就被称为并发令牌。<br>具体配置如下：<br>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HouseConfig : IEntityTypeConfiguration&lt;House&gt; &#123;</span><br><span class="line">        public void Configure(EntityTypeBuilder&lt;House&gt; builder) &#123;</span><br><span class="line">            builder.ToTable(&quot;T_Houses&quot;);</span><br><span class="line">            builder.Property(h=&gt;h.Owner).IsConcurrencyToken();//配置为并发令牌</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;请输入参赛者&quot;);</span><br><span class="line">            var o = Console.ReadLine();</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var house = ctx.Houses.Single(h =&gt; h.Id == 1);</span><br><span class="line">                if (!string.IsNullOrEmpty(house.Owner)) &#123;</span><br><span class="line">                    if (house.Owner == o) &#123;</span><br><span class="line">                        Console.WriteLine(&quot;房子已经被你抢到了&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Console.WriteLine($&quot;房子已被&#123;house.Owner&#125;占领&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                house.Owner = o;</span><br><span class="line">                Thread.Sleep(10000);</span><br><span class="line">                Console.WriteLine($&quot;恭喜&#123;o&#125;抢占成功&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    ctx.SaveChanges();</span><br><span class="line">                &#125;catch(DbUpdateConcurrencyException ex) &#123;</span><br><span class="line">                    var entry = ex.Entries.First();</span><br><span class="line">                    var dbValues = entry.GetDatabaseValues();</span><br><span class="line">                    string newOwner = dbValues.GetValue&lt;string&gt;(nameof(house.Owner));</span><br><span class="line">                    Console.WriteLine($&quot;出现了并发冲突，被&#123;newOwner&#125;提前抢走了&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>因为悲观并发控制可能会导致数据库死锁，所以更推荐使用乐观并发控制。</p><h1 id="RowVersion"><a href="#RowVersion" class="headerlink" title="RowVersion"></a>RowVersion</h1><p>上面的例子只能给Owner这一个字段添加并发控制令牌，如果想让一个数据除了Owner字段之外的数据发生变化依然采用乐观并发控制应该怎么办，为此产生了新的方式——RowVersion</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1、对于SQLServer数据库可以在实体类中用一个byte[]类型的属性做并发令牌，然后使用IsRowVersion()把这个属性设置为RowVersion类型，这样这个属性对应的数据库列就会被设置为RowVersion类型。对于RowVersion类型的列，在每次插入或更新行时，数据库会自动为这一行的RowVersion类型的列生成新的值。<br>说简单点就是在数据库中用一个名为RowVersion的字段记录这条数据更新的版本，每次有更新这个数据的值都会不一样，在对数据进行操作的时候会使用这个字段的数据与该字段原数据进行对比，实现乐观并发控制。<br>2、在SQLServer中，timestamp和rowversion是同一种类型的不同别名，实体类byte[]——&gt;数据库rowversion或timestamp。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class House &#123;</span><br><span class="line">        public long Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public string? Owner &#123; get; set; &#125;</span><br><span class="line">        public byte[] RowVer &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HouseConfig : IEntityTypeConfiguration&lt;House&gt; &#123;</span><br><span class="line">       public void Configure(EntityTypeBuilder&lt;House&gt; builder) &#123;</span><br><span class="line">           builder.ToTable(&quot;T_Houses&quot;);</span><br><span class="line">           builder.Property(h =&gt; h.RowVer).IsRowVersion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Program.cs和以前一样。</p><h2 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h2><p>1、在MySql等数据库中虽然也有类似的timestamp类型，但是旧版MySql的timestamp类型的精度不够，并不适合在高并发的系统。<br>2、非SQLServer中，可以将并发令牌列的值更新为Guid的值。<br>3、修改其他属性值的同时，使用h1.RowVer&#x3D;Guid.NewGuid()手动更新并发令牌属性的值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、乐观并发控制能够避免悲观锁带来的性能、死锁等问题，因此推荐使用乐观并发控制而不是悲观锁。<br>2、如果有一个确定的字段要被进行并发控制，那么使用isConcurrencyToken()把这个字段设置为并发令牌即可。<br>3、如果无法确定一个唯一的并发令牌列，那么就可以引入一个额外的属性设置为并发令牌，并且在每次更新数据的时候，手动更新这一列的值。如果用的是SQLServer数据库，那么也可以采用RowVersion列，这样就不用开发者手动在每次更新数据的时候，手动更新并发令牌的值了。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 并发控制 </tag>
            
            <tag> 乐观并发 </tag>
            
            <tag> 悲观并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_全局查询筛选器</title>
      <link href="/2023/11/20/EFCore-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E7%AD%9B%E9%80%89%E5%99%A8/"/>
      <url>/2023/11/20/EFCore-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E7%AD%9B%E9%80%89%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="全局查询筛选器"><a href="#全局查询筛选器" class="headerlink" title="全局查询筛选器"></a>全局查询筛选器</h1><p>全局查询筛选器：EF Core会自动将这个查询筛选器应用于涉及这个实体类型的所有LINQ查询。<br>场景：软删除、多租户。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>向配置类添加<br>builder.HasQueryFilter(b&#x3D;&gt;b.IsDeleted&#x3D;&#x3D;false);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ArticleConfig : IEntityTypeConfiguration&lt;Article&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Article&gt; builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Articles&quot;);</span><br><span class="line">        builder.HasQueryFilter(a =&gt; a.IsDeleted==false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="忽略全局筛选器"><a href="#忽略全局筛选器" class="headerlink" title="忽略全局筛选器"></a>忽略全局筛选器</h2><p>ctx.Articles.IgnoreQueryFilters();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                foreach (var item in ctx.Articles.Where(a =&gt; a.Id &gt; 3)) &#123;</span><br><span class="line">                    Console.WriteLine(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">                foreach (var item in ctx.Articles.IgnoreQueryFilters().Where(a =&gt; a.Id &gt; 3)) &#123;</span><br><span class="line">                    Console.WriteLine(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>全局筛选器可能会有性能缺陷的陷阱。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 全局查询筛选器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_实体数据的状态</title>
      <link href="/2023/11/20/EFCore-%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8A%B6%E6%80%81/"/>
      <url>/2023/11/20/EFCore-%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="实体状态"><a href="#实体状态" class="headerlink" title="实体状态"></a>实体状态</h1><h2 id="快照更改跟踪"><a href="#快照更改跟踪" class="headerlink" title="快照更改跟踪"></a>快照更改跟踪</h2><p>首次跟踪一个实体的时候，EF Core会创建这个实体的快照。执行SaveChanges()等方法时，EF Core将会把存储在快照中的值与实体的当前值进行比较。<br>和DbContext有关系的实体、类都会生成快照。</p><h2 id="实体的状态"><a href="#实体的状态" class="headerlink" title="实体的状态"></a>实体的状态</h2><p>已添加（Added）：DbContext正在跟踪此实体，但数据库中尚不存在该实体。<br>未改变（Unchanged）：DbContext正在跟踪此实体，该实体存在于数据库中，其属性值和从数据库中读取到的值一致，未发生改变。<br>已修改（Modified）：DbContext正在跟踪此实体，并存在于数据库中，并且其部分或全部属性值已修改。<br>已删除（Deleted）：DbContext正在跟踪此实体，并存在于数据库中，但在下次调用SaveChanges时要从数据库中删除对应数据。<br>已分离（Detached）：DbContext未跟踪该实体。</p><h2 id="查询实体状态"><a href="#查询实体状态" class="headerlink" title="查询实体状态"></a>查询实体状态</h2><p>使用DbContext的Entry()方法来获取实体在EF Core的跟踪信息对象EntityEntry。EntityEntry类的State属性代表实体的状态，通过DebugView.LongView属性可以看到实体的变化信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var items = ctx.Articles.Take(5).ToArray();</span><br><span class="line">                var a1 = items[0];</span><br><span class="line">                var a2 = items[1];</span><br><span class="line">                var a3 = items[2];</span><br><span class="line"></span><br><span class="line">                var a4 = new Article() &#123; Title = &quot;ddd&quot;, Message = &quot;xxxxxxxxxxx&quot; &#125;;</span><br><span class="line">                var a5 = new Article() &#123; Title = &quot;阿斯拉达覅见哦&quot;, Message = &quot;送到哪给下次&quot; &#125;;</span><br><span class="line"></span><br><span class="line">                a2.Title = &quot;WBG 0:3 不敌 T1&quot;;</span><br><span class="line">                ctx.Articles.Remove(a3);</span><br><span class="line">                ctx.Articles.Add(a4);</span><br><span class="line"></span><br><span class="line">                EntityEntry e1 = ctx.Entry(a1);</span><br><span class="line">                EntityEntry e2 = ctx.Entry(a2);</span><br><span class="line">                EntityEntry e3= ctx.Entry(a3);</span><br><span class="line">                EntityEntry e4 = ctx.Entry(a4);</span><br><span class="line">                EntityEntry e5 = ctx.Entry(a5);</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(e1.State);</span><br><span class="line">                Console.WriteLine(e2.DebugView.LongView);</span><br><span class="line">                Console.WriteLine(e3.State);</span><br><span class="line">                Console.WriteLine(e4.State);</span><br><span class="line">                Console.WriteLine(e5.State);</span><br><span class="line"></span><br><span class="line">                ctx.SaveChanges();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>DbContext会根据跟踪的实体的状态，在SaveChanges()的时候，根据实体状态的不同，生成Update、Delete、Insert等SQL语句，来把内存中实体的变化更新到数据库。</p><h1 id="AsNoTracking"><a href="#AsNoTracking" class="headerlink" title="AsNoTracking"></a>AsNoTracking</h1><p>如果通过DbContext查询出来的对象只是用来展示，不会发生状态改变，则可以使用AsNoTracking()来“禁用跟踪”，可以降低内存占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var items = ctx.Articles.AsNoTracking().Take(5).ToArray();</span><br><span class="line">                foreach (var item in items) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 实体状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_原生SQL语句</title>
      <link href="/2023/11/18/EFCore-%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/11/18/EFCore-%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="执行原生非查询SQL语句"><a href="#执行原生非查询SQL语句" class="headerlink" title="执行原生非查询SQL语句"></a>执行原生非查询SQL语句</h1><p>可以自己写数据库语句而非使用linq进行转换。<br>由于数据库语法的差异，所以可能无法跨越数据库使用。<br>一般用于以下情况：非查询语句、实体查询、任意SQL查询。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>使用dbCtx.Database.ExecuteSqlInterpolated()、dbCtx.Database.ExecuteSqlInterpolatedAsync()执行原生的非查询SQL语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">           using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">               await ctx.Database.ExecuteSqlInterpolatedAsync(@$&quot;INSERT INTO t_articles (Title, Message) </span><br><span class="line">                VALUES (&#x27;WBG对战T1&#x27;, &#x27;WBG与T1将于11月19日下午四点进行比赛&#x27;);&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h2><p>我们必须使用插值语法作为dbCtx.Database.ExecuteSqlInterpolated()方法的参数，因此我们可以写出以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string title = &quot;WBG对战T1&quot;;</span><br><span class="line">            string message = &quot;WBG与T1将于11月19日下午四点进行比赛&quot;;</span><br><span class="line">           using (var ctx  = new MyDbContext()) &#123;</span><br><span class="line">               await ctx.Database.ExecuteSqlInterpolatedAsync(@$&quot;INSERT INTO t_articles (Title, Message) </span><br><span class="line">                VALUES (&#123;title&#125;, &#123;message&#125;);&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>上面的代码生成的SQL语句不会出现SQL注入，其生成语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t_articles (Title, Message) VALUES (@p0, @p1);</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>1、字符串内插如果赋值给string变量就是字符串拼接；如果赋值给FormattableString变量，编译器就会构造FormattableString对象。该对象有很多方法可以通过F12键进行查看。<br>2、ExecuteSqlInterpolatedAsync()的参数是FormattableString类型。因此ExecuteSqlInterpolatedAsync()会进行参数化SQL的处理。<br>3、除了ExecuteSqlInterpolated()、ExecuteSqlInterpolatedAsync()以外还有ExecuteSqlRaw()、ExecuteSqlRawAsync()也可以执行原生SQL语句，但需要开发人员自己处理查询参数等了，因此不推荐使用。</p><h1 id="执行与实体相关原生SQL查询语句"><a href="#执行与实体相关原生SQL查询语句" class="headerlink" title="执行与实体相关原生SQL查询语句"></a>执行与实体相关原生SQL查询语句</h1><h2 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h2><p>1、如果要执行的原生SQL是一个查询语句，并且查询的结果也能对应一个实体，就可以调用对应实体的DbSet的FromSqlInterpolated()方法来执行一个查询SQL语句，同样使用字符串内插来传递参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string str = &quot;%T1%&quot;;</span><br><span class="line">            FormattableString fms = @$&quot;select * from t_articles where Title like &#123;str&#125;;&quot;;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var res = ctx.Articles.FromSqlInterpolated(fms);</span><br><span class="line">                foreach(var item in res) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(item.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>2、FromSqlInterpolated()方法的返回值是IQueryable类型的，因此可以在实际执行IQueryable之前，对IQueryable类型进行进一步处理。<br>3、可以把只能用原生SQL语句写的逻辑用FromSqlInterpolated()去执行，然后把分页、分组、二次过滤、排序、Include等其他逻辑尽可能仍然使用EF Core的标准去实现。</p><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>SQL必须返回实体类型对应数据库表的所有列；<br>结果集中的列名必须与属性映射到的列名称匹配；<br>只能单表查询，不能使用Join语句进行关联查询。但是可以在查询后面使用Include()来进行关联数据的获取。</p><h1 id="执行任意原生SQL查询语句"><a href="#执行任意原生SQL查询语句" class="headerlink" title="执行任意原生SQL查询语句"></a>执行任意原生SQL查询语句</h1><p>1、FromSqlInterpolated()只能单表查询，但是在实现报表查询等操作的时候，SQL语句通常是非常复杂的，不仅要多表Join而且返回的结果一般也都不会和一个实体类完整对应。因此需要一种执行任意SQL查询语句的机制。<br>2、EF Core中允许把视图或存储过程映射为实体，因此可以把复杂的查询语句写成视图或存储过程，然后再声明对应的实体类，并且在DbContext中配置对应的DbSet。<br>3、不推荐写存储过程；项目复杂查询很对，导致视图太对、DbSet膨胀。</p><h2 id="简单使用-2"><a href="#简单使用-2" class="headerlink" title="简单使用"></a>简单使用</h2><p>dbSet.Database.GetDbConnection()获得ADO.NET Core的数据库连接对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                DbConnection conn = ctx.Database.GetDbConnection();//拿到Context对应的底层Connection对象</span><br><span class="line">                if(conn.State !=System.Data.ConnectionState.Open ) &#123; </span><br><span class="line">                    await conn.OpenAsync();</span><br><span class="line">                &#125;</span><br><span class="line">                using(var cmd =  conn.CreateCommand()) &#123;</span><br><span class="line">                    cmd.CommandText=&quot;select Price,Count(*) from T_Articles group by Price&quot;;</span><br><span class="line">                    using (var reader = await cmd.ExecuteReaderAsync()) &#123;</span><br><span class="line">                        while(await reader.ReadAsync()) &#123;</span><br><span class="line">                            double price = reader.GetDouble(0);</span><br><span class="line">                            int count = reader.GetInt32(1);</span><br><span class="line">                            await Console.Out.WriteLineAsync($&quot;&#123;price&#125;:&#123;count&#125;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>不建议直接使用ADO.NET Core，可以使用Dapper写任意原生的SQL语句。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般Linq操作就够了，尽量不写原生SQL；<br>1、非查询SQL用ExecuteSqlInterpolated()；<br>2、针对实体的SQL查询用FromSqlInterpolated()；<br>3、复杂SQL查询用ADO.NET的方式或者Dapper等；</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 原生SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_IQueryable</title>
      <link href="/2023/11/16/EFCore-IQueryable/"/>
      <url>/2023/11/16/EFCore-IQueryable/</url>
      
        <content type="html"><![CDATA[<h1 id="IQueryable与IEnumerable"><a href="#IQueryable与IEnumerable" class="headerlink" title="IQueryable与IEnumerable"></a>IQueryable与IEnumerable</h1><h2 id="不同的Where方法"><a href="#不同的Where方法" class="headerlink" title="不同的Where方法"></a>不同的Where方法</h2><p>1、对于普通集合和DbSet调用的Where方法，虽然用起来一样，但是“转到定义”后看到的是不同的方法。<br>2、普通集合的版本（IEnumerable）是在内存中过滤（客户端评估），而IQueryable版本则是把查询操作翻译成SQL语句（服务器端评估）。<br>如果强制使用IEnumerable的版本，两个方式会生成不同的SQL语句。<br>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">            //IQueryable&lt;Comment&gt; comments = ctx.Comments;</span><br><span class="line">            //IQueryable&lt;Comment&gt; cmts = comments.Where(c =&gt; c.Message.Contains(&quot;人性&quot;));</span><br><span class="line">            IEnumerable&lt;Comment&gt; comments = ctx.Comments;</span><br><span class="line">            IEnumerable&lt;Comment&gt; cmts = comments.Where(c =&gt; c.Message.Contains(&quot;人性&quot;));</span><br><span class="line">            foreach (var c in cmts) &#123;</span><br><span class="line">                Console.WriteLine(c.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IEnumerable版本：<br>把所有数据放到客户端再进行筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT `t`.`Id`, `t`.`Message`, `t`.`TheArticleId`</span><br><span class="line">      FROM `T_Comments` AS `t`</span><br></pre></td></tr></table></figure><p>IQueryable版本：<br>数据在数据库进行筛选然后传给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT `t`.`Id`, `t`.`Message`, `t`.`TheArticleId`</span><br><span class="line">     FROM `T_Comments` AS `t`</span><br><span class="line">     WHERE `t`.`Message` LIKE &#x27;%人性%&#x27;</span><br></pre></td></tr></table></figure><h2 id="有时需要客户端评估（很少）"><a href="#有时需要客户端评估（很少）" class="headerlink" title="有时需要客户端评估（很少）"></a>有时需要客户端评估（很少）</h2><p>1、如果有些语句在服务器执行时占用资源特别多，可以考虑采用客户端评估。<br>2、如果有些语句特别复杂，无法转为SQL语句，可以考虑采用客户端评估。</p><h1 id="IQueryable延迟执行"><a href="#IQueryable延迟执行" class="headerlink" title="IQueryable延迟执行"></a>IQueryable延迟执行</h1><p>IQueryable只查询不遍历，就不会执行SQL语句。<br>IQueryable表示一个可以放到数据库执行的操作，它没有立即执行只是可以被执行。<br>对IQueryable接口调用非终结方法时不会执行查询，而调用终结方法时会立即执行查询。<br>终结方法：遍历、ToArray()、ToList()、Min()、Max()、Count()等。<br>非终结方法：GroupBy()、OrderBy()、Include()、Skip()、Take()等。<br>简单判断：如果一个方法的返回值为IQueryable那么这个操作一般为非终结方法，否则就是终结方法。<br>IQueryable是可以复用的，所以在实际执行终结方法之前可以分部构建IQueryable，常用于用户自定义动态查询规则。</p><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>通过Skip(3).Take(8)进行分页查询，最好显式指定排序规则。<br>需要知道满足条件的数据的总条数可以通过LongCount()，因为Count()返回的数据类型是int，数据过多的时候会超出int的最大值，而LongCount()获取的数据类型是long。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    PrintData(3, 3);</span><br><span class="line"> &#125;</span><br><span class="line">static void PrintData(int PageIndex,int PageSize) &#123;</span><br><span class="line">    using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">        var ctxs = ctx.OrgUnits.Where(o =&gt; o.Name.Contains(&quot;秋华&quot;));</span><br><span class="line">        var result = ctxs.Skip((PageIndex-1)*PageSize).Take(PageSize);</span><br><span class="line">        foreach (var res in result) &#123;</span><br><span class="line">            Console.WriteLine(res.Name);</span><br><span class="line">        &#125;</span><br><span class="line">        long PageLength = (long)Math.Ceiling(ctx.OrgUnits.LongCount()*1.0/PageSize);</span><br><span class="line">        Console.WriteLine($&quot;总页数：&#123;PageLength&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IQueryable一次性加载"><a href="#IQueryable一次性加载" class="headerlink" title="IQueryable一次性加载"></a>IQueryable一次性加载</h1><h2 id="DataReader与DataTable"><a href="#DataReader与DataTable" class="headerlink" title="DataReader与DataTable"></a>DataReader与DataTable</h2><p>DataReader：分批从数据库服务器读取数据。内存占用小、DB连接占用时间长；<br>DataTable：把所有数据都一次性从数据库服务器都加载到客户端内存中。内存占用大，节省DB连接；<br>IQueryable内部就是在调用DataReader进行数据读取。</p><h2 id="如何一次性加载"><a href="#如何一次性加载" class="headerlink" title="如何一次性加载"></a>如何一次性加载</h2><p>使用IQueryable的ToArray()、ToArrayAsync()、ToList()、ToListAsync()等方法可以一次性加载数据到内存中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                foreach (var item in ctx.OrgUnits.ToList()) &#123;</span><br><span class="line">                    Console.WriteLine(item.Name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="何时需要一次性加载"><a href="#何时需要一次性加载" class="headerlink" title="何时需要一次性加载"></a>何时需要一次性加载</h2><p>1：遍历IQueryable并且进行数据处理的过程很耗时，为了不占用服务器资源时可以使用。<br>2：如果方法需要返回查询结果，并且在方法里销毁DbContext的话，是不能返回IQueryable的。必须一次性加载返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           var res = GetOrgUnits();</span><br><span class="line">            foreach (var unit in res) &#123;</span><br><span class="line">                //由于IQueryable是延迟执行的，所以res并没有结果而是在遍历时去查询，但是查询时res对应的DB连接已经被断开</span><br><span class="line">                Console.WriteLine(unit.Name);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        static IQueryable&lt;OrgUnit&gt; GetOrgUnits() &#123;</span><br><span class="line">            using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">                return ctx.OrgUnits.Where(o=&gt;o.Name.Contains(&quot;秋华&quot;));</span><br><span class="line">                //注意：出了using就会销毁MyDbContext实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>3：多个IQueryable的遍历嵌套。很多数据库的ADO.NET Core Provider是不支持多个DataReader同时执行的。<br>在SqlServer中可以通过在连接字符串中添加MultipleActiveResultSets&#x3D;true使其支持DataReader同时执行。对于别的数据库可以转换为DataTable模式再执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">          using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">               foreach (var item in ctx.Articles.ToList()) &#123;</span><br><span class="line">                   Console.WriteLine(item.Title);</span><br><span class="line">                   foreach(var item2 in ctx.Teachers.ToList()) &#123;</span><br><span class="line">                       Console.WriteLine(item2.Name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="EF-Core的异步方法"><a href="#EF-Core的异步方法" class="headerlink" title="EF Core的异步方法"></a>EF Core的异步方法</h1><h2 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h2><p>1、SaveChanges()、SaveChangesAsync()<br>2、异步方法大部分是定义在Microsoft.EntityFrameworkCore这个名称空间下EntityFrameworkQueryableExtensions等类中的拓展方法，记得using.。<br>3、一般终结方法都有对应的异步方法，而非终结方法如GroupBy、OrderBy、Join、Where等非终结方法没有异步方法。</p><h2 id="异步遍历IQueryable"><a href="#异步遍历IQueryable" class="headerlink" title="异步遍历IQueryable"></a>异步遍历IQueryable</h2><p>1、ToListAsync()、ToArrayAsync()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">           using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">                foreach (var item in await ctx.Articles.ToListAsync()) &#123;</span><br><span class="line">                    Console.WriteLine(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>2、await foreach+AsAsyncEnumerable()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">           using(var ctx  = new MyDbContext()) &#123;</span><br><span class="line">                await foreach (var item in ctx.Articles.AsAsyncEnumerable()) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(item.Title);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>一般没必要异步遍历。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> IQueryable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_一对一与多对多</title>
      <link href="/2023/11/16/EFCore-%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A/"/>
      <url>/2023/11/16/EFCore-%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h1><p>采购申请订单——&gt;采购订单<br>订单——&gt;快递单<br>我将以订单——&gt;快递单为例进行讲解。<br>一对一关系必须显示地在其中一个实体类中声明一个外键属性。<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Delivery &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string CampanyName &#123; get; set; &#125;</span><br><span class="line">    public string Number &#123; get; set; &#125;</span><br><span class="line">    public Order Order &#123; get; set; &#125;</span><br><span class="line">    public long OrderId &#123; get; set; &#125;//显式建立外键</span><br><span class="line">&#125;</span><br><span class="line">public class Order &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public Delivery Delivery &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">internal class DeliveryConfig : IEntityTypeConfiguration&lt;Delivery&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Delivery&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Deliverys&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class OrderConfig : IEntityTypeConfiguration&lt;Order&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Order&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Orders&quot;);</span><br><span class="line">        builder.HasOne&lt;Delivery&gt;(o=&gt;o.Delivery).WithOne(d=&gt;d.Order).HasForeignKey&lt;Delivery&gt;(d=&gt;d.OrderId).IsRequired();//添加外键</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">            Order o1 = new Order &#123; Name = &quot;手机&quot; &#125;;</span><br><span class="line">            Delivery d1 = new Delivery &#123; Number=&quot;0001&quot;, CampanyName =&quot;顺丰快递&quot;,Order =  o1 &#125;;</span><br><span class="line">            ctx.Deliveries.Add(d1);</span><br><span class="line">            ctx.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h1><p>老师——学生<br>EF Core 5.0开始正式支持多对多。<br>多对多必然产生中间表。<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher</span><br><span class="line">&#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Student&gt; Student &#123; get; set; &#125; = new List&lt;Student&gt;();</span><br><span class="line">&#125;</span><br><span class="line">public class Student</span><br><span class="line">&#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Teacher&gt; Teachers &#123; get; set; &#125; = new List&lt;Teacher&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class TeacherConfig : IEntityTypeConfiguration&lt;Teacher&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Teacher&gt; builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Teachers&quot;);</span><br><span class="line">        builder.HasMany(t =&gt; t.Student).WithMany(s =&gt; s.Teachers).UsingEntity(j =&gt; j.ToTable(&quot;T_Teachers_Students&quot;));//最好指定一下中间表的表名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">internal class StudentConfig : IEntityTypeConfiguration&lt;Student&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Student&gt; builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Students&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">            /*</span><br><span class="line">            var s1 = new Student &#123; Name = &quot;张三&quot; &#125;;</span><br><span class="line">            var s2 = new Student &#123; Name = &quot;李四&quot; &#125;;</span><br><span class="line">            var s3 = new Student &#123; Name = &quot;王五&quot; &#125;;</span><br><span class="line">            var t1 = new Teacher &#123; Name = &quot;刘老师&quot; &#125;;</span><br><span class="line">            var t2 = new Teacher &#123; Name = &quot;杨老师&quot; &#125;;</span><br><span class="line">            var t3 = new Teacher &#123; Name = &quot;高老师&quot; &#125;;</span><br><span class="line">            s1.Teachers.Add(t1);</span><br><span class="line">            s1.Teachers.Add(t2);</span><br><span class="line">            s2.Teachers.Add(t3);</span><br><span class="line">            s2.Teachers.Add(t1);</span><br><span class="line">            s3.Teachers.Add(t2);</span><br><span class="line">            ctx.Students.Add(s1);</span><br><span class="line">            ctx.Students.Add(s2);</span><br><span class="line">            ctx.Students.Add(s3);</span><br><span class="line">            ctx.SaveChanges();*/</span><br><span class="line">            var teachers = ctx.Teachers.Include(t =&gt; t.Student).ToList();</span><br><span class="line">            foreach (var teacher in teachers) &#123;</span><br><span class="line">                Console.WriteLine(teacher.Name);</span><br><span class="line">                foreach (var student in teacher.Student) &#123;</span><br><span class="line">                    Console.WriteLine(&#x27;\t&#x27;+student.Name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 一对一 </tag>
            
            <tag> 多对多 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_一对多</title>
      <link href="/2023/11/11/EFCore-%E4%B8%80%E5%AF%B9%E5%A4%9A/"/>
      <url>/2023/11/11/EFCore-%E4%B8%80%E5%AF%B9%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="EF-Core一对多"><a href="#EF-Core一对多" class="headerlink" title="EF Core一对多"></a>EF Core一对多</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、实体类中关系属性<br>2、FluentAPI关系配置<br>3、使用关系操作</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>目的：数据库保存文章与评论，一篇文章对应多条评论<br>1、实体类中关系属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Article &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Title &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public List&lt;Comment&gt; Comments = new List&lt;Comment&gt; ();//实体类中关系属性</span><br><span class="line">&#125;</span><br><span class="line">public class Comment &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public Article TheArticle &#123; get; set; &#125;//实体类中关系属性</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、FluentAPI关系配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">internal class CommentConfig : IEntityTypeConfiguration&lt;Comment&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Comment&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Comments&quot;);</span><br><span class="line">        builder.HasOne&lt;Article&gt;(e =&gt; e.TheArticle).WithMany(e =&gt; e.Comments).IsRequired();//FluentAPI关系配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ArticleConfig : IEntityTypeConfiguration&lt;Article&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Article&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Articles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用关系操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        using(var db = new MyDbContext()) &#123;</span><br><span class="line">            Article article = new Article();</span><br><span class="line">            article.Title = &quot;震惊！母猪为何深夜惨叫&quot;;</span><br><span class="line">            article.Message = &quot;近日，家在石家庄村里的张老汉发现。。。。。。&quot;;</span><br><span class="line">            Comment com1 = new Comment();</span><br><span class="line">            Comment com2 = new Comment();</span><br><span class="line">            com1.Message = &quot;标题党真讨厌&quot;;</span><br><span class="line">            com2.Message = &quot;到底是人性的扭曲还是。。。。。。&quot;;</span><br><span class="line">            article.Comments.Add(com1);</span><br><span class="line">            article.Comments.Add(com2);</span><br><span class="line">            db.Articles.Add(article);</span><br><span class="line">            db.SaveChanges();</span><br><span class="line">            //有了HasXXX().WithXXX()，就相当于创建了外检关联，EF Core 会自动做好一些配置，不需要以下的写法了</span><br><span class="line">            //Article article = new Article();</span><br><span class="line">            //article.Title = &quot;震惊！母猪为何深夜惨叫&quot;;</span><br><span class="line">            //article.Message = &quot;近日，家在石家庄村里的张老汉发现。。。。。。&quot;;</span><br><span class="line">            //Comment com1 = new Comment();</span><br><span class="line">            //Comment com2 = new Comment();</span><br><span class="line">            //com1.Message = &quot;标题党真讨厌&quot;;</span><br><span class="line">            //com2.Message = &quot;到底是人性的扭曲还是。。。。。。&quot;;</span><br><span class="line">            //com1.TheArticle = article;</span><br><span class="line">            //com2.TheArticle= article;</span><br><span class="line">            //article.Comments.Add(com1);</span><br><span class="line">            //article.Comments.Add(com2);</span><br><span class="line">            //db.Articles.Add(article);</span><br><span class="line">            //db.Comments.Add(com1);</span><br><span class="line">            //db.Comments.Add(com2);</span><br><span class="line">            //db.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要显式为Comment对象的Article属性赋值（赋值也不会错），也不需要显示地把新创建的Comment类型的对象添加到DbContext中。EF Core会“顺杆爬”。</p><h2 id="一对多关系数据的获取"><a href="#一对多关系数据的获取" class="headerlink" title="一对多关系数据的获取"></a>一对多关系数据的获取</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using(var db = new MyDbContext()) &#123;</span><br><span class="line">            Article article1 = db.Articles.Single(e =&gt; e.Id == 1);</span><br><span class="line">            foreach (Comment cmt in article1.Comments) &#123;</span><br><span class="line">                Console.WriteLine(cmt.Message);//这句话没有输出评论，因为生成的Sql语句为以下内容</span><br><span class="line">                //SELECT `t`.`Id`, `t`.`Message`, `t`.`Title` FROM `T_Articles` AS `t` WHERE `t`.`Id` = 1 LIMIT 2</span><br><span class="line">                //没有去Comments表中查数据</span><br><span class="line">            &#125;</span><br><span class="line">            //解决方法如下，添加Include，表示与XXX表进行连接</span><br><span class="line">            Article article2 = db.Articles.Include(e =&gt; e.Comments).Single(e =&gt; e.Id == 1);</span><br><span class="line">            foreach (Comment cmt in article1.Comments) &#123;</span><br><span class="line">                Console.WriteLine(cmt.Message);</span><br><span class="line">            &#125;</span><br><span class="line">            Comment cmt1 = db.Comments.Single(e =&gt; e.Id == 2);</span><br><span class="line">            Console.WriteLine(cmt1.Message);</span><br><span class="line">            Console.WriteLine(cmt1.TheArticle.Id + &quot;,&quot; + cmt1.TheArticle.Title);//错误，与上面同理，没有查询Article表</span><br><span class="line">            Comment cmt2 = db.Comments.Include(e =&gt; e.TheArticle).Single(e =&gt; e.Id == 2);</span><br><span class="line">            Console.WriteLine(cmt2.TheArticle.Id + &quot;,&quot; + cmt2.TheArticle.Title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用Include则不会去关联的表中进行查询。</p><h2 id="额外的外键字段"><a href="#额外的外键字段" class="headerlink" title="额外的外键字段"></a>额外的外键字段</h2><p>EF Core会在数据表中建外键列，如果需要获取外键列的值，就需要做关联查询，效率低，因而需要一种不需要Join直接获取外键列的值的方法。<br>比如：<br>我就想获取评论对应文章的Id，但是我用了Include就会创建一个Join连接的Sql语句，这样没有必要。<br>解决方法：<br>1、在实体类中显示声明一个外键属性<br>2、关系配置中通过HasForeignKey(c&#x3D;&gt;c.ArticleId)显式指定该属性为外键。<br>3、除非必要，否则不用声明，因为会引入重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Comment &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Message &#123; get; set; &#125;</span><br><span class="line">    public Article TheArticle &#123; get; set; &#125;//实体类中关系属性</span><br><span class="line">    public int TheArticleId &#123; get; set; &#125;//显式指定外键</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal class CommentConfig : IEntityTypeConfiguration&lt;Comment&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Comment&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Comments&quot;);</span><br><span class="line">        builder.HasOne&lt;Article&gt;(e =&gt; e.TheArticle).WithMany(e =&gt; e.Comments).HasForeignKey(e =&gt; e.TheArticleId).IsRequired();//FluentAPI关系配置，显式指定外键字段</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Select函数会在必要的情况下自动进行连接查询，所以有了Select就可以不用Include函数了。</p><h1 id="单向导航属性"><a href="#单向导航属性" class="headerlink" title="单向导航属性"></a>单向导航属性</h1><h2 id="双向导航属性的不足"><a href="#双向导航属性的不足" class="headerlink" title="双向导航属性的不足"></a>双向导航属性的不足</h2><p>如上文例子，每一条评论通过TheArticleId可以连接到T_Articles表，每一篇文章可以通过Comments连接到T_Commnets表，这样的导航称为单项导航。<br>如果有一个请假系统，有一个T_UserInfos表记录用户姓名、Id信息，有一个T_Leaves表记录用户请假信息比如：请假人、审批人1、审批人2、审批人3……我们就需要在T_UserInfos表中建立多个字段用来管理审批人123，这样很麻烦，为此我们需要单向导航属性</p><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>不设置反向的属性，在配置的时候WithMany()不设置参数即可<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Leave &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public DateTime Time &#123; get; set; &#125;</span><br><span class="line">    public User Requester &#123; get; set; &#125;//申请人</span><br><span class="line">    public User Approver1 &#123; get; set; &#125;//审批人1</span><br><span class="line">    public User Approver2 &#123; get; set; &#125;//审批人2</span><br><span class="line">    public User Approver3 &#123; get; set; &#125;//审批人3</span><br><span class="line">    public string Remarks &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class User &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserConfig : IEntityTypeConfiguration&lt;User&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;User&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Users&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LeaveConfig : IEntityTypeConfiguration&lt;Leave&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Leave&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Leaves&quot;);</span><br><span class="line">        builder.HasOne&lt;User&gt;(l=&gt;l.Requester).WithMany().IsRequired();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l=&gt;l.Approver1).WithMany();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l =&gt; l.Approver2).WithMany();</span><br><span class="line">        builder.HasOne&lt;User&gt;(l =&gt; l.Approver3).WithMany();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        using(var ctx = new MyDbContext()) &#123;</span><br><span class="line">            var zs = new User &#123; Name = &quot;张三&quot; &#125;;</span><br><span class="line">            var ls = new User &#123; Name =  &quot;李四&quot; &#125;;</span><br><span class="line">            var ww = new User &#123; Name = &quot;王五&quot; &#125;;</span><br><span class="line">            ctx.Users.Add(zs);</span><br><span class="line">            ctx.Users.Add(ls);</span><br><span class="line">            ctx.Users.Add(ww);</span><br><span class="line">            ctx.Leaves.Add(new Leave &#123; Requester=zs,Approver1 = ls,Approver2=ww,Remarks=&quot;看牙&quot;,Time = DateTime.Now,Approver3=ww&#125;);</span><br><span class="line">            ctx.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>对于主从结构的“一对多”表关系，一般声明为双向导航属性。<br>对于其他的“一对多”表关系：如果表属于被很多表引用的基础表，则用单向导航属性，否则可以自由决定是否用双向导航属性。</p><h1 id="自引用组织结构树"><a href="#自引用组织结构树" class="headerlink" title="自引用组织结构树"></a>自引用组织结构树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如果有一个这样的结构，我们该如何处理呢？<br>秋华集团全球总部<br>秋华集团亚太总部<br>秋华集团（中国）<br>秋华集团（新加坡）<br>秋华集团美洲总部<br>秋华集团（美国）<br>秋华集团（加拿大）<br>以上结构我们可以建立自引用组织结构树，具体操作如下<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OrgUnit &#123;</span><br><span class="line">    public long Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public OrgUnit? Parent &#123; get; set; &#125;</span><br><span class="line">    public List&lt;OrgUnit&gt; Children &#123; get; set; &#125; = new List&lt;OrgUnit&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OrgUnitConfig : IEntityTypeConfiguration&lt;OrgUnit&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;OrgUnit&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_OrgUnits&quot;);</span><br><span class="line">        builder.Property(o=&gt;o.Name).IsUnicode().IsRequired().HasMaxLength(50);</span><br><span class="line">        builder.HasOne&lt;OrgUnit&gt;(o =&gt; o.Parent).WithMany(o =&gt; o.Children);//根节点没有Parent所以这个关系不能为不可空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Program.cs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    var orgUnit1 = new OrgUnit &#123; Name = &quot;秋华集团全球总部&quot; &#125;;</span><br><span class="line">    var orgUnit11 = new OrgUnit &#123; Name = &quot;秋华集团亚太总部&quot;, Parent = orgUnit1 &#125;;</span><br><span class="line">    var orgUnit12 = new OrgUnit &#123; Name = &quot;秋华集团美洲总部&quot;, Parent = orgUnit1 &#125;;</span><br><span class="line">    var orgUnit111 = new OrgUnit &#123; Name = &quot;秋华集团（中国）&quot;, Parent = orgUnit11 &#125;;</span><br><span class="line">    var orgUnit112 = new OrgUnit &#123; Name = &quot;秋华集团（新加坡）&quot;, Parent = orgUnit11 &#125;;</span><br><span class="line">    var orgUnit121 = new OrgUnit &#123; Name = &quot;秋华集团（美国）&quot;, Parent = orgUnit12 &#125;;</span><br><span class="line">    var orgUnit122 = new OrgUnit &#123; Name = &quot;秋华集团（加拿大）&quot;, Parent = orgUnit12 &#125;;</span><br><span class="line">    using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit1);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit11);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit12);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit111);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit112);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit121);</span><br><span class="line">        ctx.OrgUnits.Add(orgUnit122);</span><br><span class="line">        ctx.SaveChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里如果只说明某个节点的父节点是XXX，并且ctx.OrgUnits.Add(根节点)是无法做到顺杆爬的，因为无法通过父节点看到自己的子节点，所以采用以上这种方式。</p><h2 id="递归缩进打印"><a href="#递归缩进打印" class="headerlink" title="递归缩进打印"></a>递归缩进打印</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            using (var ctx = new MyDbContext()) &#123;</span><br><span class="line">                var root = ctx.OrgUnits.Single(o =&gt; o.Parent == null);</span><br><span class="line">                PrintChildren(0, ctx, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 缩进打印parent所有的子节点</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;indentLevel&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;dbContext&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;</span><br><span class="line">        static void PrintChildren(int indentLevel,MyDbContext ctx,OrgUnit parent) &#123;</span><br><span class="line">            var children = ctx.OrgUnits.Where(o=&gt;o.Parent==parent).ToList();//找以我为根节点的节点</span><br><span class="line">            foreach (var child in children) &#123;</span><br><span class="line">                Console.WriteLine(new String(&#x27;\t&#x27;, indentLevel) + child.Name);</span><br><span class="line">                PrintChildren(indentLevel + 1, ctx, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> 一对多 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_一些注意事项</title>
      <link href="/2023/11/07/EFCore-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/11/07/EFCore-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h1><h2 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h2><p>1、EF Core支持多种主键生成策略：自动增长、Guid、Hi&#x2F;Lo算法等。<br>2、自动增长优点：简单；缺点：数据库迁移以及分布式系统中比较麻烦；并发性能差。long、int等类型主键，默认是自增的。因为是数据库生成的值，所以SavaChanges后会自动把主键的值更新到Id属性。<br>3、自增字段的代码中不能为Id赋值，必须保持默认值0，否则运行的时候会报错。</p><h2 id="Guid主键"><a href="#Guid主键" class="headerlink" title="Guid主键"></a>Guid主键</h2><p>1、Guid算法（或UUID算法）生成一个全局唯一的Id。适合于分布式系统，在进行多数据库数据合并时很简单。优点：简单、高并发效率比自增主键高、全局唯一；缺点：磁盘空间占用大。<br>2、Guid值不连续。使用Guid类型做主键的时候，不能把主键设置为聚集索引。因为聚集索引是按照顺序保存主键的，因此用Guid做主键性能差。比如MySql的InnoDB引擎中主键是强制使用聚集索引的。有的数据库支持部分的连续Guid，比如SQLServer中的NewSequentialId()，但也不能解决问题。在SQLServer等中，不要把Guid主键设置为聚集索引；在MySQL中，插入频繁的表不要用Guid做主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Guid是结构体，一般不使用new Guid()，当然这样也没问题，但是更推荐以下写法</span><br><span class="line">Guid g = Guid.NewGuid();</span><br></pre></td></tr></table></figure><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>混合自增与Guid（非复合主键）：<br>用自增列做物理的主键，而用Guid列做逻辑上的主键。把自增列设置为表的主键，而在业务上查询数据的时候把Guid当主键使用。在和其他表关联以及和外部系统通讯的时候（比如前端显示数据的标识的时候）都是使用Guid列。不仅保证了性能，而且利用了Guid的优点，减轻了主键自增性导致主键值可被预测带来的安全性问题。<br>Hi&#x2F;Lo算法：<br>EF Core 支持Hi&#x2F;Lo算法来优化自增列。主键值由两部分组成：高位（Hi）和低位（Lo），高位由数据库生成，两个高位之间间隔若干个值，由程序在本地生成低位，低位的值在本地自增生成。不同进程或者集群中不同服务器获取的Hi值不会重复，而本地进程计算的Lo则可以保证可以在本地高效率的生成主键值。但是HiLo算法不是EF Core的标准。</p><h1 id="Migrations"><a href="#Migrations" class="headerlink" title="Migrations"></a>Migrations</h1><h2 id="Migrations原理"><a href="#Migrations原理" class="headerlink" title="Migrations原理"></a>Migrations原理</h2><p>1、使用迁移脚本，可以对当前连接的数据库执行编号更高的迁移，这个操作叫做“向上迁移”（Up），也可以执行把数据库回退到旧的迁移，这个操作叫“向下迁移”（Down）。<br>2、除非有特殊需要，否则不要删除Migrations文件夹下的代码。<br>3、在Migrations文件夹下的文件记录着每个操作事件的Up和Down操作。<br>4、数据库的__EFMigrationsHistory表：记录当前数据库曾经应用过的迁移脚本，按顺序排列。</p><h2 id="Migrations其他命令"><a href="#Migrations其他命令" class="headerlink" title="Migrations其他命令"></a>Migrations其他命令</h2><p>1、Updata-Database XXX<br>把数据库升级&#x2F;回滚到XXX的状态，迁移脚本不动。<br>2、Remove-Migration<br>删除最后一次的迁移脚本。<br>3、Script-Migration<br>生成迁移SQL代码。因为Updata-Database对数据可的操作没有直接的Sql代码清晰，可以通过该语句直观看到对数据库的操作。<br>4、Script-Migration D F<br>生成版本D到版本F的SQL脚本。<br>5、Script-Migration D<br>生成版本D到最新版本的SQL脚本。</p><h1 id="反向工程"><a href="#反向工程" class="headerlink" title="反向工程"></a>反向工程</h1><p>通过数据库表来反向生成实体类：<br>程序包管理控制台输入<br>Scaffold-DbContext “Server&#x3D;.;Database&#x3D;demo1;Trusted_Connection&#x3D;True;MultipleActiveResultSets&#x3D;true” Microsoft.EntityFrameworkCore.SqlServer</p><p>如果已经生成了一个实体类，但是想再在数据库中再增加一个实体类需要加一个参数 -Force：<br>Scaffold-DbContext “Server&#x3D;.;Database&#x3D;demo1;Trusted_Connection&#x3D;True;MultipleActiveResultSets&#x3D;true” Microsoft.EntityFrameworkCore.SqlServer -Force</p><h1 id="通过代码查看EF-Core生成的Sql语句"><a href="#通过代码查看EF-Core生成的Sql语句" class="headerlink" title="通过代码查看EF Core生成的Sql语句"></a>通过代码查看EF Core生成的Sql语句</h1><p>1、标准日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    public class MyDbContext:DbContext &#123;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">        public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">        private static ILoggerFactory loggerFactory = LoggerFactory.Create(b=&gt;b.AddConsole());</span><br><span class="line">        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">            base.OnConfiguring(optionsBuilder);</span><br><span class="line">            optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);</span><br><span class="line">            optionsBuilder.UseLoggerFactory(loggerFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">            base.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、简单日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    public class MyDbContext:DbContext &#123;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">        public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">            base.OnConfiguring(optionsBuilder);</span><br><span class="line">            optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);</span><br><span class="line">            optionsBuilder.LogTo(msg=&gt; &#123;</span><br><span class="line">                Console.WriteLine(msg);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">            base.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、ToQueryString方法<br>上面两种方式无法直接得到一个操作的SQL语句，而且在操作很多的情况下容易混乱。<br>EF Core的Where方法返回的而是IQueryable类型，DbSet也实现了IQueryable接口。IQueryable有拓展方法ToQueryString()可以获得转换后的SQL语句。<br>不需要真的执行查询才获取SQL语句；只能获取查询操作的SQL语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace Interview &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            using(var db = new MyDbContext()) &#123;</span><br><span class="line">                IQueryable&lt;Book&gt; books = db.Books.Where(e =&gt; e.money &gt; 30);</span><br><span class="line">                foreach(var book in books) &#123;</span><br><span class="line">                    Console.WriteLine(book.name);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(books.ToQueryString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、总结<br>写测试性代码，用简单日志；正式需要记录SQL给审核人员或者排查故障，用标准日志；开发阶段，从繁杂的查询操作中立即看到SQL，用ToQueryString()。</p><h1 id="同样的Linq被翻译成不同的SQL语句"><a href="#同样的Linq被翻译成不同的SQL语句" class="headerlink" title="同样的Linq被翻译成不同的SQL语句"></a>同样的Linq被翻译成不同的SQL语句</h1><p>数据库迁移脚本不能跨数据库，因为各个数据库的建表语句或者创建字段语句不一样。可以通过给Add-Migration命令添加“-OutputDir”参数的形式来在同一项目中为不同的数据库生成不同的迁移脚本。<br>由于各个数据库的查询、函数、自增等语法不同，在不同的EF Provider中相同的语法有可能产生不同的SQL语句。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> Migrations </tag>
            
            <tag> 反向工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_FluentAPI</title>
      <link href="/2023/10/29/EFCore-FluentAPI/"/>
      <url>/2023/10/29/EFCore-FluentAPI/</url>
      
        <content type="html"><![CDATA[<h1 id="约定配置"><a href="#约定配置" class="headerlink" title="约定配置"></a>约定配置</h1><p>主要规则：<br>1、表明采用DbContext中对应DbSet的属性名。<br>2、数据表列的名字采用实体类属性的名字，列的数据类型采用和实体类属性类型最兼容的类型。<br>3、数据表列的可空性取决于对应实体类属性的可空性。<br>4、名字为Id 的属性为主键，如果主键为short、int、long类型，则默认采用自增字段，如果主键为Guid类型，则默认采用默认的Guid生成机制生成主键值。</p><h1 id="两种配置方式"><a href="#两种配置方式" class="headerlink" title="两种配置方式"></a>两种配置方式</h1><h2 id="1、Data-Annotation"><a href="#1、Data-Annotation" class="headerlink" title="1、Data Annotation"></a>1、Data Annotation</h2><p>把配置以特性（Annotation）的形式标注在实体类中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Table(&quot;T_Perosns&quot;)]</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public int id &#123; get; set; &#125;</span><br><span class="line">    [Required()]</span><br><span class="line">    [MaxLength(100)]</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public string sex &#123; get; set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单<br>缺点：耦合</p><h2 id="2、Fluent-API"><a href="#2、Fluent-API" class="headerlink" title="2、Fluent API"></a>2、Fluent API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PersonEntityConfig : IEntityTypeConfiguration&lt;Person&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Person&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Persons&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：解耦<br>缺点：复杂<br>两种方法大部分功能重叠可以混用，但是不建议，混用优先级：FluentAPI&gt;Data Annotation&gt;约定</p><h1 id="Fluent-API"><a href="#Fluent-API" class="headerlink" title="Fluent API"></a>Fluent API</h1><p>1、视图与实体类映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Blog&gt;().ToView(&quot;blogsView&quot;);</span><br></pre></td></tr></table></figure><p>2、排除属性映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Ignore(e=&gt;e.name2);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().Ignore(b=&gt;b.name2);</span><br></pre></td></tr></table></figure><p>3、配置列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.BlogId).HasColumnName(&quot;blog_id&quot;);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().Property(b=&gt;b.BlogId).HasColumnName(&quot;blog_id&quot;);</span><br></pre></td></tr></table></figure><p>4、配置列数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.BlogId).HasColumnType(&quot;blog_id&quot;);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().Property(b=&gt;b.BlogId).HasColumnType(&quot;blog_id&quot;);</span><br></pre></td></tr></table></figure><p>5、配置主键：<br>默认把名字为Id或者“实体类型+Id”的属性作为主键，可以用HasKey()来配置其他属性作为主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.HasKey(c=&gt;c.Number);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().HasKey(c=&gt;c.Number);</span><br></pre></td></tr></table></figure><p>支持复合主键，但是不建议使用。<br>6、生成列的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.Number).ValueGeneratedOnAdd();</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(b=&gt;b.Number).ValueGeneratedOnAdd();</span><br></pre></td></tr></table></figure><p>7、可以用HasDefaultValue()为属性设定默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.Property(b=&gt;b.Age).HasDefaultValue(6);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(b=&gt;b.Age).HasDefaultValue(6);</span><br></pre></td></tr></table></figure><p>8、<br>索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.HasIndex(b=&gt;b.Url);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Blog&gt;().HasIndex(b=&gt;b.Url);</span><br></pre></td></tr></table></figure><p>符合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//配置类写法：</span><br><span class="line">builder.HasIndex(p=&gt;new &#123;p.FirstName,p.LastName&#125;);</span><br><span class="line">//DbContext类写法：</span><br><span class="line">modelBuilder.Entity&lt;Person&gt;().HasIndex(p=&gt;new &#123;p.FirstName,p.LastName&#125;);</span><br></pre></td></tr></table></figure><p>唯一索引：IsUnique()<br>聚集索引：IsClustered()<br>9、<br>用EF Core太多高级特性的时候谨慎，尽量不要和业务逻辑混合在一起，以免“不能自拔”。比如Ignore、Shadow、Table Splitting等</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
            <tag> Fluent API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore_简单使用</title>
      <link href="/2023/10/28/EFCore-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/28/EFCore-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="EFCore简介"><a href="#EFCore简介" class="headerlink" title="EFCore简介"></a>EFCore简介</h1><p>ORM：让开发者用对象操作的形式操作关系型数据库。<br>EFCore、Dapper就是常见的ORM</p><p>应用程序通过EF Core将C#代码变成Sql语句借助Ado.Net Core与数据库进行操作。</p><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>1、对于后台系统、信息系统等和数据库相关开发工作量大的系统，且团队比较稳定就用EFCore；对于互联网系统等数据库相关工作量不大的系统，或者团队不稳定就用Dapper<br>2、在项目中可以混用，只要注意EFCore的缓存、Tracking等问题即可。</p><h2 id="EFCore和EF比较"><a href="#EFCore和EF比较" class="headerlink" title="EFCore和EF比较"></a>EFCore和EF比较</h2><p>1、EF有DB First、Model First、Code First。EFCore不支持模型优先，推荐使用代码优先，遗留系统可以使用Scaffold DbContext来生成代码实现类似DB First的效果，但是推荐使用Code First。<br>2、EF会对实体上的标注做校验，EF Core追求轻量化，不校验。<br>3、EFCore加了很多新东西。<br>4、EF中的一些类的命名空间以及一些方法的名字在EF Core中稍有不同。<br>5、EF不再做新特性增加。<br>6、EF Core是对底层ADO.NET Core的封装，因此ADO.NET Core支持的数据库不一定被EF Core支持。</p><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>安装：Microsoft.EntityFrameworkCore.SqlServer或其他用来使用不同的数据库。<br>1、建数据实体类比如Book，Person等。<br>2、建实现IEntityTypeConfiguration&lt;T&gt;接口的配置类，用来配置数据对应哪张表，T为实体类。<br>3、建继承DbContext的类，里面有一个或多个Dbset&lt;T&gt;属性用来声明这个数据库里面有几个表，T为实体类。该类有OnConfiguring方法用于使用数据库连接语句，还有OnModelCreating方法用于告诉EF Core数据库配置类从何处获取（一般为当前程序集）。<br>为了方便对应杨中科老师的教程，我将使用SqlServer进行演示，如果想使用MySql可以看之前几篇博客。<br>实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    public int id &#123; get; set; &#125;</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public double money &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public int id &#123; get; set; &#125;</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public string sex &#123; get; set;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BookEntityConfig : IEntityTypeConfiguration&lt;Book&gt; &#123;</span><br><span class="line">public void Configure(EntityTypeBuilder&lt;Book&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Books&quot;);</span><br><span class="line">        builder.Property(e=&gt;e.name).HasMaxLength(50).IsRequired();//设置书名最大长度50，不允许为空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class PersonEntityConfig : IEntityTypeConfiguration&lt;Person&gt; &#123;</span><br><span class="line">    public void Configure(EntityTypeBuilder&lt;Person&gt; builder) &#123;</span><br><span class="line">        builder.ToTable(&quot;T_Persons&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DbContext类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyDbContext:DbContext &#123;</span><br><span class="line">    public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">        base.OnConfiguring(optionsBuilder);</span><br><span class="line">        optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        base.OnModelCreating(modelBuilder);</span><br><span class="line">        modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Migration数据库迁移"><a href="#Migration数据库迁移" class="headerlink" title="Migration数据库迁移"></a>Migration数据库迁移</h2><p>安装：Microsoft.EntityFrameworkCore.Tools。<br>面向对象的ORM开发中，数据库不是程序员手动创建的，而是Migration工具生成的。关系型数据库只是盛放模型数据的一个媒介而已，理想状态下，程序员不用关心数据库的操作。<br>根据对象的定义变化，自动更新数据库中的表以及表结构的操作叫做Migration（迁移）<br>迁移可以分为多步（项目进化），也可以回滚。<br>1、在程序包管理器控制台中执行：<br>Add-Migration 操作名<br>会自动在项目的Migrations文件夹中生成操作数据库的C#代码。<br>2、代码需要执行后才会应用对数据库的操作，所以程序不能有错误。在程序包管理器控制台中执行：<br>Updata-database</p><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>配置类不是必须的，在EF Core中有约定大于配置的规则，会默认生成一个隐藏的配置类，如果想更改表名或者对某字段有进一步配置可以自己添加配置类。</p><h1 id="EF-Core进行增删改查"><a href="#EF-Core进行增删改查" class="headerlink" title="EF Core进行增删改查"></a>EF Core进行增删改查</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        using(var db = new MyDbContext()) &#123;</span><br><span class="line">            //1、增</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;ES6标准入门&quot;, money = 57.5 &#125;);</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;C#图解教程&quot;, money = 69 &#125;);</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;单片微机原理&quot;, money = 30 &#125;);</span><br><span class="line">            db.Books.Add(new Book &#123; name = &quot;深入浅出NodeJS&quot;, money = 44 &#125;);</span><br><span class="line">            await db.SaveChangesAsync();//相当于Updata-Database</span><br><span class="line">            //2、删</span><br><span class="line">            var b = db.Books.Single(e =&gt; e.name == &quot;C#图解教程&quot;);</span><br><span class="line">            db.Books.Remove(b);</span><br><span class="line">            await db.SaveChangesAsync();</span><br><span class="line">            //3、改</span><br><span class="line">            var  b2 = db.Books.Single(e =&gt; e.name == &quot;深入浅出NodeJS&quot;);</span><br><span class="line">            b2.name = &quot;JAVA核心技术卷一&quot;;</span><br><span class="line">            await db.SaveChangesAsync();</span><br><span class="line">            //4、查</span><br><span class="line">            IQueryable&lt;Book&gt; books = db.Books.Where(e =&gt; e.money &gt; 30);</span><br><span class="line">            foreach(var book in books) &#123;</span><br><span class="line">                Console.WriteLine(book.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前的删除、修改数据需要先查出来，性能低，在.NET7退出了比较高效的修改、删除的操作，详细操作可以查看官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> EFCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> EFCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_SignalR</title>
      <link href="/2023/09/18/Asp.NetCore-SignalR/"/>
      <url>/2023/09/18/Asp.NetCore-SignalR/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>需求：Web聊天、站内通知<br>传统HTTP只能客户端主动发送请求<br>传统长轮询方式性能差，不推荐使用<br>基于Tcp协议，支持二进制通信，双工通信<br>性能和并发能力强<br>WebSocket独立于HTTP协议，不过我们一般仍然把WebSocket服务器端部署到Web服务器，因为可以借助HTTP协议完成初始的握手（可选），并且共享HTTP服务器的端口（主要），通过请求的特点决定将请求交给HTTP处理程序或者WebSocket处理程序。</p><h1 id="ASP-NET-Core-SignalR"><a href="#ASP-NET-Core-SignalR" class="headerlink" title="ASP.NET Core SignalR"></a>ASP.NET Core SignalR</h1><p>1、SignalR是对.NET Core平台下对WebSocket的封装<br>2、Hub（集线器）类似于路由器，是数据交换中心</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建web api项目，创建一个继承Hub的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyHub : Hub&#123;</span><br><span class="line">//这个方法名由客户端调用</span><br><span class="line">    public Task SendPublicMsgAsync(string msg) &#123;</span><br><span class="line">        string connId = this.Context.ConnectionId;</span><br><span class="line">        string msgToSend = $&quot;&#123;connId&#125; &#123;DateTime.Now&#125;：&#123;msg&#125;&quot;;</span><br><span class="line">        //双方规定好用&quot;PublicMsgReceived&quot;作为消息名，在前端会有名为&quot;PublicMsgReceived&quot;的事件</span><br><span class="line">        return this.Clients.All.SendAsync(&quot;PublicMsgReceived&quot;, msgToSend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.AddSignalR();</span><br><span class="line">//记得允许跨域</span><br><span class="line">builder.Services.AddCors(options =&gt; &#123;</span><br><span class="line">    options.AddDefaultPolicy(</span><br><span class="line">        policy =&gt; &#123;</span><br><span class="line">            policy.WithOrigins(&quot;http://127.0.0.1:5173&quot;)</span><br><span class="line">                                .AllowAnyHeader()</span><br><span class="line">                                .AllowAnyMethod()</span><br><span class="line">                                .AllowCredentials();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">app.UseCors();</span><br><span class="line">app.UseAuthorization();</span><br><span class="line">app.MapHub&lt;MyHub&gt;(&quot;/MyHub&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//前端代码</span><br><span class="line">//记得npm下载npm i @microsoft/signalr</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;reactive,onMounted&#125; from &#x27;vue&#x27;;</span><br><span class="line">import * as signalR from &#x27;@microsoft/signalr&#x27;;</span><br><span class="line">export default&#123;</span><br><span class="line">setup()&#123;</span><br><span class="line">let connection;</span><br><span class="line">const state = reactive(&#123;userMsg:&quot;&quot;,message:[]&#125;);</span><br><span class="line">const textMsgOnKeyPress = async function(e)&#123;</span><br><span class="line">if(e.keyCode!=13) return;</span><br><span class="line">//参数1：调用的signalR方法名，参数2：传递的参数</span><br><span class="line">await connection.invoke(&quot;SendPublicMsgAsync&quot;,state.userMsg);</span><br><span class="line">state.userMsg = &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">onMounted(async()=&gt;&#123;</span><br><span class="line">connection = new signalR.HubConnectionBuilder()</span><br><span class="line">.withUrl(&quot;https://localhost:7020/MyHub&quot;)</span><br><span class="line">.withAutomaticReconnect()</span><br><span class="line">.build();</span><br><span class="line">await connection.start();</span><br><span class="line">//参数1：约定的消息名，参数2：回调</span><br><span class="line">connection.on(&quot;PublicMsgReceived&quot;,rcvMsg=&gt;&#123;</span><br><span class="line">state.message.push(rcvMsg);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">return &#123;state,textMsgOnKeyPress&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;state.userMsg&quot; v-on:keypress=&quot;textMsgOnKeyPress&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;(msg,index) in state.message&quot; :key=&quot;index&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="协议协商"><a href="#协议协商" class="headerlink" title="协议协商"></a>协议协商</h2><p>signalR不仅支持WebSocket还支持ServerSent Events、长轮询。<br>浏览器会先使用http请求通过nagotiate告诉服务器自己支持哪种方式，默认按照WebSocket、ServerSent Events、长轮询的顺序尝试。<br>IE浏览器支持WebSocket但signalR的javascript客户端不支持IE浏览器。</p><h2 id="协商带来的问题"><a href="#协商带来的问题" class="headerlink" title="协商带来的问题"></a>协商带来的问题</h2><p>1、集群中协议协商的问题：“协商”请求被服务器A处理，但接下来建立WebSocket请求却被服务器B处理。<br>2、解决方法：粘性会话和禁用协商。<br>3、“粘性会话”：把来自同一客户端的请求都转发到同一服务器上。缺点：因为共享公网IP等造成请求无法被平均的分配到服务器集群；扩容的自适应性不强。<br>4、“禁用协商”：直接向服务器发送WebSocket请求，WebSocket一旦建立，就形成了服务器和客户端持久连接的通道，在该连接中的后续往返WebSocket通信都是由同一台服务器处理。缺点：无法降级到ServerSent Events和长轮询，但是问题不大。<br>5、如果需要使用禁用协商，请参考微软文档，在javascript创建WebSocket时传入所需的配置项。</p><h2 id="SignalR的分布式部署"><a href="#SignalR的分布式部署" class="headerlink" title="SignalR的分布式部署"></a>SignalR的分布式部署</h2><p>问题：如果客户端连接到了不同的服务器，那么通过SignalR发送的消息很可能因为服务器不同的原因而接受不到。<br>解决方案：分布式部署，所有服务器连接到同一个消息中间件。在粘性会话或者禁用协商的模式下，分布式部署才有意义。<br>Nuget：安装Microsoft.AspNetCore.SignalR.StackExchangeRedis。<br>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSignalR().AddStackExchangeRedis(&quot;127.0.0.1&quot;, opt =&gt; &#123;</span><br><span class="line">    opt.Configuration.ChannelPrefix = &quot;localhost1_&quot;;//避免数据混乱，添加前缀</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="SignalR的身份认证"><a href="#SignalR的身份认证" class="headerlink" title="SignalR的身份认证"></a>SignalR的身份认证</h1><p>敬请期待</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> WebSocket </tag>
            
            <tag> SignalR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_校验机制</title>
      <link href="/2023/09/15/Asp.NetCore-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/09/15/Asp.NetCore-%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="校验机制"><a href="#校验机制" class="headerlink" title="校验机制"></a>校验机制</h1><h2 id="Net-Core内置"><a href="#Net-Core内置" class="headerlink" title=".Net Core内置"></a>.Net Core内置</h2><p>1、在.Net Core中内置了对数据校验的支持，在System.ComponentModel.DataAnnotations这个命名空间下有如：[Required]、[EamilAddress]、[RegularExpression]。CustomValidationAttribute、IValidatableObject。<br>2、内置的校验机制的问题：校验规则都是和模型类耦合在一起，违反“单一职责原则”，很多常用的校验都需要编写自定义校验规则，而且写起来麻烦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DataTest &#123;</span><br><span class="line">        [Required]</span><br><span class="line">        public string UserName &#123; get; set; &#125;</span><br><span class="line">        public string Password &#123; get; set; &#125;</span><br><span class="line">        [EmailAddress]</span><br><span class="line">        public string Email &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第三方包（FluentValidation）"><a href="#第三方包（FluentValidation）" class="headerlink" title="第三方包（FluentValidation）"></a>第三方包（FluentValidation）</h2><p>1、用类似于EF Core中Fluent API的方式进行校验规则的 配置，也就是我们可以把对模型类的校验放到单独的校验类中<br>2、NuGet安装：<br>FluentValidation.AspNetCore<br>3、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.AddFluentValidation(opt =&gt; &#123;</span><br><span class="line">    opt.RegisterValidatorsFromAssembly(Assembly.GetExecutingAssembly());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//请求实体类</span><br><span class="line">   public class AddNewUserRequest &#123;</span><br><span class="line">        public string UserName &#123; get; set; &#125;</span><br><span class="line">        public string Password &#123; get; set; &#125;</span><br><span class="line">        public string Email &#123; get; set; &#125;</span><br><span class="line">        public string Password2 &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//请求校验类</span><br><span class="line">    public class AddNewUserRequestValidator :AbstractValidator&lt;AddNewUserRequest&gt; &#123;</span><br><span class="line">        public AddNewUserRequestValidator() &#123;</span><br><span class="line">            RuleFor(x =&gt; x.Email).NotNull().EmailAddress().WithMessage(&quot;密码不合法&quot;).Must(x=&gt;x.EndsWith(&quot;@163.com&quot;)||x.EndsWith(&quot;@qq.com&quot;)).WithMessage(&quot;只支持163或者qq邮箱&quot;);</span><br><span class="line">            RuleFor(x =&gt; x.UserName).NotNull().Length(6, 10);</span><br><span class="line">            RuleFor(x =&gt; x.Password).Equal(x =&gt; x.Password2).WithMessage(&quot;两次密码不一致&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FluentValidation支持从构造函数依赖注入。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> 校验机制 </tag>
            
            <tag> FluentValidation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_托管服务</title>
      <link href="/2023/09/15/Asp.NetCore-%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/09/15/Asp.NetCore-%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="托管服务"><a href="#托管服务" class="headerlink" title="托管服务"></a>托管服务</h1><p>1、让代码运行在后台。比如服务器启动的时候在后台预先加载数据到缓存，每天凌晨三点把数据导出到备份数据库，每五秒在两张表之间同步一次数据。<br>2、托管服务实现IHostedService接口，一般编写从BackgroundService继承的类。<br>3、services.AddHostedService&lt;DemoBgService&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HostedService1 : BackgroundService &#123;</span><br><span class="line">        protected override async Task ExecuteAsync(CancellationToken stoppingToken) &#123;</span><br><span class="line">        //在这里面执行后台代码</span><br><span class="line">            Console.WriteLine(&quot;后台启动&quot;);</span><br><span class="line">            await Task.Delay(3000);</span><br><span class="line">            Console.WriteLine(&quot;后台代码执行完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.AddHostedService&lt;HostedService1&gt;();</span><br></pre></td></tr></table></figure><p>如果文件中发生异常：<br>1、程序会自动停止或退出。可以把HostOptions.BackgroundServiceExceptionBehavior设置为Ignore，程序会忽略异常，而不是停止程序，不过不推荐采用默认的设置。<br>2、起码应该用try…catch…包裹一下。<br>使用DI：<br>1、托管服务是以单例的生命周期注册到依赖注入容器中，因此不能注入生命周期为范围或者瞬态的服务，比如注入EFCore上下文的话，程序就会抛异常。<br>2、可以通过构造方法中注入一个IServiceScopeFactory，它可以用来创建一个IServiceScope对象，这样我们就可以通过IServiceScope来创建短生命周期的服务了。记得在Dispose中释放IServiceScope</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//HostedService</span><br><span class="line"> public class HostedService1 : BackgroundService &#123;</span><br><span class="line">        private readonly IServiceScope serviceScope;</span><br><span class="line">        public HostedService1(IServiceScopeFactory factory) &#123;</span><br><span class="line">            this.serviceScope = factory.CreateScope();</span><br><span class="line">        &#125;</span><br><span class="line">        public override void Dispose() &#123;</span><br><span class="line">            this.serviceScope.Dispose();</span><br><span class="line">            base.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        protected override async Task ExecuteAsync(CancellationToken stoppingToken) &#123;</span><br><span class="line">            var scopeTest  = serviceScope.ServiceProvider.GetRequiredService&lt;ScopeTest&gt;();</span><br><span class="line">            scopeTest.Say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Progrom.cs</span><br><span class="line">builder.Services.AddScoped&lt;ScopeTest&gt;();</span><br><span class="line">builder.Services.AddHostedService&lt;HostedService1&gt;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> 托管服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_JWT</title>
      <link href="/2023/09/15/Asp.NetCore-JWT/"/>
      <url>/2023/09/15/Asp.NetCore-JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="Session描述"><a href="#Session描述" class="headerlink" title="Session描述"></a>Session描述</h2><p>在浏览器端用户登录后，服务器端生成唯一session id，并且把用户名和session id建立对应关系保存到服务器端，当下次浏览器端访问时携带着cookie和服务器保存session对应，就可以直接登录了。</p><h2 id="Session缺点"><a href="#Session缺点" class="headerlink" title="Session缺点"></a>Session缺点</h2><p>1、对于分布式集群环境，session数据保存在服务器内存中就不合适了，应该放到一个中心状态服务器上。ASP.NET Core支持Session采用Redis、Memcached。<br>2、中心状态服务器有性能问题。</p><h2 id="JWT描述"><a href="#JWT描述" class="headerlink" title="JWT描述"></a>JWT描述</h2><p>1、JWT把登陆信息保存在客户端。<br>2、为了防止客户端数据造假，保存在客户端的令牌经过了签名处理，而签名的密钥只有服务器端才知道，每次服务器端收到客户端提交过来的令牌的时候都要检查一下签名。<br>3、JWT是明文存储的，不要把不能被客户端知道的信息放到JWT中。<br><img src="/images/ASP.NETCore%E9%AB%98%E7%BA%A7%E7%AF%87/1.jpg"></p><h2 id="JWT优点"><a href="#JWT优点" class="headerlink" title="JWT优点"></a>JWT优点</h2><p>1、状态保存在客户端，天然适合分布式签名。<br>2、签名保证了客户端无法数据造假。<br>3、性能更高，不需要和中心状态服务器通讯，纯内存计算。</p><h2 id="JWT基本使用"><a href="#JWT基本使用" class="headerlink" title="JWT基本使用"></a>JWT基本使用</h2><p>NuGet安装：<br>System.IdentityModel.Token，生成和校验JWT<br>生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// See https://aka.ms/new-console-template for more information</span><br><span class="line">using Microsoft.IdentityModel.Tokens;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.IdentityModel.Tokens.Jwt;</span><br><span class="line">using System.Security.Claims;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">List&lt;Claim&gt; claims = new List&lt;Claim&gt;();//一个claim代表一条用户信息，尽量使用ClaimTypes的值</span><br><span class="line">claims.Add(new Claim(&quot;Passport&quot;, &quot;123456&quot;));</span><br><span class="line">claims.Add(new Claim(&quot;QQ&quot;, &quot;8888888888&quot;));</span><br><span class="line">claims.Add(new Claim(&quot;Id&quot;, &quot;6666&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.NameIdentifier, &quot;11111 &quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.Name, &quot;LJH&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.HomePhone, &quot;8364799655&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.Role, &quot;admin&quot;));</span><br><span class="line">claims.Add(new Claim(ClaimTypes.Role, &quot;manager&quot;));</span><br><span class="line">string key = &quot;suibianshurudiandongxi,jinliangchangyidian&quot;;//签名的key，不能泄露</span><br><span class="line">DateTime expire = DateTime.Now.AddHours(1);//过期时间</span><br><span class="line">byte[] secBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">var secKey = new SymmetricSecurityKey(secBytes);</span><br><span class="line">var credentials = new SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">var tokenDescriptor = new JwtSecurityToken(claims: claims,</span><br><span class="line">    expires: expire, signingCredentials: credentials);</span><br><span class="line">string jwt = new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);//JWT令牌</span><br><span class="line">Console.WriteLine(jwt);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//调用JwtSecurityTokenHandler类对JWT令牌进行解码</span><br><span class="line"></span><br><span class="line">using Microsoft.IdentityModel.Tokens;</span><br><span class="line">using System.IdentityModel.Tokens.Jwt;</span><br><span class="line">using System.Security.Claims;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">string jwt = Console.ReadLine()!;</span><br><span class="line">string secKey = &quot;suibianshurudiandongxi,jinliangchangyidian&quot;;</span><br><span class="line">JwtSecurityTokenHandler tokenHandler = new();</span><br><span class="line">TokenValidationParameters valParam = new();</span><br><span class="line">var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secKey));</span><br><span class="line">valParam.IssuerSigningKey = securityKey;</span><br><span class="line">valParam.ValidateIssuer = false;</span><br><span class="line">valParam.ValidateAudience = false;</span><br><span class="line">//不合法的key生成的jwt或者篡改过的jwt就会报错</span><br><span class="line">ClaimsPrincipal claimsPrincipal = tokenHandler.ValidateToken(jwt,</span><br><span class="line">valParam, out SecurityToken secToken);</span><br><span class="line">foreach (var claim in claimsPrincipal.Claims) &#123;</span><br><span class="line">Console.WriteLine($&quot;&#123;claim.Type&#125;=&#123;claim.Value&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ASP-NETCore对JWT的封装"><a href="#ASP-NETCore对JWT的封装" class="headerlink" title="ASP.NETCore对JWT的封装"></a>ASP.NETCore对JWT的封装</h2><p>NuGet安装：<br>1、Microsoft.AspNetCore.Authentication.JwtBearer<br>2、配置JWT节点，在appsettings.json下创建SecKey（密钥）、ExpireSeconds（过期时间），再创建配置类JWTSettings，包含SecKey、ExpireSeconds属性。<br>3、对JWT进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//appsetting.json</span><br><span class="line">&quot;JWT&quot;: &#123;</span><br><span class="line">    &quot;SecKey&quot;: &quot;asjdofiwengwieh*audsh&amp;sdy$&quot;,</span><br><span class="line">    &quot;ExpireSeconds&quot;: &quot;3600&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class JWTSettings &#123;</span><br><span class="line">      public string SecKey &#123; get;set; &#125;</span><br><span class="line">      public int ExpireSeconds &#123; get; set; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.Configure&lt;JWTSettings&gt;(builder.Configuration.GetSection(&quot;JWT&quot;));</span><br><span class="line">builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">    .AddJwtBearer(opt =&gt; &#123;</span><br><span class="line">        var jwtSettings = builder.Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTSettings&gt;();</span><br><span class="line">        byte[] keyBytes = Encoding.UTF8.GetBytes(jwtSettings.SecKey);</span><br><span class="line">        var secKey = new SymmetricSecurityKey(keyBytes);</span><br><span class="line">        opt.TokenValidationParameters = new() &#123;</span><br><span class="line">            ValidateIssuer = false,</span><br><span class="line">            ValidateAudience = false,</span><br><span class="line">            ValidateLifetime = true,</span><br><span class="line">            ValidateIssuerSigningKey = true,</span><br><span class="line">            IssuerSigningKey = secKey</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...............</span><br><span class="line">    app.UseAuthentication();//在app.UseAuthorization();前使用中间件</span><br><span class="line"></span><br><span class="line">    app.UseAuthorization();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Demo1Controller</span><br><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class Demo1Controller : ControllerBase &#123;</span><br><span class="line">        private readonly IOptionsSnapshot&lt;JWTSettings&gt; jwtSettings;</span><br><span class="line"></span><br><span class="line">        public DemoController(IOptionsSnapshot&lt;JWTSettings&gt; jwtSettings) &#123;</span><br><span class="line">            this.jwtSettings = jwtSettings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        //用户登录，返回jwt</span><br><span class="line">        public ActionResult&lt;string&gt; Login(string userName,string password) &#123;</span><br><span class="line">            if(userName == &quot;LJH&quot; &amp;&amp; password == &quot;123456&quot;) &#123;</span><br><span class="line">                List&lt;Claim&gt; claims = new List&lt;Claim&gt;();</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.NameIdentifier,&quot;1&quot;));</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.Name, userName));</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.Role, &quot;admin&quot;));</span><br><span class="line">                string key = jwtSettings.Value.SecKey;</span><br><span class="line">                DateTime expires = DateTime.Now.AddSeconds(jwtSettings.Value.ExpireSeconds);</span><br><span class="line">                byte[] secBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">                var secKey = new SymmetricSecurityKey(secBytes);</span><br><span class="line">                var credentials = new SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">                var tokenDescriptor = new JwtSecurityToken(claims: claims,</span><br><span class="line">                    expires: expires, signingCredentials: credentials);</span><br><span class="line">                string jwt = new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);</span><br><span class="line">                return jwt;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return BadRequest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;[controller]/[Action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    [Authorize]//该控制下所有action都需要登录才能访问</span><br><span class="line">    public class Demo2Controller : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test1() &#123;</span><br><span class="line">            var claim = this.User.FindFirst(ClaimTypes.Name);//可通过这个方式从jwt字符串的payload中解析并获取当前登录用户的用户名</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [AllowAnonymous]//有这个特性，不登录也可调用该action</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test2() &#123;</span><br><span class="line">            return &quot;666&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [Authorize(Roles = &quot;admin&quot;)]//角色为admin的才可以访问这个action</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test3() &#123;</span><br><span class="line">            return &quot;888&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在需要登录才能访问的控制器或者Action上添加[Authorize]。<br>客户端发送请求时在请求头中携带Authorization的值为”Bearer JWTToken”（JWTToken为生成的jwt）给服务器，就会自动判断是否登录，注意Bearer和jwtToken中间有空格，前后不能多出来额外的空格、换行等。</p><h2 id="Authorize-的注意事项"><a href="#Authorize-的注意事项" class="headerlink" title="[Authorize]的注意事项"></a>[Authorize]的注意事项</h2><p>1、ASP.NET Core中身份验证和授权验证的功能由Authentication、Authorization中间件提供：app.UseAuthentication()、app.UseAuthorization()。<br>2、控制器类上标注了[Authorize]，则所有操作方法都会被进行身份验证和授权验证；对于标注了[Authorize]的控制器中，如果其中某个操作方法不想被验证，可以在操作方法上添加[AllowAnonymous]。action上标注[Authorize]，则该action需要被验证才可以。<br>3、除了简单的[Authorize]验证，我们也可以对jwt的内容比如身份进行进一步验证，需要客户端发送jwt时携带需要验证的内容，在action或者controller类加上[Authorize(Roles &#x3D; “admin”)]特性即可。<br>4、ASP.NET Core会按照http协议的规范，从Authorization取出令牌，并且进行校验、解析，然后把解析结果填充到User属性中，这一切都由ASP.NET Core完成，不需要开发人员编写，但是一旦出现401，没有详细的报错信息，很难排查。</p><h2 id="Swagger携带JWT报文头"><a href="#Swagger携带JWT报文头" class="headerlink" title="Swagger携带JWT报文头"></a>Swagger携带JWT报文头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var scheme = new OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = &quot;Authorization header. \r\nExample: &#x27;Bearer 12345abcdef&#x27;&quot;,</span><br><span class="line">        Reference = new OpenApiReference&#123;Type = ReferenceType.SecurityScheme,</span><br><span class="line">            Id = &quot;Authorization&quot;&#125;,</span><br><span class="line">        Scheme = &quot;oauth2&quot;,Name = &quot;Authorization&quot;,</span><br><span class="line">        In = ParameterLocation.Header,Type = SecuritySchemeType.ApiKey,</span><br><span class="line">    &#125;;</span><br><span class="line">    c.AddSecurityDefinition(&quot;Authorization&quot;, scheme);</span><br><span class="line">    var requirement = new OpenApiSecurityRequirement();</span><br><span class="line">    requirement[scheme] = new List&lt;string&gt;();</span><br><span class="line">    c.AddSecurityRequirement(requirement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="JWT的缺点"><a href="#JWT的缺点" class="headerlink" title="JWT的缺点"></a>JWT的缺点</h2><p>1、到期前令牌无法被提前撤回。什么情况下需要撤回？<br>用户被删除了、禁用了；令牌被盗用了；单设备登录。<br>2、需要JWT撤回的场景用传统Session更合适。<br>3、思路：用Redis保存状态，或者用refresh_token+access_token机制等。<br>4、实现：服务器端将所有发出去的JWT保存下来，当客户端携带JWT，服务器端判断是否被修改，然后去查看有没有保存这个JWT。<br>在用户表中增加一个JWTVersion列，代表最后发放出去的令牌的版本号，每次登录、发放令牌的时候都让JWTVersion的值自增，同时将JWTVersion的值也放到JWT令牌的负载中；当执行禁用用户、撤回用户的令牌等操作时，把这个用户对应的JWTVersion列的值自增；当服务器收到客户端提交的JWT令牌后，先把JWT令牌中的JWTVersion值和数据库中JWTVersion的值做一下比较，如果JWT令牌中JWTVersion的值小于数据库中JWTVersion的值，就说明JWT令牌过期了</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_标识框架</title>
      <link href="/2023/09/15/Asp.NetCore-%E6%A0%87%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/09/15/Asp.NetCore-%E6%A0%87%E8%AF%86%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="标识框架（Identity）"><a href="#标识框架（Identity）" class="headerlink" title="标识框架（Identity）"></a>标识框架（Identity）</h1><h2 id="Authentication与Authorization"><a href="#Authentication与Authorization" class="headerlink" title="Authentication与Authorization"></a>Authentication与Authorization</h2><p>1、Authentication对访问者的用户进行验证，“用户是否登录”。<br>2、Authorization验证访问者的用户身份是否有对资源访问的访问权限，“用户是否有权限访问地址”<br>用户可能有多个角色，一个角色可能有多个用户。</p><h2 id="标识框架概念"><a href="#标识框架概念" class="headerlink" title="标识框架概念"></a>标识框架概念</h2><p>1、Identity采用基于角色的访问控制（RBAC）策略，内置了对用户、角色等表的管理，以及相关的接口，支持外部登录、2FA（两阶段验证）等。<br>2、标识框架使用EFCore对数据库进行操作，因此标识框架几乎支持所有数据库。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1、创建用户类和角色类，一般不自己编写而是创建继承IdentityUser&lt;TKey&gt;、IdentityRole&lt;TKey&gt;的自定义类类，TKey代表主键的类型，可以增加自定义属性。<br>2、NuGet安装：<br>Microsoft.AspNetCore.Identity.EntityFrameworkCore。<br>3、创建继承自IdentityDbContext的类，这个类内置了对IdentityUser&lt;TKey&gt;、IdentityRole&lt;TKey&gt;的处理，同时提供了基本的增删改查的操作。<br>4、可以通过IdDbContext类来操作数据库，不过框架中提供了RoleManager、UserManager等类来简化对数据库的操作。<br>5、部分方法的返回值为Task&lt;IdentityResult&gt;类型，这个类型包含着操作是否成功与错误信息等说明，需要手动判断<br>记得执行数据库迁移命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//自定义Identity角色</span><br><span class="line"> public class MyRole : IdentityRole&lt;long&gt;&#123;</span><br><span class="line">    &#125;</span><br><span class="line">//自定义Identity用户</span><br><span class="line">public class MyUser: IdentityUser&lt;long&gt; &#123;</span><br><span class="line">        public string? WeiXinAccount &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//数据库连接</span><br><span class="line">//不要忘了&lt;MyUser,MyRole,long&gt;</span><br><span class="line">public class MyDbContext :IdentityDbContext&lt;MyUser,MyRole,long&gt;&#123;</span><br><span class="line">        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options)</span><br><span class="line">           : base(options) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//数据库迁移时(Add-Migration Init报错)如果报错就定义这个类</span><br><span class="line">public class DbContextDesignTimeFactory : IDesignTimeDbContextFactory&lt;MyDbContext&gt; &#123;</span><br><span class="line">        public MyDbContext CreateDbContext(string[] args) &#123;</span><br><span class="line">            DbContextOptionsBuilder&lt;MyDbContext&gt; builder = new DbContextOptionsBuilder&lt;MyDbContext&gt;();</span><br><span class="line">            var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">            builder.UseMySql(&quot;server=localhost;user=root;password=your_password;database=your_database&quot;, serverVersion);</span><br><span class="line">            return new MyDbContext(builder.Options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">//Identity</span><br><span class="line">            builder.Services.AddDbContext&lt;MyDbContext&gt;(opt =&gt; &#123;</span><br><span class="line">                string constr = &quot;server=localhost;user=root;password=your_password;database=your_database&quot;;</span><br><span class="line">                var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">                opt.UseMySql(constr, serverVersion);</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.Services.AddDataProtection();</span><br><span class="line">            builder.Services.AddIdentityCore&lt;MyUser&gt;(options =&gt; &#123;</span><br><span class="line">                options.Password.RequireDigit = false;//是否需要数字</span><br><span class="line">                options.Password.RequireLowercase = false;//是否要求小写字母</span><br><span class="line">                options.Password.RequireNonAlphanumeric = false;//是否要求非数字非字母的字符</span><br><span class="line">                options.Password.RequireUppercase = false;//是否要求大写字母</span><br><span class="line">                options.Password.RequiredLength = 6;//长度</span><br><span class="line">                options.Tokens.PasswordResetTokenProvider = TokenOptions.DefaultEmailProvider;//密码重置</span><br><span class="line">                options.Tokens.EmailConfirmationTokenProvider = TokenOptions.DefaultEmailProvider;//邮箱配置</span><br><span class="line">            &#125;);</span><br><span class="line">            IdentityBuilder idBuilder = new IdentityBuilder(typeof(MyUser), typeof(MyRole), builder.Services);</span><br><span class="line">            idBuilder.AddEntityFrameworkStores&lt;MyDbContext&gt;()</span><br><span class="line">                .AddDefaultTokenProviders()</span><br><span class="line">                .AddUserManager&lt;UserManager&lt;MyUser&gt;&gt;()</span><br><span class="line">                .AddRoleManager&lt;RoleManager&lt;MyRole&gt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//Controller</span><br><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class DemoController : ControllerBase &#123;</span><br><span class="line">        private readonly UserManager&lt;MyUser&gt; userManager;</span><br><span class="line">        private readonly RoleManager&lt;MyRole&gt; roleManager;</span><br><span class="line">        private IWebHostEnvironment env;</span><br><span class="line"></span><br><span class="line">        public DemoController(UserManager&lt;MyUser&gt; userManager, RoleManager&lt;MyRole&gt; roleManager, IWebHostEnvironment env) &#123;</span><br><span class="line">            this.userManager = userManager;</span><br><span class="line">            this.roleManager = roleManager;</span><br><span class="line">            this.env = env;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        //创建用户</span><br><span class="line">        public async Task&lt;ActionResult&lt;string&gt;&gt;  Test1() &#123;</span><br><span class="line">           if(await roleManager.RoleExistsAsync(&quot;admin&quot;)==false) &#123;</span><br><span class="line">                MyRole role = new MyRole() &#123; Name = &quot;admin&quot;&#125;;</span><br><span class="line">                var result = await roleManager.CreateAsync(role);</span><br><span class="line">                if (!result.Succeeded) return BadRequest(&quot;roleManager,CreateAsync failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">           MyUser user1 =await userManager.FindByNameAsync(&quot;LJH&quot;);</span><br><span class="line">            if(user1==null) &#123;</span><br><span class="line">                user1 = new MyUser &#123; UserName = &quot;LJH&quot; &#125;;</span><br><span class="line">                var result = await userManager.CreateAsync(user1, &quot;123456&quot;);</span><br><span class="line">                if (!result.Succeeded) return BadRequest(&quot;userManager,CreateAsync failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(! await userManager.IsInRoleAsync(user1, &quot;admin&quot;)) &#123;</span><br><span class="line">               var result = await userManager.AddToRoleAsync(user1, &quot;admin&quot;);</span><br><span class="line">                if (!result.Succeeded) return BadRequest(&quot;userManager,AddToRoleAsync failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public async Task&lt;ActionResult&gt; CheckPwd(CheckPwdRequest req) &#123;</span><br><span class="line">            string userName = req.UserName;</span><br><span class="line">            string pwd = req.Password;</span><br><span class="line">            var user = await userManager.FindByNameAsync(userName);</span><br><span class="line">            if(user==null) &#123;</span><br><span class="line">                if(env.IsDevelopment()) &#123;</span><br><span class="line">                    return BadRequest(&quot;用户名不存在&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return BadRequest();//更安全</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            if(await userManager.IsLockedOutAsync(user)) &#123;</span><br><span class="line">                return BadRequest(&quot;用户已被锁定,锁定结束时间&quot;+user.LockoutEnd);</span><br><span class="line">            &#125;</span><br><span class="line">            if(await userManager.CheckPasswordAsync(user, pwd)) &#123;</span><br><span class="line">                await userManager.ResetAccessFailedCountAsync(user);</span><br><span class="line">                return Ok(&quot;登录成功&quot;);    </span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                await userManager.AccessFailedAsync(user);</span><br><span class="line">                return BadRequest(&quot;用户名或密码错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h2><p>流程：<br>1、生成重置Token<br>2、Token发给客户，形式：连接、验证码<br>3、根据Token实现密码重置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line">       public async Task&lt;ActionResult&gt; SendRestPasswordToken(string userName) &#123;</span><br><span class="line">           var user = await userManager.FindByNameAsync(userName);</span><br><span class="line">           if(user==null) &#123;</span><br><span class="line">               return BadRequest(&quot;用户名不存在&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           string token = await userManager.GeneratePasswordResetTokenAsync(user);</span><br><span class="line">           Console.WriteLine(&quot;验证码是&quot; + token);</span><br><span class="line">           return Ok();</span><br><span class="line">       &#125;</span><br><span class="line">       [HttpPut]</span><br><span class="line">       public async Task&lt;ActionResult&gt; ResetPassword(string userName,string token,string newPassword) &#123;</span><br><span class="line">           var user = await userManager.FindByNameAsync(userName);</span><br><span class="line">           if (user == null) &#123;</span><br><span class="line">               return BadRequest(&quot;用户名不存在&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           var result = await userManager.ResetPasswordAsync(user, token, newPassword);</span><br><span class="line">           if(result.Succeeded) &#123;</span><br><span class="line">               await userManager.ResetAccessFailedCountAsync(user);</span><br><span class="line">               return Ok(&quot;密码重置成功&quot;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               await userManager.ResetAccessFailedCountAsync(user);</span><br><span class="line">               return BadRequest(&quot;密码重置失败&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> 标识框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_中间件</title>
      <link href="/2023/09/13/Asp.NetCore-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2023/09/13/Asp.NetCore-%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我怕我解释不清楚，这里直接上课件<br><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/1.jpg"><br><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/2.jpg"><br><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/3.jpg"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们建立一个空的asp.net core项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args) &#123;</span><br><span class="line">            var builder = WebApplication.CreateBuilder(args);</span><br><span class="line">            var app = builder.Build();</span><br><span class="line"></span><br><span class="line">            //app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello World!&quot;);</span><br><span class="line">            app.Map(&quot;/test&quot;, async (pipiBuilder) =&gt; &#123;</span><br><span class="line">                pipiBuilder.Use(async (context, next) =&gt; &#123;</span><br><span class="line">                    context.Response.ContentType = &quot;text/html&quot;;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;1 Start &lt;br/&gt;&quot;);</span><br><span class="line">                    await next.Invoke();</span><br><span class="line">                    await context.Response.WriteAsync(&quot;1 End &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">                pipiBuilder.Use(async (context, next) =&gt; &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 Start &lt;br/&gt;&quot;);</span><br><span class="line">                    await next.Invoke();</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 End &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">                pipiBuilder.Run(async (context) =&gt; &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;Run &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            app.Run();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>以上仅为了演示，一般都在Run中输出内容，如果在Use中输出了内容，就不要next了，不然容易引起混乱。</p><h2 id="简单的自定义中间件"><a href="#简单的自定义中间件" class="headerlink" title="简单的自定义中间件"></a>简单的自定义中间件</h2><p>1、如果中间件的代码比较复杂，或者我们需要重复使用一个中间件的话，我们最好把中间件的代码放到一个单独的“中间件类”中。<br>2、中间件类是一个普通的类，不需要继承任何父类或者实现任何接口，但是这个类需要有一个构造方法，构造方法至少要有一个RequestDelegate类型的参数（就是上面的next），这个参数用来指向下一个中间件。这个类还需要定义一个名字为Invoke或者InvokeAsync的方法，方法至少有一个HttpContext类型的参数，方法的返回值必须是Task类型。中间件类的构造方法和Invoke（或者InvokeAsync）方法还可以定义其他参数，其他参数的值会通过依赖注入自动赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//自定义中间件类</span><br><span class="line">public class CheckAndParsingMiddleware &#123;</span><br><span class="line">        private readonly RequestDelegate next;</span><br><span class="line">        public CheckAndParsingMiddleware(RequestDelegate next) &#123;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        public async Task InvokeAsync(HttpContext context) &#123;</span><br><span class="line">            string password = context.Request.Query[&quot;password&quot;];</span><br><span class="line">            if(password == &quot;123&quot;) &#123;</span><br><span class="line">                if (context.Request.HasJsonContentType()) &#123;</span><br><span class="line">                    //如果请求中有json就往下执行（浏览器看不出来，去postman上看）</span><br><span class="line"></span><br><span class="line">                    //如果password为123就将请求报文转为dynamic类型</span><br><span class="line">                    var reqStream = context.Request.BodyReader.AsStream();//转成流的格式</span><br><span class="line">                    //需要安装Dynamic.json包</span><br><span class="line">                    //目前（.net6）System.Text.Json不支持把json反序列化为dynamic类型</span><br><span class="line">                    dynamic? jsonObj = DJson.Parse(reqStream);</span><br><span class="line">                    context.Items[&quot;BodyJson&quot;] = jsonObj;</span><br><span class="line">                &#125;</span><br><span class="line">                await next.Invoke(context);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                context.Response.StatusCode = 401;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">app.Map(&quot;/test&quot;, async (pipiBuilder) =&gt; &#123;</span><br><span class="line">                pipiBuilder.UseMiddleware&lt;CheckAndParsingMiddleware&gt;();</span><br><span class="line">                pipiBuilder.Use(async (context, next) =&gt; &#123;</span><br><span class="line">                    context.Response.ContentType = &quot;text/html&quot;;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 Start &lt;br/&gt;&quot;);</span><br><span class="line">                    await next.Invoke();</span><br><span class="line">                    await context.Response.WriteAsync(&quot;2 End &lt;br/&gt;&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">                pipiBuilder.Run(async (context) =&gt; &#123;</span><br><span class="line">                    await context.Response.WriteAsync(&quot;Run &lt;br/&gt;&quot;);</span><br><span class="line">                    //context.Item可以在同一个请求中跨中间件进行消息传递</span><br><span class="line">                    dynamic obj = context.Items[&quot;BodyJson&quot;];</span><br><span class="line">                    if(obj != null) &#123;</span><br><span class="line">                        await context.Response.WriteAsync($&quot;&#123;obj.ToString()&#125;&lt;br/&gt;&quot;);</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="案例（Markdown渲染中间件）"><a href="#案例（Markdown渲染中间件）" class="headerlink" title="案例（Markdown渲染中间件）"></a>案例（Markdown渲染中间件）</h2><p>Markdown不被浏览器支持，所以编写一个在服务器端把Markdown转换为HTML的中间件。<br>我们开发的中间件是构件在ASP.NET Core内置的StaticFiles中间件之上，并且在它之前运行，所有的*.md文件都被放到wwwroot文件夹下，当我们请求wwwroot下其他静态文件时，StaticFiles中间件会把它们返回给浏览器，而当我们请求wwwroot下的*.md文件时，我们编写的中间件会读取对应的*.md文件，并把它们转换为HTML格式返回给浏览器<br>检测文本编码：<br>安装Ude.NetStandard包。<br>通过CharsetDetector类探测文件编码。<br>Markdown-&gt;HTML：<br>安装MarkdownSharp包。<br>通过Markdown实例的Transform()方法将md文本转换为html。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">using MarkdownSharp;</span><br><span class="line">using Microsoft.Extensions.Caching.Memory;</span><br><span class="line">using System.Text;</span><br><span class="line">using Ude;</span><br><span class="line"></span><br><span class="line">public class MarkDownViewerMiddleware &#123;</span><br><span class="line">    private readonly RequestDelegate next;</span><br><span class="line">    private readonly IWebHostEnvironment hostEnv;</span><br><span class="line">    private readonly IMemoryCache memCache;</span><br><span class="line"></span><br><span class="line">    public MarkDownViewerMiddleware(RequestDelegate next,</span><br><span class="line">        IWebHostEnvironment hostEnv, IMemoryCache memCache) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.hostEnv = hostEnv;</span><br><span class="line">        this.memCache = memCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 检测流的编码</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;stream&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    private static string DetectCharset(Stream stream) &#123;</span><br><span class="line">        CharsetDetector charDetector = new();</span><br><span class="line">        charDetector.Feed(stream);</span><br><span class="line">        charDetector.DataEnd();</span><br><span class="line">        string charset = charDetector.Charset ?? &quot;UTF-8&quot;;</span><br><span class="line">        stream.Position = 0;</span><br><span class="line">        return charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 读取文本内容</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;stream&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    private static async Task&lt;string&gt; ReadText(Stream stream) &#123;</span><br><span class="line">        string charset = DetectCharset(stream);</span><br><span class="line">        using var reader = new StreamReader(stream, Encoding.GetEncoding(charset));</span><br><span class="line">        return await reader.ReadToEndAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async Task InvokeAsync(HttpContext context) &#123;</span><br><span class="line">        string path = context.Request.Path.Value ?? &quot;&quot;;</span><br><span class="line">        if (!path.EndsWith(&quot;.md&quot;)) &#123;</span><br><span class="line">            await next(context);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var file = hostEnv.WebRootFileProvider.GetFileInfo(path);</span><br><span class="line">        if (!file.Exists) &#123;</span><br><span class="line">            await next(context);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        context.Response.ContentType = $&quot;text/html;charset=UTF-8&quot;;</span><br><span class="line">        context.Response.StatusCode = 200;</span><br><span class="line">        string cacheKey = nameof(MarkDownViewerMiddleware)</span><br><span class="line">            + path + file.LastModified;</span><br><span class="line">        var html = await memCache.GetOrCreateAsync(cacheKey, async ce =&gt; &#123;</span><br><span class="line">            ce.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(1);</span><br><span class="line">            using var stream = file.CreateReadStream();</span><br><span class="line">            string text = await ReadText(stream);</span><br><span class="line">            Markdown markdown = new Markdown();</span><br><span class="line">            return markdown.Transform(text);</span><br><span class="line">        &#125;);</span><br><span class="line">        await context.Response.WriteAsync(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">//注意中间件的位置</span><br><span class="line">            app.UseHttpsRedirection();</span><br><span class="line">            app.UseMiddleware&lt;MarkDownViewerMiddleware&gt;();</span><br><span class="line">            app.UseStaticFiles();</span><br></pre></td></tr></table></figure><h1 id="中间件和Filter的区别"><a href="#中间件和Filter的区别" class="headerlink" title="中间件和Filter的区别"></a>中间件和Filter的区别</h1><p><img src="/images/Asp.NetCore%E4%B8%AD%E7%BA%A7%E7%AF%87/4.jpg"><br>区别：<br>1、中间件可以处理所有的请求，而Filter只能处理对控制器的请求；中间件运行在一个更底层、更抽象的级别，因此在中间件中无法处理MVC中间件特有的概念。<br>2、中间件和Filter可以完成很多相似的功能。“未处理异常中间件”和“未处理异常Filter”；“请求限流中间件”和“请求限流FIlter”<br>3、优先选择使用中间件；但是如果这个组件只针对MVC或者需要调用一些MVC相关的类的时候，我们就只能选择Filter</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> 筛选器 </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_筛选器</title>
      <link href="/2023/09/13/Asp.NetCore-%E7%AD%9B%E9%80%89%E5%99%A8/"/>
      <url>/2023/09/13/Asp.NetCore-%E7%AD%9B%E9%80%89%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="筛选器Filter"><a href="#筛选器Filter" class="headerlink" title="筛选器Filter"></a>筛选器Filter</h1><p>1、Filter是面向切面编程机制，在ASP.NET Core特定的位置执行我们自定义的代码<br>2、有5种Filter类型：Authorization filter、Resource filter、Action filter、Exception filter、Result filter。<br>3、所有筛选器一般有同步异步两个版本比如IActionFilter、IAsyncActionFilter接口</p><h2 id="异常筛选器"><a href="#异常筛选器" class="headerlink" title="异常筛选器"></a>异常筛选器</h2><p>当系统中出现未经处理的异常时，异常筛选器会执行。<br>目标：当系统中出现未处理异常的时候，我们统一给客户端返回如下格式的响应报文：{“code”:”500”,”message”:”异常信息”}，对于开发环境中message是异常堆栈，对于其他环境message用一个general的报错信息。<br>实现：实现IAsyncExceptionFilter接口。注入IHostEnvironment得知运行环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Action方法</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string MakeErr() &#123;</span><br><span class="line">           string s =  System.IO.File.ReadAllText(&quot;f:/1.txt&quot;);</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//创建自定义异常筛选器</span><br><span class="line">    public class MyExceptionFilter : IAsyncExceptionFilter &#123;</span><br><span class="line">        private readonly IWebHostEnvironment webHostEnvironment;//将需要用到的服务注入，我们需要这个来判断当前为什么环境</span><br><span class="line">        public MyExceptionFilter(IWebHostEnvironment webHostEnvironment) &#123;</span><br><span class="line">            this.webHostEnvironment = webHostEnvironment;</span><br><span class="line">        &#125;</span><br><span class="line">        public Task OnExceptionAsync(ExceptionContext context) &#123;</span><br><span class="line">            //当Action中发生未处理异常，该方法会被调用</span><br><span class="line">            //context.Exception代表异常信息对象</span><br><span class="line">            //如果给context.ExceptionHandled赋值为true，其他的ExceptionFilter就不会再执行</span><br><span class="line">            //context.Result的值会被输出给客户端，是一个IActionResult类型的对象</span><br><span class="line">            string msg;</span><br><span class="line">            if(webHostEnvironment.IsDevelopment()) &#123;</span><br><span class="line">                //如果是开发环境</span><br><span class="line">                msg = context.Exception.ToString();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                msg = &quot;服务器端发生未处理异常&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            //ObjectResult继承ActionResult实现IActionResult</span><br><span class="line">            ObjectResult obj = new ObjectResult(new &#123;code= 500 ,message = msg&#125;);</span><br><span class="line">            context.Result = obj;</span><br><span class="line">            context.ExceptionHandled = true;//告诉别的ExceptionFilter不用执行了</span><br><span class="line">            context.Result = obj;</span><br><span class="line">            return Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">            builder.Services.Configure&lt;MvcOptions&gt;(options =&gt; &#123;</span><br><span class="line">                options.Filters.Add&lt;MyExceptionFilter&gt;();//注入自定义异常筛选器，注意！！！：多个筛选器Add的时候要注意顺序</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="Action筛选器"><a href="#Action筛选器" class="headerlink" title="Action筛选器"></a>Action筛选器</h2><p>用于控制器中每个action方法执行之前和之后执行自定义代码，比如在执行action之前判断用户有没有权限或者在执行之后记录日志。<br>一个筛选器分为前代码和后代码，有多个ActionFilter执行顺序为：<br>1前-&gt;2前-&gt;3前-&gt;Action-&gt;3后-&gt;2后-&gt;1后<br>自定义Action筛选器需要实现IActionFilter&#x2F;IAsyncActionFilter接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Action方法</span><br><span class="line">[HttpGet]</span><br><span class="line">        public string TestAction() &#123;</span><br><span class="line">            Console.WriteLine(&quot;执行中&quot;);</span><br><span class="line">            return &quot;执行中&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建自定义Action筛选器</span><br><span class="line">    public class MyActionFilter : IAsyncActionFilter &#123;</span><br><span class="line">        public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) &#123;</span><br><span class="line">            //next为委托，调用next()程序就会向下执行</span><br><span class="line">            Console.WriteLine(&quot;Action1执行前&quot;);</span><br><span class="line">            ActionExecutedContext result = await next();//next()的返回值表示action执行中是否出现异常</span><br><span class="line">            if(result.Exception != null) &#123;</span><br><span class="line">                Console.WriteLine(&quot;Action1发生了异常&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Console.WriteLine(&quot;Action1执行成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">            builder.Services.Configure&lt;MvcOptions&gt;(options =&gt; &#123;</span><br><span class="line">                options.Filters.Add&lt;MyActionFilter&gt;();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="筛选器案例"><a href="#筛选器案例" class="headerlink" title="筛选器案例"></a>筛选器案例</h2><h3 id="案例一（TransactionScope）"><a href="#案例一（TransactionScope）" class="headerlink" title="案例一（TransactionScope）"></a>案例一（TransactionScope）</h3><p>需求：<br>1、数据库事务：要么全部成功，要么全部失败。<br>2、自动化：启动、提交以及回滚事务。<br>3、当一段使用EFCore进行数据库操作的代码放到TransactionScope声明的范围中的时候，这段代码就会自动被标记为“支持事务”。<br>4、TransactionScope实现了IDisposable接口，如果一个TransactionScope的对象没有调用Complete()就执行了Dispose()方法，则事物会被回滚，否则事务就会被提交。<br>5、TransactionScope支持嵌套式事务，即便里面的TransactionScope已经提交，但是外面的TransactionScope失败了，事务依然会回滚。<br>6、.Net Core中的TransactionScope不像.Net FX一样有MSDTC分布式事务提升的问题，请使用最终一致性事务。<br>接下来我会用MySql数据库举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//appsetting.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ConnectionStrings&quot;: &#123;</span><br><span class="line">    &quot;DefaultConnection&quot;: &quot;server=localhost;user=root;password=your_password;database=your_database&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//实体类</span><br><span class="line">    public class Book &#123;</span><br><span class="line">        public long Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public double Price &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Person &#123;</span><br><span class="line">        public long Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public int Age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//连接数据库</span><br><span class="line">public class MyDbContext:DbContext &#123;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;</span><br><span class="line">        public DbSet&lt;Person&gt; Persons &#123; get; set; &#125;</span><br><span class="line">        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options) : base(options) &#123; </span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//自定义特性</span><br><span class="line">public class NotTransactionAttribute :Attribute&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//自动启用事务的ActionFilter</span><br><span class="line">    public class TransactionScopeFilter : IAsyncActionFilter &#123;</span><br><span class="line">        public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) &#123;</span><br><span class="line">            //context.ActionDescriptor中是当前被执行的Action方法的描述信息</span><br><span class="line">            //context.ActionArguments中是当前被执行的Action方法的参数信息</span><br><span class="line">            //context.ActionDescriptor.Parameters[0]是当前被执行的Action方法的第一个参数</span><br><span class="line">            ControllerActionDescriptor ctrlActionDesc = context.ActionDescriptor as ControllerActionDescriptor;</span><br><span class="line">            bool isTX = false;//是否进行事务控制</span><br><span class="line">            if(ctrlActionDesc != null) &#123;//是一个MVC的action</span><br><span class="line">                //ctrlActionDesc.MethodInfo当前的Action方法</span><br><span class="line">                bool hasNotTransactionAttribute = ctrlActionDesc.MethodInfo</span><br><span class="line">                    .GetCustomAttributes(typeof(NotTransactionAttribute), false)</span><br><span class="line">                    .Any();</span><br><span class="line">                isTX = !hasNotTransactionAttribute;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isTX) &#123;</span><br><span class="line">                using(TransactionScope tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled)) &#123;</span><br><span class="line">                    var r = await next();</span><br><span class="line">                    if(r.Exception == null) &#123;</span><br><span class="line">                        tx.Complete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                await next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">           builder.Services.AddDbContext&lt;MyDbContext&gt;(options =&gt; &#123;</span><br><span class="line">                string constr = builder.Configuration.GetSection(&quot;ConnectionStrings:DefaultConnection&quot;).Value;</span><br><span class="line">                var serverVersion = new MySqlServerVersion(new Version(8, 0, 29));</span><br><span class="line">                options.UseMySql(constr, serverVersion);</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.Services.Configure&lt;MvcOptions&gt;(opt =&gt; &#123;</span><br><span class="line">                opt.Filters.Add&lt;TransactionScopeFilter&gt;();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//控制器</span><br><span class="line">    [Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class DemoController : ControllerBase &#123;</span><br><span class="line">        private MyDbContext ctx;</span><br><span class="line">        public DemoController(MyDbContext ctx) &#123;</span><br><span class="line">            this.ctx = ctx;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        [NotTransaction]</span><br><span class="line">        public string Test1() &#123;</span><br><span class="line">            using (TransactionScope tx = new TransactionScope()) &#123;</span><br><span class="line">                ctx.Books.Add(new Book &#123; Name = &quot;aaa&quot;, Price = 34 &#125;);</span><br><span class="line">                ctx.SaveChanges();//一个事务</span><br><span class="line">                ctx.Persons.Add(new Person &#123; Name = &quot;ljhljh&quot;, Age = 18 &#125;);</span><br><span class="line">                ctx.SaveChanges();//一个事务</span><br><span class="line">                tx.Complete();</span><br><span class="line">                return &quot;ok&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        [NotTransaction]</span><br><span class="line">        public async Task&lt;string&gt; Test2() &#123;</span><br><span class="line">            //异步需要向TransactionScope传入这个参数，原理是：</span><br><span class="line">            //同步的代码在TheadLocal中（相当于当前线程的全局变量）</span><br><span class="line">            //异步的代码在AsyncLocal中（相当于当前异步线程的全局变量）</span><br><span class="line">            using (TransactionScope tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled)) &#123;</span><br><span class="line">                ctx.Books.Add(new Book &#123; Name = &quot;aaa&quot;, Price = 34 &#125;);</span><br><span class="line">                await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">                ctx.Persons.Add(new Person &#123; Name = &quot;ljh&quot;, Age = 18 &#125;);</span><br><span class="line">                await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">                tx.Complete();</span><br><span class="line">                return &quot;ok&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public async Task&lt;string&gt; Test3() &#123;</span><br><span class="line">            ctx.Books.Add(new Book &#123; Name = &quot;aaa&quot;, Price = 34 &#125;);</span><br><span class="line">            await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">            ctx.Persons.Add(new Person &#123; Name = &quot;ljh&quot;, Age = 18 &#125;);</span><br><span class="line">            await ctx.SaveChangesAsync();//一个事务</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="案例二（限流器）"><a href="#案例二（限流器）" class="headerlink" title="案例二（限流器）"></a>案例二（限流器）</h3><p>需求：<br>对用户访问进行限流。<br>通过缓存机制，将用户的ip地址存放到缓存中。<br>如果缓存中ip已过期或者超过1秒就执行action。<br>ActionFilter可以在满足条件的时候终止操作方法的执行。<br>在ActionFilter中如果不调用next()就可以终止Action方法的执行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//筛选器</span><br><span class="line">    public class RateLimitFilter : IAsyncActionFilter &#123;</span><br><span class="line">        private readonly IMemoryCache memoryCache;</span><br><span class="line"></span><br><span class="line">        public RateLimitFilter(IMemoryCache memoryCache) &#123;</span><br><span class="line">            this.memoryCache = memoryCache;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) &#123;</span><br><span class="line">            string userIp = context.HttpContext.Connection.RemoteIpAddress.ToString();//用户ip</span><br><span class="line">            string cacheKey = $&quot;Limit_&#123;userIp&#125;&quot;;</span><br><span class="line">            long? lastTick = memoryCache.Get&lt;long?&gt;(cacheKey) ;//获取用户ip对应最后一次登录时间</span><br><span class="line">            if (lastTick == null || Environment.TickCount64 - lastTick &gt; 1000) &#123;</span><br><span class="line">                //如果用户ip缓存已过期或者超过一秒</span><br><span class="line">                memoryCache.Set(cacheKey, Environment.TickCount64,TimeSpan.FromSeconds(10));//存储当前时间并且设置10秒固定过期时间</span><br><span class="line">                return next();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               ObjectResult result = new ObjectResult(&quot;访问过于频繁&quot;)&#123; StatusCode = 429&#125;;</span><br><span class="line">                context.Result = result;</span><br><span class="line">                return Task.CompletedTask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(opt =&gt; &#123;</span><br><span class="line">                opt.Filters.Add&lt;TransactionScopeFilter&gt;();</span><br><span class="line">                opt.Filters.Add&lt;RateLimitFilter&gt;();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//控制器</span><br><span class="line">    [Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class RateLimitController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string LimitTest() &#123;</span><br><span class="line">            return &quot;响应结果……&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> 筛选器 </tag>
            
            <tag> Filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_EFCore</title>
      <link href="/2023/09/13/Asp.NetCore-EFCore/"/>
      <url>/2023/09/13/Asp.NetCore-EFCore/</url>
      
        <content type="html"><![CDATA[<h1 id="EFCore"><a href="#EFCore" class="headerlink" title="EFCore"></a>EFCore</h1><p>敬请期待</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> EFCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_配置系统</title>
      <link href="/2023/09/13/Asp.NetCore-%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/13/Asp.NetCore-%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h1><h2 id="默认添加配置提供者"><a href="#默认添加配置提供者" class="headerlink" title="默认添加配置提供者"></a>默认添加配置提供者</h2><p>ASP.NET CORE默认添加的配置提供者：<br>1)加载现有的IConfiguration<br>2)加载项目根目录下的appsettings.json<br>3)加载项目根目录下的appsettings.{Environment}.json<br>4)当程序运行在开发环境在，程序会加载“用户机密”配置<br>5)加载环境变量中的配置<br>6)加载命令行中的配置</p><h2 id="开发、测试、生产环境"><a href="#开发、测试、生产环境" class="headerlink" title="开发、测试、生产环境"></a>开发、测试、生产环境</h2><p>不同的环境有不同的配置<br>运行环境：ASP.NET Core会从环境变量中读取名字为ASPNETCORE_ENVIRONMENT的值，推荐值：Development、Staging、Production。<br>读取方法：app.Environment.EnvironmentName、app.Environment.IsDevelopment()……<br>在windows和vs中设置环境变量的方法。</p><h2 id="机密信息"><a href="#机密信息" class="headerlink" title="机密信息"></a>机密信息</h2><p>1、把不方便放到appsetting.json中的机密信息放到一个不在项目中的json文件中。<br>2、在ASP.NET Core项目上单击鼠标右键，选择【管理用户机密】。<br>3、secrets.json文件和项目通过csproj文件中的&lt;UserSecretsId&gt;建立关系。<br>注意事项：<br>机密信息仅供开发人员使用。<br>仍然是明文存储，如果不想被人看到可通过Azure Key Vault、Zack.AnyDBConfigProvider等，但是无法完全避免。<br>如果因为重装、新员工等原因导致secrets.js重建，就要重新配置，如果影响大的话，还是用集中式配置服务器。</p><h2 id="配置系统的使用"><a href="#配置系统的使用" class="headerlink" title="配置系统的使用"></a>配置系统的使用</h2><p>其实没必要看我的，直接看文档就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Program.cs</span><br><span class="line">            builder.Configuration.AddJsonFile(&quot;MyConfig.json&quot;,//添加json配置文件</span><br><span class="line">                optional: true,</span><br><span class="line">                reloadOnChange: true</span><br><span class="line">            );</span><br><span class="line">            builder.Services.Configure&lt;Config&gt;(builder.Configuration);//将Config注入到DI中，并且绑定到根节点上</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//MyConfig.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;18&quot;,</span><br><span class="line">  &quot;proxy&quot;: &#123;</span><br><span class="line">    &quot;address&quot;: &quot;aa&quot;,</span><br><span class="line">    &quot;port&quot;: &quot;8080&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//ConfigController.cs</span><br><span class="line">    [Route(&quot;api/[controller]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class ConfigController : ControllerBase &#123;</span><br><span class="line">        private readonly IOptionsSnapshot&lt;Config&gt; optConfig;//在需要用到的地方依赖注入</span><br><span class="line">        public ConfigController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">            this.optConfig = optConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public string Test() &#123;</span><br><span class="line">            return optConfig.Value.Proxy.Address;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> 配置系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志系统</title>
      <link href="/2023/09/07/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/07/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>日志系统官方文档：<br><a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/logging?tabs=command-line">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/logging?tabs=command-line</a><br>日志级别：<br>Trace&lt;Debug&lt;Information&lt;Warning&lt;Error&lt;Critical<br>日志提供者（LoggingProvider）:<br>把日志输出到控制台、文件、数据库等。<br>对于业务代码只要注入日志对象记录日志即可，具体哪些日志输出到哪里、什么样的格式、是否输出等都有配置或者初始化代码决定。</p><h1 id="控制台日志"><a href="#控制台日志" class="headerlink" title="控制台日志"></a>控制台日志</h1><p>安装：Microsoft.Extensions.Logging、Microsoft.Extensions.Logging.Console</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">using Microsoft.Extensions.Logging;</span><br><span class="line"></span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddLogging((logBuilder) =&gt; &#123;</span><br><span class="line">                logBuilder.AddConsole();</span><br><span class="line">                //logBuilder.AddEventLog();安装Microsoft.Extension.Logging.EventLog，这个只能windows用所以用的很少</span><br><span class="line">                logBuilder.SetMinimumLevel(LogLevel.Debug);//设置最低级别，不写这个看不到Debug信息</span><br><span class="line">            &#125;);</span><br><span class="line">            services.AddScoped&lt;Test1&gt;();</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               var test1 = sp.GetRequiredService&lt;Test1&gt;();</span><br><span class="line">                test1.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Test1 &#123;</span><br><span class="line">        //&lt;&gt;里面一般为当前类，这样可以直接从找到是哪个类记录了日志</span><br><span class="line">        private readonly ILogger&lt;Test1&gt; logger;</span><br><span class="line">        public Test1(ILogger&lt;Test1&gt; logger) &#123;</span><br><span class="line">            this.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Test() &#123;</span><br><span class="line">            logger.LogDebug(&quot;开始执行数据库同步&quot;);</span><br><span class="line">            logger.LogDebug(&quot;连接数据库成功&quot;);</span><br><span class="line">            logger.LogWarning(&quot;查找数据失败，重试第一次&quot;);</span><br><span class="line">            logger.LogWarning(&quot;查找数据失败，重试第二次&quot;);</span><br><span class="line">            logger.LogError(&quot;查找数据最终失败&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                File.ReadAllText(&quot;A:/1.txt&quot;);</span><br><span class="line">                logger.LogDebug(&quot;读取文件成功&quot;);</span><br><span class="line">            &#125;catch(Exception ex) &#123;</span><br><span class="line">                //通过该方法记录异常，可以传入异常对象</span><br><span class="line">                logger.LogError(ex,&quot;读取文件失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NLog文本日志"><a href="#NLog文本日志" class="headerlink" title="NLog文本日志"></a>NLog文本日志</h1><p>NLog官方文档：<br><a href="https://github.com/NLog/NLog/wiki/Getting-started-with-ASP.NET-Core-6">https://github.com/NLog/NLog/wiki/Getting-started-with-ASP.NET-Core-6</a><br>文本日志一般按照日期区分，为了避免磁盘被撑爆可以限制日志总个数或者总大小。<br>1、.Net没有内置文本日志提供者。第三方有Log4Net、NLog、Serilog等。老牌的Log4Net另搞一套，不考虑。<br>安装：<br>NLog.Extensions.Logging(using NLog.Extension.Logging;)。2、项目根目录下建nlog.config选择文件较新则赋值，注意文件名的大小写（考虑linux）。也可以是其他文件名，但是需要单独配置。约定大于配置。<br>3、增加logBuilder.AddNLog();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//nlog.config</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      autoReload=&quot;true&quot;</span><br><span class="line">      internalLogLevel=&quot;Info&quot;</span><br><span class="line">      internalLogFile=&quot;c:\temp\internal-nlog-AspNetCore.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- enable asp.net core layout renderers --&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;add assembly=&quot;NLog.Web.AspNetCore&quot;/&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- the targets to write to --&gt;</span><br><span class="line">  &lt;targets&gt;</span><br><span class="line">    &lt;!-- File Target for all log messages with basic details --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;File&quot; name=&quot;allfile&quot; fileName=&quot;c:\temp\nlog-AspNetCore-all-$&#123;shortdate&#125;.log&quot;</span><br><span class="line">            layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId:whenEmpty=0&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;File&quot; name=&quot;ownFile-web&quot; fileName=&quot;c:\temp\nlog-AspNetCore-own-$&#123;shortdate&#125;.log&quot;</span><br><span class="line">            layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId:whenEmpty=0&#125;|$&#123;level:uppercase=true&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;|url: $&#123;aspnet-request-url&#125;|action: $&#123;aspnet-mvc-action&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;Console&quot; name=&quot;lifetimeConsole&quot; layout=&quot;$&#123;MicrosoftConsoleLayout&#125;&quot; /&gt;</span><br><span class="line">  &lt;/targets&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- rules to map from logger name to target --&gt;</span><br><span class="line">  &lt;rules&gt;</span><br><span class="line">    &lt;!--All logs, including from Microsoft--&gt;</span><br><span class="line">    &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;allfile&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Output hosting lifetime messages to console target for faster startup detection --&gt;</span><br><span class="line">    &lt;logger name=&quot;Microsoft.Hosting.Lifetime&quot; minlevel=&quot;Info&quot; writeTo=&quot;lifetimeConsole, ownFile-web&quot; final=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --&gt;</span><br><span class="line">    &lt;logger name=&quot;Microsoft.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;logger name=&quot;System.Net.Http.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;ownFile-web&quot; /&gt;</span><br><span class="line">  &lt;/rules&gt;</span><br><span class="line">&lt;/nlog&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using NLog.Extensions.Logging;</span><br><span class="line">//============================</span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddLogging((logBuilder) =&gt; &#123;</span><br><span class="line">                logBuilder.AddNLog();</span><br><span class="line">            &#125;);</span><br><span class="line">            services.AddScoped&lt;Test1&gt;();</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               var test1 = sp.GetRequiredService&lt;Test1&gt;();</span><br><span class="line">                test1.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>nlog有多个traget表示日志输出到哪，rules中有多个logger，会从上往下匹配，用来配置日志规则（哪个级别输出到哪个target），匹配到final&#x3D;true就不再往下匹配。</p><h2 id="日志分类、过滤"><a href="#日志分类、过滤" class="headerlink" title="日志分类、过滤"></a>日志分类、过滤</h2><p>1、为什么要分类？不同级别或者不同模块的日志要记录到不同的地方。<br>2、为什么要过滤？项目不同阶段（比如刚上线和稳定后）需要记录的日志不同。严重错误可以调用短信Provider等。<br>3、搞一个新的类，放到SystemServices这个名称空间下，然后输出一些日志。然后调用很多次日志执行。nlog.config如备注所改。</p><h2 id="重要的参数"><a href="#重要的参数" class="headerlink" title="重要的参数"></a>重要的参数</h2><p>archiveAboveSize为”单个日志文件超过多少字节就把日志存档”，如果不设定maxArchiveFiles参数，则文件日志存档文件的数量会一直增加。<br>maxArchiveFiles指定数量个数的存档文件，旧的会被删掉。<br>maxArchiveDays设定保存若干天的日志存档。<br>通过设定这些参数实现滚动日志策略。</p><h2 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h2><p>rules节点下可以添加多个logger，每个logger都有name属性，name是通配符格式的。<br>logger节点的minlevel属性和maxlevel属性，表示这个logger接受日志的最低级别和最高级别。<br>日志输出时，会从上往下匹配rules节点下所有的logger，若发现当前日志的分类名和level符合这个logger的name的通配符，就会把日志输出给这个logger。如果匹配多个logger，就会把这条日志输出给多个logger。但是如果一个logger设置了final&#x3D;”true”，那么如果匹配到这个logger，就不继续向下匹配其他logger了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>NLog部分功能和.NET的Logging重复，比如分类、分级、各种Provider。<br>为了避免冲突，如果用NLog，建议不要再配置.NET的分级等。</p><h1 id="结构化日志"><a href="#结构化日志" class="headerlink" title="结构化日志"></a>结构化日志</h1><p>结构化日志比普通文本更利于日志的分析，比如统计“邮件发送失败”错误发生了多少次。</p><h1 id="集中化日志"><a href="#集中化日志" class="headerlink" title="集中化日志"></a>集中化日志</h1><p>集群化配置环境中，有N多个服务器，如果每个服务器都把日志记录到本地文件，不便于查询、分析。<br>需要把日志保存到集中化的日志服务器中。<br>NLog可以配置结构化日志不过比较麻烦更推荐——Serilog<br>Nuget安装：Serilog.AspNetCore。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = new LoggerConfiguration()</span><br><span class="line">                .MinimumLevel.Debug()</span><br><span class="line">                .Enrich.FromLogContext()</span><br><span class="line">                .WriteTo.Console(new JsonFormatter())</span><br><span class="line">                .CreateLogger();</span><br><span class="line">builder.AddSerilog();</span><br></pre></td></tr></table></figure><p>要记录的结构化数据通过占位符来输出：<br>logger.LogWaring(“新增用户{@person}”,new {Id &#x3D; 3,Name &#x3D; “zack”});<br>同样可以输出到文件、数据库、MongoDB等。</p><h2 id="集中日志服务"><a href="#集中日志服务" class="headerlink" title="集中日志服务"></a>集中日志服务</h2><p>使用NLog、Serilog等可以把日志记录到数据库，MongoDB等地方，就可以实现“结构化、集中日志服务”，不过需要自己编写日志分析程序。<br>公有云厂商一般都提供了日志云服务，都带有分析功能，都有对应Serilog插件，即使没有提供，开发一个插件也不麻烦。<br>如果没有用云平台或者想自己控制日志服务，可以使用Exceptionless或者ELK等</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>普通项目用NLog输出到文本文件即可，根据需要设定过滤、分类规则。<br>集群部署的项目用Serilog+集中式日志服务。如果需要记录结构化日志，再进行结构化输出。<br>如果用云服务的就够了，就用云服务，免得自己部署；如果想自己控制日志数据就用自部署Exceptionless或者ELK等。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Logging </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_缓存</title>
      <link href="/2023/09/07/Asp.NetCore-%E7%BC%93%E5%AD%98/"/>
      <url>/2023/09/07/Asp.NetCore-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存（Caching）是系统优化中简单又有效的工具，投入小收效大，数据库中的索引等简单有效的优化功能本质上都是缓存。<br>缓存的概念：缓存命中，缓存命中率，缓存数据不一致，多级缓存。</p><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><p>RFC7324是HTTP协议中对缓存进行控制的规范，其中重要的是cache-control这个响应报文头。服务器如果返回cache-control:max-age&#x3D;60,则表示服务器指示浏览器端“可以缓存这个相应内容60秒”。<br>我们只要给需要进行缓存控制的控制器的操作方法添加ResponseCache特性，ASP.NET Core就会自动添加cache-control报文头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class TimeController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        [ResponseCache(Duration = 10)]//缓存这个内容10秒</span><br><span class="line">        public DateTime GetTime([FromServices]Value value) &#123;</span><br><span class="line">            return DateTime.Now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端缓存"><a href="#服务器端缓存" class="headerlink" title="服务器端缓存"></a>服务器端缓存</h2><p>服务器端缓存位于浏览器和服务器执行代码之间。<br>如果ASP.NET Core中安装了“响应缓存中间件”，那么ASP.NET Core不仅会继续根据[ResponseCache]设置来生成cache-control响应报文头来设置客户端缓存，而且服务器端也会按照[ResponseCache]的设置来对响应进行服务器端缓存。服务器端的缓存对不同客户端都生效，而客户端缓存只对自身生效。<br>用法：<br>app.MapControllers()之前app.UseCors()之后加上app.UseResponseCaching()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure><p>大部分浏览器的“开发者工具”中可以禁用缓存，如果禁用了缓存，则在请求报文头中加入了”cache-control:no-cache”，如果加了该请求头，服务器端缓存和浏览器端缓存都会失效。<br>服务器端响应缓存还有很多限制，包括但不限于：响应状态码为200的GET或者HEAD请求才可能被缓存；报文头中不能含有Authorization、Set-Cookie等。<br>最好采用内存缓存、分布式缓存等。</p><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>1、把缓存数据放到应用程序的内存。内存缓存中保存的是一系列的键值对，就像字典类型一样。<br>2、内存缓存的数据保存在当前运行的网站程序的内存中，是和进程相关的。因为在web服务器中，多个不同网站是运行在不同的进程中的，因此不同网站的内存缓存是不会互相干扰的，而且网站重启后，内存缓存中的所有数据也就都被清空了。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>1、启用：builder.Services.AddMemoryCache()<br>2、注入IMemoryCache接口，查看接口的方法：TryGetValue、Remove、Set、GetOrCreate、GerOrCreateAsync</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">[ApiController]</span><br><span class="line">public class BookController : ControllerBase &#123;</span><br><span class="line">    private readonly IMemoryCache _memoryCache;//注入</span><br><span class="line">    public BookController(IMemoryCache memoryCache) &#123;</span><br><span class="line">        _memoryCache = memoryCache;</span><br><span class="line">    &#125;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    public async Task&lt;ActionResult&lt;Book?&gt;&gt; GetBookById(int Id) &#123;</span><br><span class="line">        var book = await _memoryCache.GetOrCreateAsync(&quot;Book&quot; + Id, async (e) =&gt; &#123;</span><br><span class="line">            return await DataBase.GetBookAsync(Id);</span><br><span class="line">        &#125;);</span><br><span class="line">        if(book == null) &#123;</span><br><span class="line">            return NotFound(&quot;未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Ok(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DataBase &#123;</span><br><span class="line">        public static Task&lt;Book?&gt; GetBookAsync(int Id) &#123;</span><br><span class="line">            return Task.FromResult(DataBase.GetBook(Id));</span><br><span class="line">        &#125;</span><br><span class="line">        public static Book? GetBook(int Id) &#123;</span><br><span class="line">            switch (Id) &#123;</span><br><span class="line">                case 1: return new Book() &#123; Id = 1, Name = &quot;C#图解教程&quot; &#125;;</span><br><span class="line">                case 2: return new Book() &#123; Id = 2, Name = &quot;Java从入门到精通&quot; &#125;;</span><br><span class="line">                case 3: return new Book() &#123; Id = 3, Name = &quot;C语言入门&quot; &#125;;</span><br><span class="line">                default: return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存过期"><a href="#缓存过期" class="headerlink" title="缓存过期"></a>缓存过期</h3><p>1、在数据改变的时候调用Remove或者Set来删除或者修改缓存。<br>2、绝对过期时间：<br>到了设定的时间就清除指定的缓存。<br>在GetOrCreateAsync()方法的回调函数中有一个ICacheEntry类型的的参数，通过ICacheEntry对当前的缓存项做设置。<br>AbsoluteExpirationRelativeToNow用来设定缓存项的绝对过期时间。<br>3、滑动过期时间：<br>在设定时间内如果继续发请求，就续命。<br>ICacheEntry的SlidingExpiration属性用来设定缓存项的滑动过期时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var book = await _memoryCache.GetOrCreateAsync(&quot;Book&quot; + Id, async (e) =&gt; &#123;</span><br><span class="line">    Console.WriteLine(&quot;去数据库找ID为&quot; + Id + &quot;的书&quot;);</span><br><span class="line">    e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(30);//30秒绝对过期时间</span><br><span class="line">    e.SlidingExpiration = TimeSpan.FromSeconds(10);//10秒滑动过期时间</span><br><span class="line">    return await DataBase.GetBookAsync(Id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>混合过期时间：<br>使用滑动过期实践策略，如果一个缓存项一直被频繁访问，那么这个缓存项就会一直被续期而不过期。可以对一个缓存项同时设定滑动过期时间和绝对过期时间，并且把绝对过期时间设定的比滑动过期时间长，这样缓存项的内容会在绝对过期时间内伴随着访问被滑动续期，但是一超过绝对过期时间，缓存项就会被删除。</p><h1 id="缓存的问题"><a href="#缓存的问题" class="headerlink" title="缓存的问题"></a>缓存的问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var book = _memoryCache.Get&lt;Book?&gt;(&quot;Book&quot; + Id);</span><br><span class="line">if(book == null) &#123;//缓存中不存在</span><br><span class="line">    book = await DataBase.GetBookAsync(Id);</span><br><span class="line">    _memoryCache.Set(&quot;Book&quot; + Id, book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，当我们从缓存中得到了null，我们就认为缓存中不存在，于是在数据库中查询。但如果数据库中本来就不存在也会返回null，这样会造成一个问题，如果用户请求一个不存在的书ID，就会不停的访问数据库，这样的漏洞称为缓存穿透。<br>解决方法：<br>把查不到也当做一个数据放入缓存中。<br>当我们使用GetOrCreateAsync()方法时，该方法会把null当成合法的缓存值，所以即便不喜欢用回调函数也要尽量使用GetOrCreateAsync()方法。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>如果缓存中有很多数据，在固定的时间后统一失效，然后同时去数据库重新获取，就会造成数据库周期性的负载增大，进而造成缓存雪崩。<br>解决方法：<br>在基础过期时间之上，再加一个随机的过期时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(Random.Shared.Next(10,15));//随机10-15秒的过期时间</span><br></pre></td></tr></table></figure><h2 id="缓存数据混乱"><a href="#缓存数据混乱" class="headerlink" title="缓存数据混乱"></a>缓存数据混乱</h2><p>解决方法：合理给Key命名。</p><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>IQueryable、IEnumerable类型可能存在延迟加载的问题，如果把这两种类型的变量指向的对象保存到缓存中，在我们把它们取出来再去执行的时候，如果它们延迟加载时候需要的对象已经被释放，就会执行失败，因此需要禁止缓存这两种类型。</p><h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>如果集群节点的数量非常多的话，每个节点的数据不能共享，每个节点都需要相同的数据，就会到数据库服务器重复查询，可能会把数据库压垮。<br>不是再读取内存中的缓存，而是创建一个缓存服务器来存储缓存数据。<br>1、常用的分布式缓存服务器有Redis、Memcached等。<br>2、.Net Core中没有内置分布式缓存，但是提供了统一的分布式缓存服务器的操作接口IDistributedCache，用法和内存缓存类似，用于可以更好的使用不同的分布式缓存服务器。<br>3、分布式缓存和内存缓存的区别：缓存值的类型为byte[]，需要我们进行类型转换，也提供了一些按照string类型存取缓存的扩展方法，string类型在底层还是转换成char[]。<br><img src="/images/Asp.NetCore%E5%88%9D%E7%BA%A7%E7%AF%87/1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book book = new Book();</span><br><span class="line">JsonSerializer.Deserialize&lt;Book&gt;(&quot;json字符串&quot;);//将json字符串转为对应对象</span><br><span class="line">JsonSerializer.Serialize(book);//将对象转为json字符串</span><br></pre></td></tr></table></figure><p>用SQLSever做缓存性能不好。<br>Memcached是缓存专用，性能高但是集群、高可用等方面较弱，而且有“缓存键的最大长度为250字节”等限制。可以安装EnyimMemcachedCore这个第三方NuGet包。<br>Redis不局限于缓存，虽然性能比Memcached性能稍差，但高可用、集群等非常强大，适合在数据量大、高可用性等场合使用。<br>我用Redis做个演示：<br>1、安装Microsoft.Extensions.Caching.StackExchangeRedis包。<br>2、注册服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddStackExchangeRedisCache(options =&gt;&#123;</span><br><span class="line">    options.Configuration = &quot;localhost&quot;;//缓存服务器地址</span><br><span class="line">    options.InstanceName = &quot;Cache1_&quot;;//Key的前缀，避免和其他数据冲突</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、使用服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private readonly IMemoryCache _memoryCache;//注入</span><br><span class="line">private readonly IDistributedCache _distributedCache;//注入</span><br><span class="line">public BookController(IMemoryCache memoryCache, IDistributedCache distributedCache) &#123;</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    _distributedCache = distributedCache;</span><br><span class="line">&#125;</span><br><span class="line">[HttpGet]</span><br><span class="line">public async Task&lt;ActionResult&lt;Book&gt;&gt; GetBookRedis(int Id) &#123;</span><br><span class="line">    Book? book;</span><br><span class="line">    string? str = await _distributedCache.GetStringAsync(&quot;Book&quot; + Id);</span><br><span class="line">    if(str == null) &#123;</span><br><span class="line">        await Console.Out.WriteLineAsync(&quot;去数据库查找&quot;);</span><br><span class="line">        book =await DataBase.GetBookAsync(Id);</span><br><span class="line">        await _distributedCache.SetStringAsync(&quot;Book&quot;+Id,JsonSerializer.Serialize(book));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        book = JsonSerializer.Deserialize&lt;Book&gt;(str);</span><br><span class="line">    &#125;</span><br><span class="line">    if (book == null) &#123;</span><br><span class="line">        Console.WriteLine(&quot;未找到ID为&quot; + Id + &quot;的书&quot;);</span><br><span class="line">        return NotFound(&quot;未找到&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Console.WriteLine(&quot;找到了ID为&quot; + Id + &quot;的书&quot;);</span><br><span class="line">        return Ok(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis不会出现缓存穿透问题，但需要自己处理一下缓存雪崩问题。</p>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> .NET </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_依赖注入</title>
      <link href="/2023/09/07/Asp.NetCore-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/07/Asp.NetCore-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h2 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h2><p>在ASP.NET Core项目中一般不需要自己创建ServiceCollection、IServiceProvider。在Program.cs的builder.Build()之前向builder.Services中注入。</p><p>在Controller中可以通过构造方法注入服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//控制器</span><br><span class="line"></span><br><span class="line">[Route(&quot;[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class SumController : ControllerBase &#123;</span><br><span class="line"></span><br><span class="line">        private readonly Value value;</span><br><span class="line"></span><br><span class="line">        public SumController(Value value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpGet]</span><br><span class="line"></span><br><span class="line">        public int GetValue() &#123;</span><br><span class="line">            return this.value.Sum(3, 4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Value &#123;</span><br><span class="line">        public int Sum(int a,int b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Program.cs</span><br><span class="line"></span><br><span class="line">builder.Services.AddScoped&lt;Value&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="低使用频率的服务"><a href="#低使用频率的服务" class="headerlink" title="低使用频率的服务"></a>低使用频率的服务</h2><p>可以把action用到的服务通过action的参数注入，在这个参数上标注[FromServices]。和action的其他参数不冲突。</p><p>一般不需要，只有调用频率不高并且资源的创建比较消耗资源的服务才[FromServices]。</p><p>只有action方法才能用[FromServices]，普通的类默认不支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//其余地方不变，只修改控制器即可</span><br><span class="line"></span><br><span class="line">public class SumController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public int GetValue([FromServices]Value value) &#123;</span><br><span class="line">            return value.Sum(6, 8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> .NET </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Asp.NetCore_基本使用</title>
      <link href="/2023/09/07/Asp.NetCore-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/07/Asp.NetCore-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="初识ASP-NET-CORE-Web-Api"><a href="#初识ASP-NET-CORE-Web-Api" class="headerlink" title="初识ASP.NET CORE Web Api"></a>初识ASP.NET CORE Web Api</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.AspNetCore.Http;</span><br><span class="line">using Microsoft.AspNetCore.Mvc;</span><br><span class="line">namespace AspTest.Controllers &#123;</span><br><span class="line">    [Route(&quot;api/[controller]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class TestController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public UserInfoRequest UserInfo() &#123;</span><br><span class="line">            var UserInfo =  new UserInfoRequest();</span><br><span class="line">            UserInfo.Email = &quot;abc@123.com&quot;;</span><br><span class="line">            UserInfo.Name = &quot;Test&quot;;</span><br><span class="line">            UserInfo.Password = &quot;password&quot;;</span><br><span class="line">            return UserInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public string UserInfoRequery(UserInfoRequest userInfo) &#123;</span><br><span class="line">            Console.WriteLine(userInfo.Name);</span><br><span class="line">            Console.WriteLine(userInfo.Email);</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Route特性内为访问路径。<br>web api比mvc少了视图，它的控制器依然以xxxController命名并且控制器类被[ApiController修饰]，其中xxx表示控制器的名字，它需要继承ControllerBase，当浏览器访问&#x2F;xxx路径时默认发起Get请求。<br>[HttpGet]、[HttpPost]用于修饰方法，该方法的返回值为http请求的响应内容（默认JSON）。<br><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/1.jpg"><br><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/2.jpg"></p><h1 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h1><p>web api风格有两种，一种是面向过程（RPC），一种是面向REST。</p><h2 id="RPC："><a href="#RPC：" class="headerlink" title="RPC："></a>RPC：</h2><p>通过“控制器&#x2F;操作方法”（有点像mvc）的形式把服务器端的代码当成方法去调用。把http当成传输数据的通道，不关心http谓词，通过QueryString、请求报文体给服务器传递数据，状态码。比如：&#x2F;Person&#x2F;GetAll、&#x2F;Person&#x2F;GetById?id&#x3D;8</p><h2 id="REST："><a href="#REST：" class="headerlink" title="REST："></a>REST：</h2><p>按照http语义来使用http协议。<br>URL用于资源的定位：&#x2F;user&#x2F;888、&#x2F;user&#x2F;888&#x2F;orders<br>http谓词有GET POST PUT DELETE PATCH等<br>DELETE PUT GET是幂等的<br>服务器端通过状态码来反应资源获取结果如404 403 201</p><h3 id="REST的优点"><a href="#REST的优点" class="headerlink" title="REST的优点"></a>REST的优点</h3><p>可以对GET、PUT、DELETE请求进行重试；<br>可以用GET请求做缓存；<br>通过HTTP状态码反映服务器端的处理结果，统一错误处理机制<br>网关等可以分析请求处理结果；</p><h3 id="REST的不足"><a href="#REST的不足" class="headerlink" title="REST的不足"></a>REST的不足</h3><p>很难清晰地进行资源的划分；<br>系统的进化可能会改变幂等；<br>有些环节会篡改非200响应码的响应报文；<br>有的客户端不支持PUT、DELETE</p><h1 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h1><p>方式：<br>URL、QueryString、请求报文体（不支持Get、Delete）</p><h2 id="RPC风格请求数据传递"><a href="#RPC风格请求数据传递" class="headerlink" title="RPC风格请求数据传递"></a>RPC风格请求数据传递</h2><p>控制器上[Route(“[controller]&#x2F;[action]”)]表示通过控制器名和方法名进行定位<br>强制要求控制器中不同的操作用不同的方法名<br>把[HttpGet]、[HttpPost]等添加到对应操作方法上<br>注意：如果控制器中存在一个没有添加[HttpGet]、[HttpPost]等的public方法，swagger就会报错，可以用[ApiExploreSetting(IgnoreApi &#x3D; true)]<br>action方法支持方法重载，GET和POST可以使用同名的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">namespace AspTest.Controllers &#123;</span><br><span class="line">    [Route(&quot;api/[controller]/[action]&quot;)]</span><br><span class="line">    [ApiController]</span><br><span class="line">    public class StudentController : ControllerBase &#123;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public Student? GetStdInfo(int id) &#123;</span><br><span class="line">            if (id == 18) &#123;</span><br><span class="line">                return new Student(&quot;张三&quot;, 20, 18);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/3.jpg"></p><h2 id="控制器与返回值"><a href="#控制器与返回值" class="headerlink" title="控制器与返回值"></a>控制器与返回值</h2><p>控制器可以不继承ControllerBase，不继承的类更方便单元检测，但是会少了很多好用的方法，所以一般建议继承。<br>action函数支持异步。<br>可以让action函数返回IActionResult类型，但是不包含类型信息，因而Swagger等无法推断出类型，需要手动通过Ok()或NotFount()等方法转为IActionResult格式，所以更推荐用ActionResult&lt;T&gt;类型做返回值，T为实际返回类型，它支持类型转换（重写了隐式转换运算），从而用起来更简单。<br>web api中Action方法的返回值如果是普通数据类型，那么返回值就会默认被序列化为Json格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet]</span><br><span class="line">        public IActionResult GetStdInfo(int id) &#123;</span><br><span class="line">            if (id == 1) &#123;</span><br><span class="line">                return Ok(new Student(&quot;张三&quot;, 20, 1));</span><br><span class="line">            &#125; else if (id == 2) &#123;</span><br><span class="line">                return Ok(new Student(&quot;李四&quot;, 21, 2));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return NotFound(&quot;学生不存在&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpGet]</span><br><span class="line">        public ActionResult&lt;Student&gt; GetStudent(int id) &#123;</span><br><span class="line">            if (id == 1) &#123;</span><br><span class="line">            //可以将任何类型转为ActionResult类型</span><br><span class="line">                return new Student(&quot;张三&quot;, 20, 1);</span><br><span class="line">            &#125; else if (id == 2) &#123;</span><br><span class="line">                return new Student(&quot;李四&quot;, 21, 2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            //非泛型ActionResult可以隐式转换为泛型ActionResult</span><br><span class="line">                return NotFound(&quot;学生不存在&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Action方法的参数"><a href="#Action方法的参数" class="headerlink" title="Action方法的参数"></a>Action方法的参数</h2><p>1、在[HttpGet]、[HttpPost]等中使用占位符比如{schoolName}捕捉路径中的内容，从而供Action方法的参数使用。<br>[HttpGet(“&#x2F;School&#x2F;{SchoolName}&#x2F;class&#x2F;{classNum}”)]<br>捕捉的值会自动赋值给Action中的同名参数，如果名字不一致可以用[FromRoute(Name&#x3D;”名字”)]。<br>2、使用[FromQuery]来获取QueryString中的值，如果名字一致，只要为参数添加[FromQuery]即可；如果名字不一致，则需要[FromQuery{Name&#x3D;”名字”}]，与[FromRoute(Name&#x3D;”名字”)]使用方法一致，这里不做演示。<br>3、QueryString和Route可以混用。<br>注意：一定要设置请求头中的Content-Type为application&#x2F;json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[HttpGet]</span><br><span class="line">        public UserInfoRequest UserInfo(string Name) &#123;//localhost:7190/Test?Name=张三  从QueryString获取参数</span><br><span class="line">            var UserInfo =  new UserInfoRequest();</span><br><span class="line">            UserInfo.Email = &quot;abc@123.com&quot;;</span><br><span class="line">            UserInfo.Name = Name;</span><br><span class="line">            UserInfo.Password = &quot;password&quot;;</span><br><span class="line">            return UserInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public string UserInfoRequery(UserInfoRequest userInfo) &#123;//localhost:/Test/从请求体获取参数</span><br><span class="line">            Console.WriteLine(userInfo.Name);</span><br><span class="line">            Console.WriteLine(userInfo.Email);</span><br><span class="line">            return &quot;ok&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpGet(&quot;&#123;Value1&#125;/&#123;Value2&#125;&quot;)]//localhost:7190/Test/66/99  从URL获取params参数</span><br><span class="line">        public string GetValues(int Value1, int Value2) &#123;</span><br><span class="line">            return $&quot;Value1:&#123;Value1&#125;,Value2:&#123;Value2&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpGet(&quot;A/&#123;B&#125;/C/&#123;D&#125;&quot;)]</span><br><span class="line">        public object GetABCD(int B, [FromRoute(Name =&quot;D&quot;)] int Dd) &#123;//localhost:7190/Test/GetABCD/A/66/C/99</span><br><span class="line">            return new &#123; B=B , D=Dd &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpGet(&quot;&#123;id&#125;&quot;)]</span><br><span class="line">        public object MixTest([FromRoute] int id, string name) &#123;//localhost:7190/Test/MixTest/3?name=张三</span><br><span class="line">            return new &#123; id = id, name = name &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Asp.NetCore%E5%85%A5%E9%97%A8%E7%AF%87/4.jpg"><br>从Content-Type为multipart&#x2F;from-data的请求中获取数据的[FromFrom]。<br>从请求报文头中获取值的[FromHeader]。</p><h1 id="处理跨域"><a href="#处理跨域" class="headerlink" title="处理跨域"></a>处理跨域</h1><p>CORS原理：在服务器的响应报文头中通过access-control-allow-origin告诉浏览器允许跨域访问的域名。<br>在Program.cs的 “var app &#x3D; builder.Build()” 这句之前注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string[] urls = new []&#123;&quot;http://localhost:3000&quot;&#125;;</span><br><span class="line">builder.Services.AddCors(</span><br><span class="line">    options=&gt;&#123;</span><br><span class="line">        options.AddDefaultPolicy(</span><br><span class="line">            builder=&gt;builder.WithOrigins(urls)</span><br><span class="line">            .AllowAnyMethods()</span><br><span class="line">            .AllowAnyHeader()</span><br><span class="line">            .AllowCredentials();</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在Program.cs的 “app.UseHttpsRedirection()”这句代码之前加一句”app.UseCors();”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseCors();//使用中间件</span><br><span class="line">app.UseHttpsRedirection();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Asp.NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Asp.NetCore </tag>
            
            <tag> .NET </tag>
            
            <tag> REST </tag>
            
            <tag> RPC </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置系统</title>
      <link href="/2023/09/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/05/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>配置系统官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/configuration">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/configuration</a><br>.Net配置系统支持丰富的配置源包括文件、注册表、环境变量、命令行、Azure Key Vault等，还可以配置自定义配置源。可以跟踪配置的改变，可以按照优先级覆盖。<br>还支持ini、xml等格式的配置源。<br>还支持在运行时、调试时加载不同的json文件。<br>还内置或第三方支持中心化配置服务器，比如使用Apollo、Nacos等开源服务器，或使用Azure、阿里云等的配置服务</p><h1 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a>JSON配置</h1><p>安装Microsoft.Extensions.Configuration（配置框架的包）和Microsoft.Extensions.Configuration.Json（读json的包）<br>新建json文件，设置属性如果较新就赋值。<br>config.json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;18&quot;,</span><br><span class="line">  &quot;proxy&quot;: &#123;&quot;address&quot;: &quot;aa&quot;,&quot;port&quot;: &quot;8080&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原始使用方式"><a href="#原始使用方式" class="headerlink" title="原始使用方式"></a>原始使用方式</h2><p>AddJsonFile()命名参数介绍<br>optional表示文件是否可选<br>reloadOnChange参数表示如果文件修改了，是否重新加载设置（可以不重启就加载）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">            configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">            IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">            //原始方式</span><br><span class="line">            string name = configurationRoot[&quot;name&quot;];</span><br><span class="line">            string address = configurationRoot.GetSection(&quot;proxy:address&quot;).Value;</span><br><span class="line">            Console.WriteLine($&quot;name = &#123;name&#125;&quot;);</span><br><span class="line">            Console.WriteLine($&quot;address = &#123;address&#125;&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="绑定对象方式"><a href="#绑定对象方式" class="headerlink" title="绑定对象方式"></a>绑定对象方式</h2><p>安装Microsoft.Extensions.Configuration.Binder<br>有自动类型转换，自定义的类的属性名应与配置文件中的键名一致（拼写一致就行，不区分大小写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">            configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">            IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">            //绑定对象方式</span><br><span class="line">            Proxy proxy = configurationRoot.GetSection(&quot;proxy&quot;).Get&lt;Proxy&gt;();</span><br><span class="line">            Console.WriteLine($&quot;&#123;proxy.Address&#125;:&#123;proxy.Port&#125;&quot;);</span><br><span class="line">            Config config = configurationRoot.Get&lt;Config&gt;();</span><br><span class="line">            Console.WriteLine($&quot;&#123;config.Name&#125;,&#123;config.Age&#125;,&#123;config.Proxy.Address&#125;,&#123;config.Proxy.Port&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Config &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public string Age &#123; get; set; &#125;</span><br><span class="line">        public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Proxy &#123;</span><br><span class="line">        public string Address &#123; get; set; &#125;</span><br><span class="line">        public int Port &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入方式（更推荐）"><a href="#依赖注入方式（更推荐）" class="headerlink" title="依赖注入方式（更推荐）"></a>依赖注入方式（更推荐）</h2><p>在需要读取配置的地方，用IOptionsSnapshot&lt;T&gt;注入。不要在构造函数里直接读取IOptionsSnapshot.Value，而是到用到的地方再读取，否则就无法更新变化。<br>读取配置时，DI要声明IOptions&lt;T&gt;（旧的值）、IOptionsMonitor&lt;T&gt;（新的值）、IOptionsSnapshot&lt;T&gt;（一个范围内新的值）等类型，建议用IOptionsSnapshot。<br>安装：<br>Microsoft.Extensions.Configuration.Binder<br>Microsoft.Extensions.Configuration<br>Microsoft.Extensions.Configuration.Json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           ServiceCollection services = new ServiceCollection();</span><br><span class="line">           services.AddScoped&lt;TestController&gt;();</span><br><span class="line">           services.AddScoped&lt;Test2&gt;();</span><br><span class="line"> </span><br><span class="line">           ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">           configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">           IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line"></span><br><span class="line">           services.AddOptions()</span><br><span class="line">               .Configure&lt;Config&gt;(e =&gt; configurationRoot.Bind(e))//DI将根节点绑定到Config对象上并且将Config类型注册到依赖注入容器中</span><br><span class="line">               .Configure&lt;Proxy&gt;(e=&gt; configurationRoot.GetSection(&quot;proxy&quot;).Bind(e));//将proxy节点绑定到Proxy对象上并且将Proxy类型注册到依赖注入容器中</span><br><span class="line"></span><br><span class="line">           using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">               //因为我们使用了IOptionSnapshot，所以修改文件时不会改变，相当于在一个大scope中</span><br><span class="line">               while (true) &#123;</span><br><span class="line">                   //如果想改变时获取新的数据，可以手动新建scope</span><br><span class="line">                   using(var scope = sp.CreateScope()) &#123;</span><br><span class="line">                       var c = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                       c.Test();</span><br><span class="line">                       Console.WriteLine(&quot;改一下age&quot;);</span><br><span class="line">                       Console.ReadLine();</span><br><span class="line">                       c.Test();</span><br><span class="line">                       var c2 = scope.ServiceProvider.GetRequiredService&lt;Test2&gt;();</span><br><span class="line">                       c2.Test();</span><br><span class="line">                       //注意：你无法通过以下方式获取配置对象</span><br><span class="line">                       //var config = scope.ServiceProvider.GetRequiredService&lt;Config&gt;();</span><br><span class="line">                   &#125;</span><br><span class="line">                   Console.WriteLine(&quot;点击任意键继续&quot;);</span><br><span class="line">                   Console.ReadLine();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Config &#123;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">       public string Age &#123; get; set; &#125;</span><br><span class="line">       public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Proxy &#123;</span><br><span class="line">       public string Address &#123; get; set; &#125;</span><br><span class="line">       public int Port &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class TestController &#123;</span><br><span class="line">       //创建IOptionsSnapshot&lt;&gt;类型成员，为依赖注入提供条件</span><br><span class="line">       public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">       public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">           this.optConfig = optConfig;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(this.optConfig.Value.Age);</span><br><span class="line">           Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class Test2 &#123;</span><br><span class="line">       private readonly IOptionsSnapshot&lt;Proxy&gt; optProxy;</span><br><span class="line">       public Test2(IOptionsSnapshot&lt;Proxy&gt; optProxy) &#123;</span><br><span class="line">           this.optProxy = optProxy;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(optProxy.Value.Address);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h1><h2 id="命令行简单配置："><a href="#命令行简单配置：" class="headerlink" title="命令行简单配置："></a>命令行简单配置：</h2><p>安装Microsoft.Extensions.Configuration.CommandLine<br>支持 server &#x3D; 127.0.0.1、–server&#x3D;127.0.0.1、 –server 127.0.0.1等，注意在键值之间加空格，格式不能混用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            services.AddScoped&lt;TestController&gt;();</span><br><span class="line">            services.AddScoped&lt;Test2&gt;();</span><br><span class="line">            ConfigurationBuilder configBuder = new ConfigurationBuilder();</span><br><span class="line">            configBuder.AddCommandLine(args);//推荐传这个</span><br><span class="line">            IConfigurationRoot configRoot = configBuder.Build();</span><br><span class="line">            services.AddOptions()</span><br><span class="line">                .Configure&lt;Config&gt;(e =&gt; configRoot.Bind(e))</span><br><span class="line">                .Configure&lt;Proxy&gt;(e =&gt; configRoot.GetSection(&quot;Proxy&quot;));</span><br><span class="line">            using(var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                while(true) &#123;</span><br><span class="line">                    using(var scope = sp.CreateScope()) &#123;</span><br><span class="line">                        var c1 = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                        var c2 = scope.ServiceProvider.GetRequiredService&lt;Test2&gt;();</span><br><span class="line">                        c1.Test();</span><br><span class="line">                        c2.Test();</span><br><span class="line">                        Console.ReadLine();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Config &#123;</span><br><span class="line">            public string Name &#123; get; set; &#125;</span><br><span class="line">            public int Age &#123; get; set; &#125;</span><br><span class="line">            public Proxy proxy &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public class Proxy &#123;</span><br><span class="line">            public string Address &#123; get; set; &#125;</span><br><span class="line">            public int Port &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        internal class TestController &#123;</span><br><span class="line">       public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">       public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">           this.optConfig = optConfig;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(this.optConfig.Value.Age);</span><br><span class="line">           Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   internal class Test2 &#123;</span><br><span class="line">       private readonly IOptionsSnapshot&lt;Proxy&gt; optProxy;</span><br><span class="line">       public Test2(IOptionsSnapshot&lt;Proxy&gt; optProxy) &#123;</span><br><span class="line">           this.optProxy = optProxy;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Test() &#123;</span><br><span class="line">           Console.WriteLine(optProxy.Value.Address);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以这样运行：<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/1.jpg"><br>或者使用vs右键项目-&gt;属性-&gt;调试-&gt;启动配置文件：<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/2.jpg"></p><h2 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h2><p>对于多级结构需要用root:key&#x3D;value的方式来进行扁平化处理<br><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/3.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Config &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public int Age &#123; get; set; &#125;</span><br><span class="line">        public Proxy proxy &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Proxy &#123;</span><br><span class="line">        public string Address &#123; get; set; &#125;</span><br><span class="line">        public int Port &#123; get; set; &#125;</span><br><span class="line">        public int[] Ids &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    internal class TestController &#123;</span><br><span class="line">    public readonly IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">    public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line">        this.optConfig = optConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Test() &#123;</span><br><span class="line">        Console.WriteLine(optConfig.Value.Name);</span><br><span class="line">        Console.WriteLine(optConfig.Value.Age);</span><br><span class="line">        Console.WriteLine(&quot;===============&quot;);</span><br><span class="line">        Console.WriteLine(optConfig.Value.proxy.Address);</span><br><span class="line">        Console.WriteLine(optConfig.Value.proxy.Port);</span><br><span class="line">        Console.WriteLine(string.Join(&#x27;,&#x27;, optConfig.Value.proxy.Ids));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><img src="/images/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/4.jpg"><br>注意遇到深层次结构还是需要做扁平化处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configBuder.AddEnvironmentVariables();</span><br></pre></td></tr></table></figure><p>还可以传一个名为prefix的字符串参数，这个参数是所需要的环境变量的前缀为了防止和系统其他环境变量冲突，记得修改自己写的环境变量为其添加前缀。</p><h1 id="开发自己的配置提供者"><a href="#开发自己的配置提供者" class="headerlink" title="开发自己的配置提供者"></a>开发自己的配置提供者</h1><p>1、开发一个直接或间接实现IConfigurationProvider接口的类XXXConfigurationProvider，一般直接继承ConfigurationProvider。如果是从文件读取，可以继承自FileConfigurationProvider。重写Load方法，把”扁平化数据”设置到Data属性即可。<br>2、再开发一个实现了IConfigurationSource接口的类XXXIConfigurationSource。如果是从文件读取，可以继承自FileConfigurationSource。在Build方法中返回上面的ConfigurationProvider对象。<br>3、然后使用即可，configurationBuilder.Add(new ConfigurationSource())即可。为了简化使用，一般提供一个IConfigurationBuilder的扩展方法<br>整体流程：<br>编写ConfigurationProvider类实际读取配置；编写ConfigurationSource在Build中返回ConfigurationProvider对象；把ConfigurationSource对象加入IConfigurationBuilder。记得在返回之前加一句EnsureDefaults(builder)用于处理默认值问题。<br>配置文件格式：<br>开发web.config提供者<br>.net core中不建议使用.net framework里的web.config，不过仍然继续提供了ConfigurationManager的方式。我们来实现一个能够读取web.config里的connectionStrings和appSettings的内容<br>具体内容我没看明白，请看杨中科老师的视频吧：<a href="https://www.bilibili.com/video/BV1pK41137He?p=43&vd_source=b855e022b9c5c6c637f3aa9babc2e438">https://www.bilibili.com/video/BV1pK41137He?p=43&amp;vd_source=b855e022b9c5c6c637f3aa9babc2e438</a></p><h1 id="多配置源"><a href="#多配置源" class="headerlink" title="多配置源"></a>多配置源</h1><p>比如某个网站需要自定义配置；程序员的同一台机器上，开发调试环境和测试环境用不同的配置。<br>按照注册到ConfigurationBuilder的顺序，后来者居上，后注册的优先级高，如果配置名字重复，用后注册的值</p><h1 id="保命的UserSecrets"><a href="#保命的UserSecrets" class="headerlink" title="保命的UserSecrets"></a>保命的UserSecrets</h1><p>.net提供了user-secrets机制，user-secrets的配置不会放到源代码中<br>不能泄露到源码中的配置放到user-secrets即可，不用都放<br>一般把user-secrets优先级放到普通json文件之后。<br>如果开发人员电脑重装系统等原因造成本地的配置文件被删除了，就需要重新配置<br>并不是生产中的加密，只适用于开发<br>安装：<br>Microsoft.Extensions.Configuration.UserSecrets<br>在vs项目上点右键【管理用户机密】，编辑这个配置文件。看看这个文件在哪里。在csproj中的UserSecretsld就是文件夹的名字<br>configBuilder.AddUserSecrets&lt;Program&gt;()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//secrets.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;password&quot;:&quot;secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//主程序</span><br><span class="line">var builder = new ConfigurationBuilder();</span><br><span class="line">builder.AddJsonFile(&quot;config.json&quot;, true, true);</span><br><span class="line">builder.AddCommandLine(args);</span><br><span class="line">builder.AddUserSecrets&lt;Program&gt;();</span><br></pre></td></tr></table></figure><p>记得在除了secrets.json以外的所有配置地方删除私密的数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建容器</span><br><span class="line">ServiceCollection services = new ServiceCollection();</span><br><span class="line">//添加服务</span><br><span class="line">services.AddScoped\&lt;TestController&gt;();</span><br><span class="line">//创建提供方</span><br><span class="line">var sp = services.BuildServiceProvider();</span><br><span class="line">//获取对象</span><br><span class="line">sp.GetService\&lt;Test&gt;();</span><br></pre></td></tr></table></figure><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建配置创建者 </span><br><span class="line">ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();</span><br><span class="line">//添加配置方</span><br><span class="line">configurationBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">//创建根节点</span><br><span class="line">IConfigurationRoot configurationRoot = configurationBuilder.Build();</span><br><span class="line">//通过根节点找到数据</span><br><span class="line">string address = configurationRoot.GetSection(&quot;proxy:address&quot;).Value;</span><br><span class="line">//或绑定对象</span><br><span class="line">Proxy proxy = configurationRoot.GetSection(&quot;proxy&quot;).Get&lt;Proxy&gt;();</span><br><span class="line">//或通过依赖注入绑定对象</span><br><span class="line">services.AddOptions()  </span><br><span class="line">               .Configure&lt;Config&gt;(e =&gt; configurationRoot.Bind(e))  </span><br><span class="line">               .Configure&lt;Proxy&gt;(e=&gt; configurationRoot.GetSection(&quot;proxy&quot;).Bind(e));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 配置系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元检测</title>
      <link href="/2023/09/04/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/"/>
      <url>/2023/09/04/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h2><p>当我们要查看某个方法是否有错误，我们可以创建一个专门用来测试的类，用于不调用主程序的情况下，在测试类中检测方法是否符合所期待的那样。这样的行为称为单元检测或单元测试。</p><h2 id="单元检测演示"><a href="#单元检测演示" class="headerlink" title="单元检测演示"></a>单元检测演示</h2><p>一台电脑如果想玩3A游戏的话当然需要一个好的显卡，能玩游戏的显卡就是好显卡，我们可以使用单元检测来判断。<br>主程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            IGraphicsCard card = new NVIDIA();</span><br><span class="line">            Console.WriteLine(card.Show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface IGraphicsCard &#123;</span><br><span class="line">        string Show();</span><br><span class="line">    &#125;</span><br><span class="line">    public class NVIDIA:IGraphicsCard &#123; </span><br><span class="line">        public string Show() &#123;</span><br><span class="line">            return &quot;正在玩原神&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class AMD:IGraphicsCard &#123; </span><br><span class="line">        public string Show() &#123;</span><br><span class="line">            return &quot;正在玩星穹铁道&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元检测程序：<br>请先创建单元测试项目<br><img src="/images/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/1.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using Test;//引用主程序名称空间</span><br><span class="line">namespace GraphicsCardTest &#123;</span><br><span class="line">    public class GraphicsCardTest &#123;//测试类</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test1() &#123;//测试方法</span><br><span class="line">            var gc = new NVIDIA();</span><br><span class="line">            var expected = &quot;正在玩原神&quot;;//如果NVIDIA显卡能玩原神则成功</span><br><span class="line">            var actual = gc.Show();</span><br><span class="line">            Assert.Equal(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test2() &#123;//测试方法</span><br><span class="line">            var gc = new AMD();</span><br><span class="line">            var expected = &quot;正在玩星穹铁道&quot;;//如果AMD显卡能玩星穹铁道则成功</span><br><span class="line">            var actual = gc.Show();</span><br><span class="line">            Assert.Equal(expected, actual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="/images/%E5%8D%95%E5%85%83%E6%A3%80%E6%B5%8B/2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 单元检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>依赖注入</title>
      <link href="/2023/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/09/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>依赖注入官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection">https://learn.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection</a><br>依赖注入的原理是——反射<br>如果想用依赖注入框架需要：<br>先用NuGet下载Microsoft.Extensions.DependencyInjection。<br>使用名称空间using Microsoft.Extensions.DependencyInjection;</p><h1 id="依赖注入框架的简单使用"><a href="#依赖注入框架的简单使用" class="headerlink" title="依赖注入框架的简单使用"></a>依赖注入框架的简单使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var sc = new ServiceCollection();//创建容器</span><br><span class="line">            sc.AddScoped(typeof(IStudent),typeof(Student));//接口描述，绑定该接口的类型的描述</span><br><span class="line">            var sp = sc.BuildServiceProvider();</span><br><span class="line">            // ==============================以下不再有new操作符</span><br><span class="line">            IStudent student = sp.GetService&lt;IStudent&gt;();</span><br><span class="line">            student.Study();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStudent &#123;</span><br><span class="line">        void Study();</span><br><span class="line">    &#125;</span><br><span class="line">    class Student : IStudent &#123;</span><br><span class="line">        public void Study() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我要学习&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 依赖注入的几个概念<br> 服务：就是你需要的对象；<br> 注册服务：对象不能凭空出现，需要先注册；<br> 服务容器：负责管理注册的服务<br> 查询服务：创建对象及关联对象；<br> 对象生命周期：Transient（瞬态）、Scoped（范围内单例）、Singleton（单例）；<br> 可以指定服务类型和实现类型，或者服务类型和实现类型是同一类型<br> 服务类型尽量用接口<br> 微软的控制反转组件（DependencyInjection）包含服务定位器和依赖反转</p><h1 id="服务定位器的写法"><a href="#服务定位器的写法" class="headerlink" title="服务定位器的写法"></a>服务定位器的写法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            //1、创建容器</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //2、注册服务</span><br><span class="line">            services.AddTransient&lt;TestServiceImp1&gt;();</span><br><span class="line">            //3、创建服务提供者（相当于服务定位器）</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //4、从提供者获取服务</span><br><span class="line">                TestServiceImp1 t1 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t1.Name = &quot;Test1&quot;;</span><br><span class="line">                t1.SayHi();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public void SayHi();</span><br><span class="line">    &#125;</span><br><span class="line">    public class TestServiceImp1 : ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public void SayHi() &#123;</span><br><span class="line">            Console.WriteLine(&quot;hi&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class TestServiceImp2 : ITestService &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public void SayHi() &#123;</span><br><span class="line">            Console.WriteLine(&quot;你好&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="瞬时模式与单例模式Transient、Singleton"><a href="#瞬时模式与单例模式Transient、Singleton" class="headerlink" title="瞬时模式与单例模式Transient、Singleton"></a>瞬时模式与单例模式Transient、Singleton</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //Transient</span><br><span class="line">            //services.AddTransient&lt;TestServiceImp1&gt;();</span><br><span class="line">            //Singleton</span><br><span class="line">            //services.AddSingleton&lt;TestServiceImp1&gt;();</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                TestServiceImp1 t1 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t1.Name = &quot;Test1&quot;;</span><br><span class="line">                TestServiceImp1 t2 = sp.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                t2.Name = &quot;Test2&quot;;</span><br><span class="line">                Console.WriteLine(object.ReferenceEquals(t1, t2));//判断是否为同一对象</span><br><span class="line">                Console.WriteLine(t1.Name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="范围模式Scope"><a href="#范围模式Scope" class="headerlink" title="范围模式Scope"></a>范围模式Scope</h2><p>Scope<br>如果一个类实现了IDisposable接口，则离开作用域之后，容器会自动调用对象的Dispose方法<br>不要在长生命周期的对象中引用比它短的声明周期的对象<br>生命周期的选择：<br>如果类无状态（无属性，无成员变量），建议为Singleton；如果类有状态，且有Scope控制，建议为Scoped，因为通常这种Scope控制下的代码都是运行在同一线程中，没有并发修改的问题；使用Transient要谨慎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //Scoped</span><br><span class="line">            services.AddScoped&lt;TestServiceImp1&gt;();</span><br><span class="line">            //老大sp</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //老大创造了小弟scope1</span><br><span class="line">                //创建范围，这个范围就是using的代码块</span><br><span class="line">                using (IServiceScope scope1 = sp.CreateScope()) &#123;</span><br><span class="line">                    //在scope中获取Scope相关的对象，scope1.ServiceProvider而不是sp</span><br><span class="line">                    //想获取服务不能直接问老大要，应该问小弟scope1要</span><br><span class="line">                    TestServiceImp1 t1 = scope1.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    TestServiceImp1 t2 = scope1.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    Console.WriteLine(object.ReferenceEquals(t1, t2));</span><br><span class="line">                &#125;</span><br><span class="line">                //老大创造小弟scope2</span><br><span class="line">                //创建范围，这个范围就是using的代码块</span><br><span class="line">                using (IServiceScope scope2 = sp.CreateScope()) &#123;</span><br><span class="line">                    //在scope中获取Scope相关的对象，scope1.ServiceProvider而不是sp</span><br><span class="line">                    //想获取服务不能直接问老大要，应该问小弟scope2要</span><br><span class="line">                    TestServiceImp1 t1 = scope2.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    TestServiceImp1 t2 = scope2.ServiceProvider.GetService&lt;TestServiceImp1&gt;();</span><br><span class="line">                    Console.WriteLine(object.ReferenceEquals(t1, t2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h2><p>当服务类型与实现类型不一致时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //泛型方法</span><br><span class="line">            services.AddScoped&lt;ITestService, TestServiceImp1&gt;();</span><br><span class="line">            services.AddScoped&lt;ITestService, TestServiceImp2&gt;();</span><br><span class="line">            //非泛型方法</span><br><span class="line">            //services.AddScoped(typeof(ITestService),typeof(TestServiceImp1));</span><br><span class="line">            //自定义单例对象</span><br><span class="line">            //services.AddSingleton(typeof(ITestService),new TestServiceImp1());</span><br><span class="line">            using (var sp = services.BuildServiceProvider()) &#123;</span><br><span class="line">                //获取服务时，&lt;&gt;里面是注册类型而不是实现类型</span><br><span class="line">                //如果找不到服务就返回null</span><br><span class="line">                ITestService ts1 = sp.GetService&lt;ITestService&gt;();</span><br><span class="line">                //如果找不到直接抛异常而不是返回null</span><br><span class="line">                //ITestService ts1 = sp.GetRequiredService&lt;ITestService&gt;();</span><br><span class="line">                //非泛型方法，返回object，使用时需要手动转换</span><br><span class="line">                //ITestService ts1 = (ITestService)sp.GetService(typeof(ITestService));</span><br><span class="line">                //一个注册类型对应多个实现类型时，可以获取全部</span><br><span class="line">                //如果不用GetServices而用GetService就以最后一个添加进来的为准</span><br><span class="line">                IEnumerable&lt;ITestService&gt; tests = sp.GetServices&lt;ITestService&gt;();</span><br><span class="line">                foreach (ITestService test in tests) &#123;</span><br><span class="line">                    Console.WriteLine(test.GetType());</span><br><span class="line">                &#125;</span><br><span class="line">                ts1.Name = &quot;Test1&quot;;</span><br><span class="line">                ts1.SayHi();</span><br><span class="line">                Console.WriteLine(ts1.GetType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="依赖注入写法"><a href="#依赖注入写法" class="headerlink" title="依赖注入写法"></a>依赖注入写法</h1><p>依赖注入是有传染性的，如果一个类的对象是通过DI创建的，那么这个类的构造函数中声明的所有服务类型的参数都会被DI赋值；但如果一个对象是程序员手动创建的，那么这个类就和DI没有关系，它的构造函数中声明的服务类型参数就不会被自动赋值。<br>.Net的DI默认是构造函数注入<br>你只管声明，其余交给DI<br>降低模块之间的耦合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            ServiceCollection services = new ServiceCollection();</span><br><span class="line">            //日志服务或者配置服务需要替换只需要在这里更改就行了</span><br><span class="line">            services.AddScoped&lt;Controller&gt;();</span><br><span class="line">            services.AddScoped&lt;ILog, LogImp1&gt;();</span><br><span class="line">            services.AddScoped&lt;IStorage, StorageImp1&gt;();</span><br><span class="line">            //如果从本地读取配置</span><br><span class="line">            //services.AddScoped&lt;IConfig, ConfigImp1&gt;();</span><br><span class="line">            //如果从数据库读取配置</span><br><span class="line">            services.AddScoped&lt;IConfig, DbConfig&gt;();</span><br><span class="line">            using(var sp =  services.BuildServiceProvider()) &#123;</span><br><span class="line">                var c = sp.GetRequiredService&lt;Controller&gt;();</span><br><span class="line">                c.Test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Controller &#123;</span><br><span class="line">        private readonly ILog log;</span><br><span class="line">        private readonly IStorage storage;</span><br><span class="line">        public Controller(ILog log, IStorage storage) &#123;</span><br><span class="line">            this.log = log;</span><br><span class="line">            this.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Test() &#123;</span><br><span class="line">            this.log.Log(&quot;开始上传&quot;);</span><br><span class="line">            this.storage.Save(&quot;asdfa&quot;, &quot;1.txt&quot;);</span><br><span class="line">            this.log.Log(&quot;上传完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface ILog &#123;</span><br><span class="line">        public void Log(string msg);</span><br><span class="line">    &#125;</span><br><span class="line">    class LogImp1 : ILog &#123;</span><br><span class="line">        public void Log(string msg) &#123;</span><br><span class="line">            Console.WriteLine($&quot;日志：&#123;msg&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IConfig &#123;</span><br><span class="line">        public string GetValue(string name);</span><br><span class="line">    &#125;</span><br><span class="line">    class ConfigImp1 : IConfig &#123;</span><br><span class="line">        public string GetValue(string name) &#123;</span><br><span class="line">            return &quot;SqlServer&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStorage &#123;</span><br><span class="line">        public void Save(string content,string name);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果从本地配置文件读取配置</span><br><span class="line">    class StorageImp1 : IStorage &#123;</span><br><span class="line">        private readonly IConfig config;</span><br><span class="line">        public StorageImp1(IConfig config) &#123;</span><br><span class="line">            this.config = config;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Save(string content, string name) &#123;</span><br><span class="line">            string server = config.GetValue(&quot;server&quot;);</span><br><span class="line">            Console.WriteLine($&quot;向服务器&#123;server&#125;的文件名为&#123;name&#125;上传&#123;content&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果从数据库读取配置</span><br><span class="line">    class DbConfig : IConfig &#123;</span><br><span class="line">        public string GetValue(string name) &#123;</span><br><span class="line">            return &quot;MySql&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/09/04/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/09/04/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>对某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。<br>有关程序及其类型的数据称为元数据，被保存在程序的程序集中。<br>程序在运行时，可以查看其他程序集或本身的元数据。这种行为叫做反射。<br>使用反射要使用System.Reflection命名空间。</p><h2 id="Type类"><a href="#Type类" class="headerlink" title="Type类"></a>Type类</h2><p>blc声明了一个Type抽象类，用来包含类型的特征，使用这个类的对象能获取程序使用的类型信息。<br>Type类成员<br><img src="/images/%E5%8F%8D%E5%B0%84/1.jpg"></p><h2 id="获取Type对象"><a href="#获取Type对象" class="headerlink" title="获取Type对象"></a>获取Type对象</h2><p>实例对象的GetType()方法和typeof()运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">           Student std = new Student();</span><br><span class="line">           Type type1 = std.GetType();</span><br><span class="line">           Type type2 = typeof(Student);</span><br><span class="line">           Type type3 = typeof(int);</span><br><span class="line">           Console.WriteLine(type1.Name);</span><br><span class="line">           Console.WriteLine(type1.Namespace);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Student &#123;</span><br><span class="line">       public int Id &#123; get; set; &#125;</span><br><span class="line">       public string Name &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            IStudent std = new Student();</span><br><span class="line">            Type s = std.GetType();//获取类型信息</span><br><span class="line">            object o = Activator.CreateInstance(s);//通过获取的类型信息创建object类型实例</span><br><span class="line">            MethodInfo stuMi = s.GetMethod(&quot;Study&quot;);//获取该类型的Study方法</span><br><span class="line">            stuMi.Invoke(o, null);//在指定对象上调用该方法，第二个参数是参数</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IStudent &#123;</span><br><span class="line">        int Id &#123; get; set; &#125;</span><br><span class="line">        string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Student : IStudent &#123;</span><br><span class="line">        public int Id &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public void Study() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我要学习&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="插件程序的开发"><a href="#插件程序的开发" class="headerlink" title="插件程序的开发"></a>插件程序的开发</h2><p>主体程序：<br>请先在程序目录下创建Animals文件夹，该文件用来存放插件，请将插件生成的dll放在该文件夹中，主体程序会遍历文件夹中的dll，从dll中通过反射获取类库的中所有具有Voice方法的类型信息，存放在animaTypes中，最后通过反射调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.Loader;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(Environment.CurrentDirectory);//请在该路径下创建Animals文件夹</span><br><span class="line">            var floder = Path.Combine(Environment.CurrentDirectory, &quot;Animals&quot;);</span><br><span class="line">            var files = Directory.GetFiles(floder);</span><br><span class="line">            var animalTypes = new List&lt;Type&gt;();</span><br><span class="line">            foreach (var file in files) &#123;</span><br><span class="line">                var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(file);</span><br><span class="line">                var types = assembly.GetTypes();</span><br><span class="line">                foreach (var t in types) &#123;</span><br><span class="line">                    if(t.GetMethod(&quot;Voice&quot;)!=null) &#123;</span><br><span class="line">                        animalTypes.Add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (true) &#123;</span><br><span class="line">                for(int i = 0; i&lt; animalTypes.Count; i++) &#123;</span><br><span class="line">                    Console.WriteLine($&quot;&#123;i+1&#125;,&#123;animalTypes[i].Name&#125;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;====================&quot;);</span><br><span class="line">                Console.WriteLine(&quot;Please choose animal&quot;);</span><br><span class="line">                int index = int.Parse(Console.ReadLine());</span><br><span class="line">                if(index&gt;animalTypes.Count || index&lt;1) &#123;</span><br><span class="line">                    Console.WriteLine(&quot;No such an animal.Try again!&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;How many times?&quot;);</span><br><span class="line">                int times = int.Parse(Console.ReadLine());</span><br><span class="line">                var t = animalTypes[index-1];</span><br><span class="line">                var m = t.GetMethod(&quot;Voice&quot;);</span><br><span class="line">                var o = Activator.CreateInstance(t);</span><br><span class="line">                m.Invoke(o, new object[] &#123; times &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace Animals &#123;</span><br><span class="line">    public class Cat &#123;</span><br><span class="line">        public void Voice(int times) &#123;</span><br><span class="line">            for(int i = 0; i &lt; times; i++) &#123;</span><br><span class="line">                Console.WriteLine(&quot;喵&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 反射 </tag>
            
            <tag> Type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程</title>
      <link href="/2023/08/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/08/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h2><p>默认情况下一个进程只包含一个线程。<br>线程可以派生其他线程，因此在任意时刻，一个进程可能包含不同状态的多个线程，它们执行程序的不同部分。<br>如果一个进程拥有多个线程，它们将共享进程的资源。<br>系统为处理器执行所调度的单元是线程，不是进程。</p><h2 id="异步编程演示"><a href="#异步编程演示" class="headerlink" title="异步编程演示"></a>异步编程演示</h2><p>异步获取百度的html然后异步写入test.txt文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            string str = await client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            string fileName = @&quot;F:\test.txt&quot;;</span><br><span class="line">            await File.WriteAllTextAsync(fileName,str);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方法在其完成所有工作之前就返回到调用方法。<br>主函数调用异步方法，然后主函数在异步方法执行时继续执行（可能在相同的线程也可能在不同的线程）<br>async：声明这种方法是异步的。<br>await：在异步方法内等待。</p><h2 id="异步方法的注意点"><a href="#异步方法的注意点" class="headerlink" title="异步方法的注意点"></a>异步方法的注意点</h2><p>异步方法头中用async修饰符，即使返回结果为空也应该将结果声明为Task.<br>异步方法包含一个或多个await。<br>异步方法必须返回void、Task、Task&lt;T&gt;、ValueTask&lt;T&gt;的其中之一。<br>异步方法应具有公开可访问的GetAwaiter方法类型。<br>异步方法名称一般以Async为后缀。<br>Lambda表达式和匿名方法也可以作为异步对象。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await操作符帮我们提供异步等待，并且可以将Task&lt;T&gt;所封装的真实值取出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            //不用await帮忙，我就要自己取</span><br><span class="line">            Task&lt;string&gt; str1 = client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            await Console.Out.WriteLineAsync(str1.Result);</span><br><span class="line">            //await帮我取值</span><br><span class="line">            string str2 = await client.GetStringAsync(@&quot;https:\\www.baidu.com&quot;);</span><br><span class="line">            await Console.Out.WriteLineAsync(str2);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>await表达式制订了一个异步执行的任务，这个任务可能是Task也可能不是，默认情况下这个任务在当前线程上异步运行。<br>一个空闲对象既是一个awaitable类型的实例，awaitable类型是指包含GetAwaiter方法的类型，该方法没有参数，返回一个awaiter类型的对象。awaiter类型包含以下成员：<br>bool IsCompleted{get}<br>void OnCompleted(Action);<br>还包含以下成员之一：<br>void GetResult();<br>T GetResult();<br>实际上，你不需要构建自己的awaitable，相反，你应该使用Task或ValueTask类，它们是awaitable类型</p><h2 id="Task-Run"><a href="#Task-Run" class="headerlink" title="Task.Run"></a>Task.Run</h2><p>异步方法不等于多线程，异步方法的代码并不会自动在新线程中执行，除非把代码放到新线程中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            await Repeat(100);</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; Repeat(int times) &#123;</span><br><span class="line">            int i = 0;</span><br><span class="line">            for(int j = 0; j &lt; times; j++) &#123;</span><br><span class="line">                i = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Task.Run()方法可以创建一个Task，并且在不同线程上运行你的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            await Repeat(100);</span><br><span class="line">            Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; Repeat(int times) &#123;</span><br><span class="line">            return await Task.Run(() =&gt; &#123;</span><br><span class="line">                int i = 0;</span><br><span class="line">                for (int j = 0; j &lt; times; j++) &#123;</span><br><span class="line">                    i = i + j;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(&quot;ThreadID：&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">                return i;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它接受一个委托，委托类型可以是：<br><img src="/images/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/1.jpg"></p><h2 id="为什么有些异步方法没标async"><a href="#为什么有些异步方法没标async" class="headerlink" title="为什么有些异步方法没标async"></a>为什么有些异步方法没标async</h2><p>如果不需要传递异步结果，不需要包装成Task，就没必要async，在哪await都是await。<br>这样写对优化有帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            string str = await GetBaidu();</span><br><span class="line">            await Console.Out.WriteLineAsync(str);</span><br><span class="line">        &#125;</span><br><span class="line">        static  Task&lt;string&gt; GetBaidu() &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            return client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="取消异步操作CancellationToken和CancellationTokenSource"><a href="#取消异步操作CancellationToken和CancellationTokenSource" class="headerlink" title="取消异步操作CancellationToken和CancellationTokenSource"></a>取消异步操作CancellationToken和CancellationTokenSource</h2><p>位于System.Threading.Tasks名称空间下。<br>很多异步方法都有CancellationToken参数用于获得提前终止执行的信号。<br>CancellationToken是一个结构体，它包含着一个任务是否应被取消的信息。<br>拥有CancellationToken对象的任务应定期检查其令牌状态也就是IsCancellationRequested属性是否为true，任务需停止其操作并返回。<br>CancellationToken是不可逆的只能使用一次。<br>CancellationTokenSource对象创建可分配给不同任务的CancellationToken对象。任何持有CancellationTokenSource的对象都可以调用其Cancel方法，这会将CancellationToken的IsCancellationRequested设置为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();</span><br><span class="line">            CancellationToken token = cancellationTokenSource.Token;</span><br><span class="line">            cancellationTokenSource.CancelAfter(3000);</span><br><span class="line">            Task&lt;int&gt; res = GetBaidu(token);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (Console.ReadLine() != &quot;p&quot;) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                cancellationTokenSource.Cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task&lt;int&gt; GetBaidu(CancellationToken token) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            for(int i = 0; i &lt; 65533; i++) &#123;</span><br><span class="line">                if(token.IsCancellationRequested) &#123;</span><br><span class="line">                    await Console.Out.WriteLineAsync(&quot;请求被取消&quot;);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                string str = await client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">                await Console.Out.WriteLineAsync(str);</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="同步等待任务"><a href="#同步等待任务" class="headerlink" title="同步等待任务"></a>同步等待任务</h2><p>可以使用task对象的Wait()方法在调用方法中同步等待：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            t.Wait();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Task.WaitAll()静态方法用于等待一组任务都完成<br>Task.WaitAny()静态方法用于等待一组任务中的某一个完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t1 = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            Task t2 = File.ReadAllTextAsync(@&quot;F:\test.txt&quot;);</span><br><span class="line">            //Task.WaitAll(t1, t2);</span><br><span class="line">            Task.WaitAny(t1, t2);</span><br><span class="line">            Console.WriteLine($&quot;t1是否完成:&#123;t1.IsCompleted&#125;,t2是否完成&#123;t2.IsCompleted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们的重载还有：<br><img src="/images/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/2.jpg"></p><h2 id="在异步方法中异步等待"><a href="#在异步方法中异步等待" class="headerlink" title="在异步方法中异步等待"></a>在异步方法中异步等待</h2><p>有时在异步方法中，你会希望用await表达式来等待Task，这时异步方法会返回调用方法，但该异步方法会等待一个或所有任务完成。可以通过Task.WhenAll()和Task.WhenAny()来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            await Test();</span><br><span class="line">        &#125;</span><br><span class="line">        static async Task Test() &#123;</span><br><span class="line">            HttpClient client = new HttpClient();</span><br><span class="line">            Task&lt;string&gt; t1 = client.GetStringAsync(&quot;https://www.baidu.com&quot;);</span><br><span class="line">            Task t2 = File.ReadAllTextAsync(@&quot;F:\test.txt&quot;);</span><br><span class="line">            //await Task.WhenAll(t1, t2);</span><br><span class="line">            await Task.WhenAny(t1, t2);</span><br><span class="line">            await Console.Out.WriteLineAsync($&quot;t1是否完成:&#123;t1.IsCompleted&#125;,t2是否完成&#123;t2.IsCompleted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Delay"><a href="#Task-Delay" class="headerlink" title="Task.Delay"></a>Task.Delay</h2><p>该方法创建Task对象，将对象暂停在其线程中，一定时间后再完成，该方法不会阻塞主线程.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.Delay(3000);</span><br></pre></td></tr></table></figure><h2 id="GUI程序中的异步"><a href="#GUI程序中的异步" class="headerlink" title="GUI程序中的异步"></a>GUI程序中的异步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void Button_Click(object sender, RoutedEventArgs e) &#123;</span><br><span class="line">            this.input.Text = &quot;Watting&quot;;</span><br><span class="line">            this.btn.IsEnabled = false;</span><br><span class="line">            Thread.Sleep(4000);</span><br><span class="line">            this.input.Text = &quot;没有任务&quot;;</span><br><span class="line">            this.btn.IsEnabled = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在wpf中当点击按钮，文本框文字没有改变，按钮也没有被禁用，但是页面卡住了三秒，期间无法拖动也无法进行其他活动。<br>原因是GUI需要处理很多事情，当点击按钮时，按钮的Click被放入消息队列，消息泵从队列中移除该消息并开始执行事件处理函数。事件处理函数将改变文本框文字、禁用按钮、移动窗体、改变文本框文字、启用按钮放入消息泵，消息泵还未刷新页面时，被Thread.Sleep()阻塞了主线程，当三秒之后再处理消息泵的内容，但是这一切发生的太快。<br>将上述代码修改如下即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private async void Button_Click(object sender, RoutedEventArgs e) &#123;</span><br><span class="line">            this.input.Text = &quot;Watting&quot;;</span><br><span class="line">            this.btn.IsEnabled = false;</span><br><span class="line">            await Task.Delay(4000);        </span><br><span class="line">            this.input.Text = &quot;没有任务&quot;;</span><br><span class="line">            this.btn.IsEnabled = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Task-Yield"><a href="#Task-Yield" class="headerlink" title="Task.Yield"></a>Task.Yield</h2><p>该方法创建一个立即返回的awaitable。等待一个Yield可以让异步方法在执行后续部分的同时返回到调用方法，可以将其理解成李凯当前的消息队列、回到队伍末尾、让处理器有时间处理其他任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Task&lt;int&gt; value = DoStuff.FindSeriesSum(100000);</span><br><span class="line">            CountBig(100000); CountBig(100000);</span><br><span class="line">            CountBig(100000); CountBig(100000);</span><br><span class="line">            Console.WriteLine($&quot;Sum:&#123;value.Result&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        private static void CountBig(int value) &#123;</span><br><span class="line">            for (int i = 0; i &lt; value; i++) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class DoStuff &#123;</span><br><span class="line">        public static async Task&lt;int&gt;FindSeriesSum(int i1) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for(int i = 0; i &lt; i1; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                if(i%1000 ==0)await Task.Yield();</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Yield方法在GUI程序中非常有用，可以中断大量工作，让其他任务使用处理器。</p><h2 id="异步Lambda表达式"><a href="#异步Lambda表达式" class="headerlink" title="异步Lambda表达式"></a>异步Lambda表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button.Click+=async(sender,e)=&gt;&#123;...&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 异步编程 </tag>
            
            <tag> async </tag>
            
            <tag> await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINQ</title>
      <link href="/2023/08/30/LINQ/"/>
      <url>/2023/08/30/LINQ/</url>
      
        <content type="html"><![CDATA[<p>Linq表示语言集成查询，它是.Net框架的扩展，允许我们以使用sql查询数据库的类似方法来查询集合。<br>Linq的查询语法有方法语法和查询语法。方法语法是命令式的，查询语法是声明式的。<br>位于System.Linq名称空间。<br>Linq查询可以返回两种类型的结果——可以是一个枚举，它是满足查询参数的项列表；也可以是一个叫标量的单一值，它是满足查询条件的结果的某种摘要形式。</p><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p>学习Linq之前，让我们先来认识一下匿名类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var student = new &#123;</span><br><span class="line">                age = 18,</span><br><span class="line">                name = &quot;张三&quot;,</span><br><span class="line">                major = &quot;数字电路&quot;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>匿名类型的成员类型由编译器推断，只需要在对象初始化语句中初始化即可。<br>注意事项：<br>匿名类型只能用于局部变量，不能用于类成员。<br>必须使用var作为变量类型。<br>编译器为匿名类型创建的属性是只读的。<br>可以使用投影初始化语句来初始化匿名对象（与JS一样）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            int age = 18;</span><br><span class="line">            string name = &quot;张三&quot;;</span><br><span class="line">            string major = &quot;数字电路&quot;;</span><br><span class="line">            var student = new &#123;</span><br><span class="line">                age, name, major</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果编译器遇到了另一个具有相同参数名，相同的推断类型和相同顺序的匿名类型对象初始化语句，它会重用这个类型并直接创建新的实例，不会创建新的匿名类型。</p><h2 id="查询语法（微软推荐，我不推荐）"><a href="#查询语法（微软推荐，我不推荐）" class="headerlink" title="查询语法（微软推荐，我不推荐）"></a>查询语法（微软推荐，我不推荐）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new List&lt;int&gt;() &#123; 1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">            var result = from n in list</span><br><span class="line">                         where n&gt;5</span><br><span class="line">                         select n;</span><br><span class="line">            foreach(var n in result) &#123;</span><br><span class="line">                Console.WriteLine(n);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>如果查询表达式返回枚举，则查询一直到处理枚举时才会执行。<br>如果枚举被处理多次，查询就会执行多次。<br>如果在进行遍历之后，查询执行之前数据有改动，则查询会使用新的数据。<br>如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。<br>查询表达式由from子句和查询主题组成。<br>子句必须按照一定的顺序出现。<br>from子句和select…group子句这两部分是必须的，其他子句是可选的。<br>select子句在表达式最后。<br>可以有任意多的from…let…where子句。</p><h2 id="from子句"><a href="#from子句" class="headerlink" title="from子句"></a>from子句</h2><p>指定要作为数据源使用的数据集合（必须是可枚举的），它还引入了迭代变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from n in list where n&gt;5 select n;</span><br><span class="line">from l1 in list1 from l2 in list2 where l1&lt;l2 select </span><br></pre></td></tr></table></figure><h2 id="join子句（联结）"><a href="#join子句（联结）" class="headerlink" title="join子句（联结）"></a>join子句（联结）</h2><p>接受两个集合，然后创建一个新的集合，其中每一个元素包含两个原始集合中的元素成员。<br>必须使用上下文关键字equals来比较字段，不能用&#x3D;&#x3D;运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var query = from s in students </span><br><span class="line">join c in studentsInCourses on s.StID equals c.StID</span><br></pre></td></tr></table></figure><h2 id="let子句"><a href="#let子句" class="headerlink" title="let子句"></a>let子句</h2><p>接受一个表达式的运算并把它赋值给一个需要在其他运算中使用的标识符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 3, 4, 5, 6 &#125;;</span><br><span class="line">            List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6,7,8,9 &#125;;</span><br><span class="line">            var res = from l1 in list1</span><br><span class="line">                      from l2 in list2</span><br><span class="line">                      let sum = l1+ l2</span><br><span class="line">                      where sum==12</span><br><span class="line">                      select new &#123; l1,l2,sum &#125;;</span><br><span class="line">            foreach(var a in res) &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><p>根据之后的运算来去除不符合指定条件的项</p><h2 id="orderby子句"><a href="#orderby子句" class="headerlink" title="orderby子句"></a>orderby子句</h2><p>接受一个表达式并根据表达式按顺序返回结果项。<br>可选ascending（升序）descending（降序），默认是升序<br>可以有任意多个子句，他们必须用逗号分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 16,8,146,95,3,24 &#125;;</span><br><span class="line">            var res = from l1 in list1</span><br><span class="line">                      orderby l1</span><br><span class="line">                      select l1;</span><br><span class="line">            foreach(var a in res) &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="select子句"><a href="#select子句" class="headerlink" title="select子句"></a>select子句</h2><p>select子句指定应该选择所选对象的哪些部分。<br>查询结果可以由原始集合的项，原始集合中项的字段或匿名类型组成。</p><h2 id="group子句"><a href="#group子句" class="headerlink" title="group子句"></a>group子句</h2><p>group…by是可选的，用来指定选择的项如何被分组。<br>如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组。作为字段分组依据的属性叫做键（key）<br>group子句返回的不是原始数据源中项的枚举，而是返回可以枚举已经形成的项的分组的可枚举类型。<br>分组本身是可枚举类型，他们可以枚举实际的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Student[] students = new Student[] &#123; </span><br><span class="line">            new Student()&#123;Lname = &quot;三&quot;,Fname = &quot;张&quot;, age = 18,Major = &quot;计算机网络&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;四&quot;,Fname = &quot;李&quot;, age = 18,Major = &quot;数据结构与算法&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;五&quot;,Fname = &quot;王&quot;, age = 18,Major = &quot;计算机网络&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;人甲&quot;,Fname = &quot;路&quot;, age = 18,Major = &quot;数据库原理&quot;&#125;,</span><br><span class="line">            new Student()&#123;Lname = &quot;灰乙&quot;,Fname = &quot;炮&quot;, age = 18,Major = &quot;数据库原理&quot;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            var query = from student in students</span><br><span class="line">                        group student by student.Major;</span><br><span class="line">            foreach(var q in query) &#123;</span><br><span class="line">                Console.WriteLine(q.Key);</span><br><span class="line">                foreach(var s in q) &#123;</span><br><span class="line">                    Console.WriteLine(s.Fname+s.Lname+&quot;选修&quot;+s.Major);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Student &#123;</span><br><span class="line">        public string Lname &#123; get; set; &#125;</span><br><span class="line">        public string Fname &#123; get; set; &#125;</span><br><span class="line">        public string Major &#123; get; set; &#125;</span><br><span class="line">        public int age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每一个分组由一个叫做键的字段区分<br>每一个分组本身是可枚举类型并且可以枚举它的项。</p><h2 id="into语句"><a href="#into语句" class="headerlink" title="into语句"></a>into语句</h2><p>into语句是查询延续子句，可以接受查询一部分的结果并赋予一个名字，从而可以在查询的另一部分中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            var groupA = new[]&#123; 3, 4, 5, 6, &#125;;</span><br><span class="line">            var groupB = new[] &#123; 4,5,6,7 &#125;;</span><br><span class="line">            var res = from a in groupA</span><br><span class="line">                      join b in groupB on a equals b</span><br><span class="line">                      into groupAB</span><br><span class="line">                      from c in groupAB</span><br><span class="line">                      select c;</span><br><span class="line">            foreach(var r in res) &#123;</span><br><span class="line">                Console.WriteLine(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="方法语法（标准查询运算符）"><a href="#方法语法（标准查询运算符）" class="headerlink" title="方法语法（标准查询运算符）"></a>方法语法（标准查询运算符）</h2><p>标准查询运算符由一系列API方法组成，一些运算符返回IEnumerable对象（或其他序列），而其他运算符返回标量，返回标量的运算符立即执行查询，并返回一个值，而不是一个可枚举类型对象。ToArray()、ToList()等ToCollection运算符也会立即执行。<br>许多操作都以一个谓词作为参数，谓词是一个方法，它以对象为参数，根据对象是否满足某个条件返回true或false。<br>被查询的集合对象叫序列，它必须实现IEnumerable&lt;T&gt;接口，其中T是类型。<br><img src="/images/LINQ/1.jpg"><br><img src="/images/LINQ/2.jpg"><br><img src="/images/LINQ/3.jpg"><br>System.Linq.Enumerable类声明了标准查询运算符方法，然而这些方法不仅仅是普通方法，他们是拓展了IEnumerable&lt;T&gt;泛型类的扩展方法。</p><h2 id="常用标准查询运算符"><a href="#常用标准查询运算符" class="headerlink" title="常用标准查询运算符"></a>常用标准查询运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var group = new[] &#123;1,2,3,4,5,6,7,8,9,0 &#125;;</span><br><span class="line">            Student[] students = new Student[] &#123; </span><br><span class="line">                new Student()&#123;name = &quot;路人甲&quot;,age =18 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人乙&quot;,age =18 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人丙&quot;,age =19 &#125;,</span><br><span class="line">                new Student()&#123;name = &quot;路人丁&quot;,age =120 &#125;,</span><br><span class="line">            &#125;;</span><br><span class="line">            var res1 = group.Where(e =&gt; e &gt; 6);</span><br><span class="line">            var res2 = group.Count(e=&gt;e&lt;5);</span><br><span class="line">            var res3 = group.Any(e=&gt;e&lt;0);</span><br><span class="line">            var res4 = group.Single(e=&gt;e==6);</span><br><span class="line">            var res5 = group.SingleOrDefault(e=&gt;e==7);</span><br><span class="line">            var res6 = group.First(e=&gt;e&gt;3);</span><br><span class="line">            var res7 = group.FirstOrDefault(e=&gt;e&gt;15);</span><br><span class="line">            var res8 = group.OrderBy(e=&gt;e);</span><br><span class="line">            var res9  = students.OrderBy(e=&gt;e.age);</span><br><span class="line">            var res10 = students.OrderByDescending(e=&gt;e.age);</span><br><span class="line">            var res11 = students.OrderBy(e =&gt; Guid.NewGuid());//随机排序</span><br><span class="line">            var res12 = students.OrderBy(e =&gt; e.age).ThenBy(e=&gt;e.name);</span><br><span class="line">            var res13 = students.OrderBy(e =&gt; e.age).ThenByDescending(e=&gt;e.name);</span><br><span class="line">            var res14 = group.Skip(2).Take(3);//跳过2条，取2条</span><br><span class="line">            var res15 = students.Max(e =&gt; e.age);</span><br><span class="line">            var res16 = students.Min(e =&gt; e.age);</span><br><span class="line">            var res17 = students.Average(e =&gt; e.age);</span><br><span class="line">            var res18 = students.Sum(e =&gt; e.age);</span><br><span class="line">            var res19 = students.Count();</span><br><span class="line">            var res20 = students.GroupBy(e =&gt; e.age);</span><br><span class="line">            var res21 = students.Select(e =&gt; e.age);</span><br><span class="line">            var res22 = students.ToList();</span><br><span class="line">            var res23 = students.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Student &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public int age &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Linq </tag>
            
            <tag> 匿名类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举器与迭代器</title>
      <link href="/2023/08/30/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2023/08/30/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>为什么数组可以被foreach遍历呢？<br>原因是数组可以按需提供一个叫做枚举器的对象，枚举器可以依次返回请求数组中的元素，枚举器知道项的次序并且追踪它在序列中的位置，然后返回请求的当前项。<br>获取对象枚举器的方法是调用对象的GetEnumerator方法。实现GetEnumerator方法的类型叫做可枚举类型。</p><h2 id="IEnumerator接口"><a href="#IEnumerator接口" class="headerlink" title="IEnumerator接口"></a>IEnumerator接口</h2><p>位于System.Collections。<br>实现了IEnumerator接口的枚举器包含3个函数成员：Current、MoveNext以及Reset。<br>Current是返回序列中当前位置项的属性，它是只读的，它返回object类型的引用，我们必须把它转成实际类型的实例。<br>MoveNext是把枚举器位置前进到集合中下一项的方法。它也返回布尔值，指示新的位置是有效位置还是已经超过了序列的尾部，MoveNext必须在第一次使用Current之前调用。<br>Reset是把位置重置为原始状态的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//using System.Collections;</span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            int[] arr = &#123; 10, 11, 12, 13 &#125;;</span><br><span class="line">            IEnumerator ie = arr.GetEnumerator();</span><br><span class="line">            while (ie.MoveNext()) &#123;</span><br><span class="line">                int item = (int) ie.Current;</span><br><span class="line">                Console.WriteLine($&quot;Item value：&#123;item&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerable接口"><a href="#IEnumerable接口" class="headerlink" title="IEnumerable接口"></a>IEnumerable接口</h2><p>位于System.Collections。<br>可枚举类是实现了IEnumerable接口的类，IEnumerable只有一个成员——GetEnumerator方法，它返回对象的枚举器。<br>枚举器与迭代器完整写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Spectrum spectrum = new Spectrum();</span><br><span class="line">            foreach (var color in spectrum) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ColorEnumerator : IEnumerator &#123;</span><br><span class="line">        string[] colors;</span><br><span class="line">        int position = -1;</span><br><span class="line">        public ColorEnumerator(string[] theColors) &#123;</span><br><span class="line">            colors = new string[theColors.Length];</span><br><span class="line">            for(int i = 0;i &lt; theColors.Length; i++) &#123;</span><br><span class="line">                colors[i] = theColors[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public object Current &#123;</span><br><span class="line">            get &#123;</span><br><span class="line">                if(position == -1) &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                if(position&gt;= colors.Length) &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">                return colors[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public bool MoveNext() &#123;</span><br><span class="line">            if(position&lt;colors.Length-1) &#123;</span><br><span class="line">                position++;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else &#123; return false; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Reset() &#123;</span><br><span class="line">            position = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Spectrum : IEnumerable &#123;</span><br><span class="line">        string[] Colors = &#123; &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yello&quot;, &quot;pink&quot; &#125;;</span><br><span class="line">        public IEnumerator GetEnumerator() &#123;</span><br><span class="line">            return new ColorEnumerator(Colors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>大多数情况下你应该使用泛型版本的IEnumerable&lt;T&gt;和IEnumerator&lt;T&gt;。<br>IEnumerable&lt;T&gt;接口的GetEnumerator方法返回实现IEnumator&lt;T&gt;的枚举器类的实例，这些接口是协变接口。<br>泛型接口的枚举器是类型安全的，它自动将返回结果转换成实际类型的引用。<br><img src="/images/%E6%9E%9A%E4%B8%BE%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/1.jpg"></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器需要System.Collections.Generic名称空间。<br>从C#2.0开始提供了更简单的创建枚举器和可枚举类型的方式，这种结构称为迭代器，我们可以把手动编码的可枚举类型和枚举器替换为由迭代器生成的可枚举类型和枚举器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样的有迭代器产生的枚举器简化了很多代码。<br>迭代器块是有一个或多个yield语句的代码块。<br>迭代器块不是需要在同一时间执行的一串命令式命令，而是声明性的。<br>迭代器块有两个特殊的语句：<br>yield return 指定了序列中要返回的下一项。<br>yield break  指定在序列中没有其他项。<br>根据迭代器块的返回类型，可以让迭代器产生枚举器或可枚举类型<br>使用迭代器创建枚举器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">        public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">            return this.BlackAndWhite();</span><br><span class="line">        &#125;</span><br><span class="line">        public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用迭代器创建可枚举对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass mc = new MyClass();</span><br><span class="line">        foreach (string color in mc) &#123;</span><br><span class="line">            Console.WriteLine(color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass &#123;</span><br><span class="line">    public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">        return this.BlackAndWhite();</span><br><span class="line">    &#125;</span><br><span class="line">    public IEnumerator&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">        yield return &quot;black&quot;;</span><br><span class="line">        yield return &quot;gray&quot;;</span><br><span class="line">        yield return &quot;white&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代器创建可枚举类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;   </span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyClass mc = new MyClass();</span><br><span class="line">            foreach (string color in mc) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">            foreach (string color in mc.BlackAndWhite()) &#123;</span><br><span class="line">                Console.WriteLine(color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyClass &#123;</span><br><span class="line">        public IEnumerator&lt;string&gt; GetEnumerator() &#123;</span><br><span class="line">            return this.BlackAndWhite().GetEnumerator();</span><br><span class="line">        &#125;</span><br><span class="line">        public IEnumerable&lt;string&gt; BlackAndWhite() &#123;</span><br><span class="line">            yield return &quot;black&quot;;</span><br><span class="line">            yield return &quot;gray&quot;;</span><br><span class="line">            yield return &quot;white&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><p>当我们实现返回枚举器的迭代器时，必须通过实现GetEnumerator来让类可枚举，它返回由迭代器返回的枚举器。<br>在类中实现返回可枚举类型的迭代器时，我们可以让类实现GetEnumerator来让类本身可枚举，或不实现让类不可枚举。<br>如果实现GetEnumerator，让它调用迭代器方法以获取自动生成的实现IEnumerable的类实例，然后从IEnumerable对象返回由GetEnumerator创建的枚举器。<br>如果不实现GetEnumerator使类本身不可枚举，仍然可以使用由迭代器返回的可枚举类，只需要直接调用迭代器方法。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> IEnumerator </tag>
            
            <tag> IEnumerable </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 枚举器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协变与逆变</title>
      <link href="/2023/08/30/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/"/>
      <url>/2023/08/30/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>大家通常会犯一个错误，就是将派生类型的委托分配给基类型委托的变量，下面来看这个主题叫做可变性，它分为三种——协变、逆变、不变。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p>如果类型参数只用做输出值与构造委托有效性之间的常数关系叫做协变。<br>你也许知道，你可以将派生类型的对象赋值给基类型的变量，这称作类型兼容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Factory&lt;Cat&gt; catMaker = MakeCat;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = catMaker;//报错</span><br><span class="line">    &#125;</span><br><span class="line">    static Cat MakeCat() &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        return cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate T Factory&lt;T&gt;();</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public int NumberOfLegs = 4;</span><br><span class="line">&#125;</span><br><span class="line">class Cat:Animal &#123; &#125;</span><br></pre></td></tr></table></figure><p>出现以上问题的原因很简单，Cat虽然是Animal的子类，但是Factory&lt;Cat&gt;不是Factory&lt;Animal&gt;的子类，必然无法赋值。<br>如果我们想用这样的赋值，就需要告诉编译器我要使用协变。<br>使用协变的前提：类型参数只用做输出值与构造委托有效性之间的常数关系，必须使用out关键字标记委托声明中的类型参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate T Factory&lt;out T&gt;();</span><br></pre></td></tr></table></figure><p>可能会觉得协变的定义很难懂，接下来我来解释一下什么叫输出值。<br>输出值就是返回值，上面的MakeCat函数的返回值是一个Cat类型的对象，Factory&lt;Animal&gt;接收一个Animal类型的返回值，用Animal来接受返回值为Cat的对象，并声明成out协变保证这个派生类对象只用来当做函数返回值，这样当然没问题。</p><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p>逆变用于在期望传入基类时允许传入派生类对象的特性称作逆变。<br>如果上面的函数变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = MakeAnimal;</span><br><span class="line">        Factory&lt;Cat&gt; CatMaker = animalMaker;</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeAnimal(Animal animal) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void Factory&lt; T &gt;(T t);</span><br><span class="line">class Animal &#123;</span><br><span class="line">    public int NumberOfLegs = 4;</span><br><span class="line">&#125;</span><br><span class="line">class Cat:Animal &#123; &#125;</span><br></pre></td></tr></table></figure><p>这次我们用一个MakeAnimal函数接受一个Animal类或其派生类的对象，当我们传入了Cat时，虽然Cat是Animal的派生类，但是Factory&lt;Cat&gt;与Factory&lt;Animal&gt;平级，所以不能直接赋值。<br>如果就想这样做，就需要告诉编译器我要使用逆变。使用协变的前提：类型参数只用做输入值与构造委托有效性之间的常数关系，必须使用in关键字标记委托声明中的类型参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate T Factory&lt;in T&gt;();</span><br></pre></td></tr></table></figure><p>MakeAnimal函数接受一个animal的对象，我们传入了animal的派生类对象并声明成in逆变保证这个派生类对象只用来当做函数传参，这样做当然没问题</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>可变性处理的是可以使用基类型替换派生类型的安全情况，反之亦然。因此可变性只适用于引用类型。</p><p>in和out关键字的显式变化只适用于委托和接口，不适用于类、结构、方法。</p><p>不包括in和out关键字的委托和接口类型参数是不变的。这些类型参数不能用于协变或逆变。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 可变性 </tag>
            
            <tag> 协变 </tag>
            
            <tag> 逆变 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2023/08/29/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/08/29/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><p>大家有没有觉得一个类的成员类型或者一个方法的返回值类型和参数类型一旦写好就不太方便修改，如果一个经常使用的类，它的某个成员类型有时候需要int，有时候需要string，我们需要不停的修改这个类，或者声明一个与其名字相似但成员类型不同的新的类，这样做非常麻烦。<br>另外还有一个函数，它的参数类型有时候需要int，有时候需要double，虽然我们可以进行函数重载，但代码挺多的。<br>为了解决上述问题，提供了新的解决方案——泛型。<br>我们可以使用“类型占位符”书写代码，然后在创建类的实例时知名真实的类型。<br>泛型类型不是类型，而是类型的模板。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">            MyClass&lt;int, double&gt; myClass = new MyClass&lt;int, double&gt;() &#123; Value1 = 12 ,Value2 = new double[] &#123; 1,2,3&#125; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class MyClass&lt;T1 , T2&gt; &#123;</span><br><span class="line">        public T1 Value1 &#123; get; set; &#125;</span><br><span class="line">        public T2[] Value2;</span><br><span class="line">        public void Fun1(T1 x) &#123; ... &#125;</span><br><span class="line">        public T2 Fun2() &#123; ...&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码，如果我们想要修改MyClass类成员的类型，只需要在声明时修改&lt;&gt;内的内容，也就是类型参数就行。<br>泛型的声明有点长可以使用var进行简化。</p><h2 id="类型参数的约束（where）"><a href="#类型参数的约束（where）" class="headerlink" title="类型参数的约束（where）"></a>类型参数的约束（where）</h2><p>由于泛型栈不知道它们保存的项的类型是什么，所以也就不会知道这些类型实现的成员。<br>栈可以确认的是，这些保存的项都实现了object类的成员，包括ToString、Equals、以及GetType方法，除此之外，它不知道还有哪些成员可用。<br>为了让泛型变得更有用，我们需要提供额外的信息让编译器知道参数可以接受哪种类型，这样的信息称为约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass&lt;int, double[]&gt; myClass = new MyClass&lt;int, double[]&gt;() &#123; Value1 = 12 ,Value2 = new double[] &#123; 1,2,3&#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass&lt;T1 , T2&gt;where T1: struct </span><br><span class="line">                             where T2 : class, IEnumerable&lt;double&gt; &#123;</span><br><span class="line">    public T1 Value1 &#123; get; set; &#125;</span><br><span class="line">    public T2 Value2;</span><br><span class="line">    public void Fun1(T1 x) &#123;</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">    &#125;</span><br><span class="line">    public T2 Fun2() &#123;</span><br><span class="line">        return Value2 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约束类型：</p><table><thead><tr><th>约束类型</th><th>描述</th></tr></thead><tbody><tr><td>类名</td><td>只有这个类型的类或从它派生的类才能用作类型实参</td></tr><tr><td>class</td><td>任何引用类型，包括类、数组、委托和接口都可以用作类型实参</td></tr><tr><td>struct</td><td>任何值类型都可以用作类型实参</td></tr><tr><td>接口名</td><td>只有这个接口或实现这个接口的类型才能用作类型实参</td></tr><tr><td>new()</td><td>任何具有无参公共构造函数的类型都可以用作类型实参</td></tr><tr><td>where子句可以以任何次序列出，但是where字句中的约束必须有特定的顺序：</td><td></td></tr><tr><td>最多只能有一个主约束，而且必须放在第一位。</td><td></td></tr><tr><td>可以有任意多的接口名称约束。</td><td></td></tr><tr><td>如果存在构造函数约束，则必须放在最后。</td><td></td></tr><tr><td>主约束</td><td>次约束</td></tr><tr><td>–</td><td>–</td></tr><tr><td>ClassName</td><td>InterfaceName</td></tr><tr><td>class</td><td></td></tr><tr><td>struct</td><td></td></tr></tbody></table><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            var intArray = new int[] &#123; 3, 5, 7, 9, 11 &#125;;</span><br><span class="line">            var stringArray = new string[] &#123; &quot;first&quot;, &quot;second&quot;, &quot;third&quot; &#125;;</span><br><span class="line">            Simple.ReverseAndPrint&lt;int&gt;(intArray);</span><br><span class="line">            Simple.ReverseAndPrint(stringArray);//自动推断</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple &#123;</span><br><span class="line">        static public void ReverseAndPrint&lt;T&gt;(T[] arr) &#123;</span><br><span class="line">            Array.Reverse(arr);</span><br><span class="line">            foreach (var item in arr) &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译器可以帮我们从方法参数的类型中推断出应用作为泛型方法的类型参数的类型，简化调用时书写的代码。</p><h2 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct&lt;T1,T2&gt; &#123;</span><br><span class="line">            public T1 Value1;</span><br><span class="line">            public T2 Value2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyDel&lt;int&gt; del = func;</span><br><span class="line">            del.Invoke(0);</span><br><span class="line">        &#125;</span><br><span class="line">        static void func(int i) &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate void MyDel&lt;T&gt;(T t);</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>如果一个类实现了泛型接口，那么这个类本身也是泛型的。<br>如果一个类实现了特化之后的泛型接口，那么这个类就不再是泛型类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Simple&lt;string&gt; simple = new Simple&lt;string&gt;();</span><br><span class="line">            Simple&lt;int&gt; int1 = new Simple&lt;int&gt;();</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(&quot;hello world&quot;));</span><br><span class="line">            Console.WriteLine(int1.ReturnIt(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IMyIf&lt;T&gt; &#123;</span><br><span class="line">        T  ReturnIt( T inValue);</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple&lt;S&gt; : IMyIf&lt;S&gt; &#123;</span><br><span class="line">        public S ReturnIt(S inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用不同类型参数实例化的泛型接口的实例是不同的接口。<br>我们可以在非泛型类型中实现泛型接口。<br>必须实现每一个接口的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Simple simple = new Simple();</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(&quot;hello world&quot;));</span><br><span class="line">            Console.WriteLine(simple.ReturnIt(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface IMyIf&lt;T&gt; &#123;</span><br><span class="line">        T  ReturnIt( T inValue);</span><br><span class="line">    &#125;</span><br><span class="line">    class Simple : IMyIf&lt;int&gt;, IMyIf&lt;string&gt; &#123;</span><br><span class="line">        public int ReturnIt(int inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public string ReturnIt(string inValue) &#123;</span><br><span class="line">            return inValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。<br>泛型接口的名字不会与非泛型冲突。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 泛型 </tag>
            
            <tag> 泛型约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/08/29/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/08/29/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么我们需要接口"><a href="#为什么我们需要接口" class="headerlink" title="为什么我们需要接口"></a>为什么我们需要接口</h2><p>接口是指定一组函数成员而不实现它们的引用类型，只有类和结构可以实现接口。<br>接口是抽象类的进一步抽象。<br>可以很好的帮助我们解决类的耦合。<br>接下来我会一步步推出来为什么要使用接口。</p><h2 id="抽象类解耦"><a href="#抽象类解耦" class="headerlink" title="抽象类解耦"></a>抽象类解耦</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            HuaWei huaWei = new HuaWei();</span><br><span class="line">            Man man = new Man();</span><br><span class="line">            man.huaWei = huaWei;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Man &#123;</span><br><span class="line">        public HuaWei huaWei &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class HuaWei &#123;</span><br><span class="line">        public void Call() &#123;</span><br><span class="line">            Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个代码表示一个人拿了一部华为手机，当这个人想换成小米手机的时候，就不得不修改成一下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        XiaoMi xiaoMi = new XiaoMi();</span><br><span class="line">        Man man = new Man();</span><br><span class="line">        man.xiaoMi = xiaoMi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man &#123;</span><br><span class="line">    public XiaoMi xiaoMi &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class XiaoMi &#123; </span><br><span class="line">    public void Call() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现一个问题，这个人可能会换很多部不同的手机，难道我们每次都要重写Man类就为了让这个人打电话吗？当然不可能，所以我们想了一个方法，用抽象类封装一下，再通过多态来实现不就可以了吗：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">      static void Main(string[] args) &#123;</span><br><span class="line">          Man man = new Man();</span><br><span class="line">          Phone phone = new XiaoMi();</span><br><span class="line">          phone.Call();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Man &#123;</span><br><span class="line">      public Phone phone &#123; get; set; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  abstract class Phone &#123;</span><br><span class="line">      public abstract void Call();</span><br><span class="line">  &#125;</span><br><span class="line">  class XiaoMi:Phone &#123; </span><br><span class="line">      override public void Call() &#123;</span><br><span class="line">          Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class HuaWei:Phone &#123;</span><br><span class="line">      override public void Call() &#123;</span><br><span class="line">          Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就好多了，这下我们只需要每次给man换手机就行了，Call方法给每个手机厂商自己实现就行了。</p><h2 id="接口解耦"><a href="#接口解耦" class="headerlink" title="接口解耦"></a>接口解耦</h2><p>当我们声明一个抽象类的时候，我们必须要写非常多的public abstract 用来声明抽象方法，还必须在子类中写好多override，况且随着手机的功能越来越多，手机可以当游戏机，可以当手电筒，可以当记事本，难道我们要在Phone中加入不属于手机初衷的功能吗？这样一点都不优雅，有没有优雅一点的办法？<br>有！就是使用接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">       static void Main(string[] args) &#123;</span><br><span class="line">           Man man = new Man();</span><br><span class="line">           IPhone phone = new XiaoMi();</span><br><span class="line">           phone.Call();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class Man &#123;</span><br><span class="line">       public IPhone phone &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   interface IPhone &#123;</span><br><span class="line">       void Call();</span><br><span class="line">   &#125;</span><br><span class="line">   class XiaoMi:IPhone &#123; </span><br><span class="line">       public void Call() &#123;</span><br><span class="line">           Console.WriteLine(&quot;我用小米打电话&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   class HuaWei:IPhone &#123;</span><br><span class="line">       public void Call() &#123;</span><br><span class="line">           Console.WriteLine(&quot;我用华为打电话&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>interface声明接口，接口内的成员隐式都是public abstract的所以无需再写也不能写了。还可以看到在实现接口的类中不用再写override了，优雅太优雅了。</p><h2 id="声明接口的注意事项"><a href="#声明接口的注意事项" class="headerlink" title="声明接口的注意事项"></a>声明接口的注意事项</h2><p>接口成员不能是数据成员或静态成员<br>接口声明只能包含如下类型非静态成员函数声明：<br>方法<br>属性<br>事件<br>索引器<br>接口成员的声明不能包含任何实现代码，必须用分号代替每一个成员声明的主体。<br>按照惯例接口名称应以大写I开始。<br>接口声明可以分隔成分部接口声明。<br>接口声明可以有任何访问修饰符，但是接口成员都是隐式public的，不允许有任何修饰符包括public。<br>接口不能实例化，只能用来声明变量，但不能调用不属于这个接口成员的类成员。<br>接口可以继承一个或多个接口</p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>类和结构可以实现接口，而且可以实现多个接口。<br>实现接口的类或结构需要在基类列表中包含接口名称基类在前接口在后，必须为每一个接口成员提供实现。<br>如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。<br>实现接口的类可以从它的基类继承实现的代码。</p><h2 id="显式接口成员实现"><a href="#显式接口成员实现" class="headerlink" title="显式接口成员实现"></a>显式接口成员实现</h2><p>使用限定接口名称来声明，由接口名称和成员名称以及它们中间的点分隔号构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        IKiller man1 = new Man();</span><br><span class="line">        man1.Kill();</span><br><span class="line">        IGoodMan man2 = new Man();</span><br><span class="line">        man2.Smile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface IKiller &#123;</span><br><span class="line">    void Kill();</span><br><span class="line">&#125;</span><br><span class="line">interface IGoodMan &#123;</span><br><span class="line">    void Smile();</span><br><span class="line">&#125;</span><br><span class="line">class Man : IKiller, IGoodMan &#123;</span><br><span class="line">     void IKiller.Kill() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我是个杀手&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     void IGoodMan.Smile() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我是个好人&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式实现接口成员的函数不应该有访问修饰符，因为其是隐式public的。<br>显式接口成员实现只可以通过指向接口的引用来访问，其他的类成员都不可以直接访问他们。<br>由于其他类成员不能直接访问显式接口成员的实现，派生类的成员也不能直接访问他们，他们必须总是通过接口的引用来访问。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数</title>
      <link href="/2023/08/29/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
      <url>/2023/08/29/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>匿名方法是在实例化委托是内联声明的方法。</p><h2 id="匿名函数使用位置"><a href="#匿名函数使用位置" class="headerlink" title="匿名函数使用位置"></a>匿名函数使用位置</h2><p>声明委托变量时作为初始化表达式</p><p>组合委托时在赋值语句的右边</p><p>为委托增加事件时在赋值语句的右边</p><h2 id="匿名函数语法"><a href="#匿名函数语法" class="headerlink" title="匿名函数语法"></a>匿名函数语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            MyDel del = delegate (string str) &#123;</span><br><span class="line">                Console.WriteLine(str);</span><br><span class="line">            &#125;;</span><br><span class="line">            del();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delegate void MyDel(string str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数不会显式声明返回值，但是实现代码必须通过返回一个与委托的返回值相同的值来匹配委托的返回类型。<br>当委托的参数列表不包含out参数并且匿名方法不适用任何参数时可以省略括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = delegate &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>如果委托声明的参数列表包含了params参数，那么匿名方法的参数列表将忽略params关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">delegate void MyDel(int x,params int[] ints);</span><br><span class="line">//声明</span><br><span class="line">MyDel del = delegate (int x, int[]ints) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>匿名方法可以访问他们外围作用域的局部变量和环境。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>匿名函数几乎被Lambda表达式替代了。<br>其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = (int x , int[] ints) =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>编译器可以从委托的声明中知道委托参数的类型，因此Lambda表达式语序省略类型参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = (x , ints) =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>如果只有一个参数就可以省略两端的圆括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = x =&gt; &#123;</span><br><span class="line">                Console.WriteLine(&quot;Hello World&quot;);</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>Lambda表达式允许表达式的主题是语句块或表达式。如果语句块包含了一个返回语句，我们可以将语句块替换为return关键字后的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = x  =&gt; x*10;</span><br></pre></td></tr></table></figure><p>是不是觉得这样的语法超级简洁</p><h2 id="Lambda表达式参数列表注意事项"><a href="#Lambda表达式参数列表注意事项" class="headerlink" title="Lambda表达式参数列表注意事项"></a>Lambda表达式参数列表注意事项</h2><p>表达式的参数列表不一定需要包含类型，除非委托有ref或out参数。<br>如果只有一个参数且这个参数是隐式类型则可以省略圆括号，否则必须有括号。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件</title>
      <link href="/2023/08/29/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/08/29/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>事件是类的成员，是使对象或类具有通知能力的成员。<br>事件的组成：发布者、订阅者、事件处理程序、触发事件。<br>事件订阅本质上是一种以委托类型为基础的约定。</p><h2 id="事件相关的说明"><a href="#事件相关的说明" class="headerlink" title="事件相关的说明"></a>事件相关的说明</h2><p>事件包含了一个私有的委托，但是你无法直接访问委托。<br>事件中可用的操作比委托少，我们只能添加、删除或调用事件处理程序。<br>事件被触发时，它调用委托来一次调用调用列表中的方法。<br>+&#x3D;、-&#x3D;是事件唯一允许的操作。<br>委托类型声明：事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。<br>事件处理程序声明：订阅者类中会在事件触发时执行的方法声明。他们不一定是显示命名的方法，还可以是Lambda表达式或匿名方法。<br>事件声明：订阅者必须注册事件才能在事件被触发时得到通知。这是将事件处理程序与事件相连的代码。<br>触发事件的代码：发布者类中“触发”事件并导致调用注册的所有事件处理程序的代码。</p><h2 id="创建发布者类"><a href="#创建发布者类" class="headerlink" title="创建发布者类"></a>创建发布者类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件委托"><a href="#声明事件委托" class="headerlink" title="声明事件委托"></a>声明事件委托</h2><p>订阅者的事件处理程序需要满足该委托。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">public delegate void ClickEventHandle(Button sender, ClickEventArgs e);//定义委托类型 Button：触发事件的对象ClickEventArgs：事件附带的信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件附带信息"><a href="#声明事件附带信息" class="headerlink" title="声明事件附带信息"></a>声明事件附带信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">            public int Width &#123; get; private set; &#125;</span><br><span class="line">            public int Height &#123; get; private set; &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="将触发事件时应执行的函数存放于发布者类的事件委托中"><a href="#将触发事件时应执行的函数存放于发布者类的事件委托中" class="headerlink" title="将触发事件时应执行的函数存放于发布者类的事件委托中"></a>将触发事件时应执行的函数存放于发布者类的事件委托中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">public ClickEventHandle Event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><p>发布者类必须提供事件对象，这需要委托类型和名称。<br>事件是类的成员，并且必须声明为public，这样其他类和结构才可以在它上面注册事件处理程序。<br>不能用new来创建该事件的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        public event ClickEventHandle Click &#123;</span><br><span class="line">        //add添加事件处理程序，remove移除事件处理程序，value外部传入的事件处理程序</span><br><span class="line">            add &#123;</span><br><span class="line">                this.Event += value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove &#123;</span><br><span class="line">                this.Event -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//event：关键字 ClickEventHandler：委托类型 Click：事件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布者触发事件"><a href="#发布者触发事件" class="headerlink" title="发布者触发事件"></a>发布者触发事件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Button&#123;</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Event != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Event.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建订阅者类并编写事件处理程序"><a href="#创建订阅者类并编写事件处理程序" class="headerlink" title="创建订阅者类并编写事件处理程序"></a>创建订阅者类并编写事件处理程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;//绑定事件处理程序</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(Button sender, ClickEventArgs e) &#123;//事件处理程序</span><br><span class="line">            Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">            Console.WriteLine($&quot;按钮名：&#123;e.Name&#125;，按钮宽度：&#123;e.Width&#125;，按钮高度：&#123;e.Height&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="事件的完整写法"><a href="#事件的完整写法" class="headerlink" title="事件的完整写法"></a>事件的完整写法</h2><p>假设有一个按钮和一个屏幕，三秒后按钮自动按下，屏幕收到按钮按下的事件，在屏幕上显示按钮的信息。<br>结合上面讲述的内容，构成事件的完整写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Button button = new Button();</span><br><span class="line">            Screen screen = new Screen(button);</span><br><span class="line">            await button.Button_Click();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">        public int Width &#123; get; set; &#125;</span><br><span class="line">        public int Height &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(Button sender, ClickEventArgs e) &#123;//事件处理程序</span><br><span class="line">            Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">            Console.WriteLine($&quot;按钮名：&#123;e.Name&#125;，按钮宽度：&#123;e.Width&#125;，按钮高度：&#123;e.Height&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Button &#123;</span><br><span class="line">        public ClickEventHandle Event;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">        public delegate void ClickEventHandle(Button sender, ClickEventArgs e);//定义委托类型 Button：触发事件的对象ClickEventArgs：事件附带的信息</span><br><span class="line">        public event ClickEventHandle Click &#123;</span><br><span class="line">            add &#123;</span><br><span class="line">                this.Event += value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove &#123;</span><br><span class="line">                this.Event -= value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//event：关键字 ClickEventHandler：委托类型 Click：事件名</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Event != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Event.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件的简单写法"><a href="#事件的简单写法" class="headerlink" title="事件的简单写法"></a>事件的简单写法</h2><p>对于事件的使用.Net提供了一个标准模式，该标准模式的基础就是System名称空间中声明的EventHandler委托类型。<br>在之后声明事件就不需要自己定义事件委托类型了。<br>EventHandler委托需要注意以下几点：<br>第一个参数用来保存触发事件的对象的引用，由于它是object类型的，所以可以匹配任何类型的实例。<br>第二个参数用来保存状态信息，指明什么类型适用于该应用程序。<br>返回类型是void。<br>EventHandler的第二个参数是EventArgs类的对象，它声明在System名称空间中，但是EventArgs不能传递任何数据，它用于不需要传递数据的事件处理程序，通常会被忽略。如果你希望传递数据，必须声明一个派生自EventArgs的类，并使用合适的字段来保存需要传递的数据。<br>事件访问器add和remove可以省路，事件名同时担任事件委托和事件名两个职责，可以简单理解成public event EventHandler Click;声明了一个委托类型成员（但其实不是）<br>了解了上述的概念，我们就可以简化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using System.Threading.Tasks;</span><br><span class="line">using System;</span><br><span class="line">namespace Test &#123;</span><br><span class="line">    internal class Program &#123;</span><br><span class="line">        static async Task Main(string[] args) &#123;</span><br><span class="line">            Button button = new Button();</span><br><span class="line">            Screen screen = new Screen(button);</span><br><span class="line">            await button.Button_Click();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class ClickEventArgs : EventArgs &#123;//ClickEventArgs：事件附带的信息</span><br><span class="line">        public int Width &#123; get; set; &#125;</span><br><span class="line">        public int Height &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Screen &#123;</span><br><span class="line">        public Screen(Button btn) &#123;</span><br><span class="line">            btn.Click += this.ShowButtonInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        public void ShowButtonInfo(object? sender, EventArgs e) &#123;//事件处理程序</span><br><span class="line">            ClickEventArgs ClickArg = e as ClickEventArgs;</span><br><span class="line">            if (ClickArg != null) &#123;</span><br><span class="line">                Console.WriteLine(&quot;\n\n\n我是一块屏幕，检测到按钮被点击了，我要显示：&quot;);</span><br><span class="line">                Console.WriteLine($&quot;按钮名：&#123;ClickArg.Name&#125;，按钮宽度：&#123;ClickArg.Width&#125;，按钮高度：&#123;ClickArg.Height&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Button &#123;</span><br><span class="line">        private int Width = 240;//按钮宽度</span><br><span class="line">        private int Height = 120;//按钮高度</span><br><span class="line">        private string Name = &quot;蓝色按钮&quot;;</span><br><span class="line">        public event EventHandler Click;</span><br><span class="line">        public async Task Button_Click() &#123;</span><br><span class="line">            if (this.Click != null) &#123;</span><br><span class="line">                await Console.Out.WriteLineAsync(&quot;三秒后自动点击按钮&quot;);</span><br><span class="line">                await Task.Delay(3000);</span><br><span class="line">                ClickEventArgs e = new ClickEventArgs();</span><br><span class="line">                e.Width = this.Width;</span><br><span class="line">                e.Height = this.Height;</span><br><span class="line">                e.Name = this.Name;</span><br><span class="line">                this.Click.Invoke(this,e);//触发</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托</title>
      <link href="/2023/08/29/%E5%A7%94%E6%89%98/"/>
      <url>/2023/08/29/%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>可以认为委托是持有一个或多个方法的对象，但委托与对象不同，可以执行委托，这时委托会执行它所持有的方法。<br>如果学过C&#x2F;C++可以将委托理解成函数指针的升级版。</p><h2 id="初识委托"><a href="#初识委托" class="headerlink" title="初识委托"></a>初识委托</h2><p>委托与类平级，所以一般声明在类声明的位置，委托的访问性默认是internal。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyDel del = new MyDel(SayHello);</span><br><span class="line">        del.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;Hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate int MyDel(int i);</span><br></pre></td></tr></table></figure><p>创建委托实例时，可以传入实例方法或者静态方法的方法名。</p><h2 id="初始化委托"><a href="#初始化委托" class="headerlink" title="初始化委托"></a>初始化委托</h2><p>我们已经见到了new的赋值方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = new MyDel(Ix10);</span><br></pre></td></tr></table></figure><p>也可以使用委托赋值的快捷方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDel del = SayHello;</span><br></pre></td></tr></table></figure><h2 id="组合委托"><a href="#组合委托" class="headerlink" title="组合委托"></a>组合委托</h2><p>委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表连接了作为操作数的两个委托的调用列表副本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel del1 = SayHello;</span><br><span class="line">MyDel del2 = Human.Eat;</span><br><span class="line">MyDel del3 = del1+del2;</span><br></pre></td></tr></table></figure><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>我们已经展示过了组合委托，通过+运算符可以将两个委托组合起来，+和+&#x3D;运算符还可以给委托增加方法到委托的调用队列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyDel del = SayHello;</span><br><span class="line">        del += Human.Eat;</span><br><span class="line">        del = del +SayHello;</span><br><span class="line">        del();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void MyDel();</span><br><span class="line">public class Human &#123;</span><br><span class="line">    public static void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用+&#x3D;运算符时，实际上发生的是创建了一个新的委托，其调用列表是左边的委托加上右边方法的组合，然后将这个委托赋值给del。<br>由代码的执行结果来看，其调用顺序与添加方法的顺序相同。</p><h2 id="移除委托方法"><a href="#移除委托方法" class="headerlink" title="移除委托方法"></a>移除委托方法</h2><p>可以使用-和-&#x3D;运算符从委托移除方法 。<br>如果在调用列表中的方法有多个实例，-&#x3D;运算符将从列表最后开始搜索，并且移除第一个与方法匹配的实例。<br>试图删除委托中不存在的方法将无效。<br>试图调用空委托会抛出异常，可以通过将委托和null进行比较来判断委托的调用列表是否为空。如果为空则委托是null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static async Task Main(string[] args) &#123;</span><br><span class="line">        Action action = SayHello;</span><br><span class="line">        action += Human.Eat;</span><br><span class="line">        action = action + SayHello;</span><br><span class="line">        action = action - SayHello;</span><br><span class="line">        action -= Human.Eat;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    static void SayHello() &#123;</span><br><span class="line">        Console.WriteLine(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delegate void MyDel();</span><br><span class="line">public class Human &#123;</span><br><span class="line">    public static void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式异步调用多播委托"><a href="#显式异步调用多播委托" class="headerlink" title="显式异步调用多播委托"></a>显式异步调用多播委托</h2><p>多播委托默认是同步调用的，但我们可以使用Thread或Task显式异步调用。<br>Thread：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//using System.Threading;</span><br><span class="line">MyDel del = SayHello;</span><br><span class="line">del += Human.Eat;</span><br><span class="line">Thread thread = new Thread(new ThreadStart(del));//可以直接传入方法名或委托实例</span><br><span class="line">thread.Start();</span><br></pre></td></tr></table></figure><p>Task：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static async Task Main(string[] args) &#123;</span><br><span class="line">      Action action = SayHello;</span><br><span class="line">      action += Human.Eat;</span><br><span class="line">      Task task = new Task(action);</span><br><span class="line">      task.Start();</span><br><span class="line">      await Task.Delay(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步调用看不懂没关系，我会在异步编程中介绍的。Task之所以加了Delay是因为如果不await，代码会在执行Human.Eat或者SayHello之前退出。</p><h2 id="Action委托"><a href="#Action委托" class="headerlink" title="Action&lt;&gt;委托"></a>Action&lt;&gt;委托</h2><p>Action委托无需自己定义，由C#语言定义只需要使用即可。<br>Action委托是泛型委托用于无返回值的函数，泛型列表中是被委托函数的参数列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Action&lt;string&gt; action = Say;</span><br><span class="line">        action(&quot;你好世界&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void Say(string str) &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Func委托"><a href="#Func委托" class="headerlink" title="Func&lt;&gt;委托"></a>Func&lt;&gt;委托</h2><p>Func&lt;&gt;委托无需自己定义，由C#语言定义只需要使用即可。<br>Func&lt;&gt;委托是泛型委托用于有返回值的函数，泛型列表中最后一个是方法返回值类型，前几个是被委托函数的参数类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">internal class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            Func&lt;int, int, int&gt; func = new Func&lt;int, int, int&gt;(add);</span><br><span class="line">            int res = func(3,4);</span><br><span class="line">            Console.WriteLine(res);</span><br><span class="line">        &#125;</span><br><span class="line">        static int add(int a,int b) &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 委托 </tag>
            
            <tag> 多播委托 </tag>
            
            <tag> Action </tag>
            
            <tag> Func </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dictionary字典</title>
      <link href="/2023/08/28/Dictionary%E5%AD%97%E5%85%B8/"/>
      <url>/2023/08/28/Dictionary%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="字典（dictionary）的声明"><a href="#字典（dictionary）的声明" class="headerlink" title="字典（dictionary）的声明"></a>字典（dictionary）的声明</h2><p>声明字典时,需同时声明字典内的键和值的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br></pre></td></tr></table></figure><h2 id="字典的读取与增加"><a href="#字典的读取与增加" class="headerlink" title="字典的读取与增加"></a>字典的读取与增加</h2><p>键和值可以是任何类型，但键必须是唯一的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br><span class="line">        dic.Add(1, &quot;hi&quot;);</span><br><span class="line">        dic.Add(2, &quot;你好&quot;);</span><br><span class="line">        dic[3] = &quot;hello&quot;;</span><br><span class="line">        Console.WriteLine(dic[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典初始化器"><a href="#字典初始化器" class="headerlink" title="字典初始化器"></a>字典初始化器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int, string&gt; &#123;</span><br><span class="line">            &#123;1,&quot;hello world&quot; &#125;,</span><br><span class="line">            &#123;2,&quot;字典的基本用法&quot; &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h2 id="dic-Remove-key"><a href="#dic-Remove-key" class="headerlink" title="dic.Remove(key)"></a>dic.Remove(key)</h2><p>用于移除键对应的成员，返回bool，成功为true，失败为false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</span><br><span class="line">        dic.Add(1, &quot;hi&quot;);</span><br><span class="line">        dic.Add(2, &quot;你好&quot;);</span><br><span class="line">        dic.Remove(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> Dictionary </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型List类</title>
      <link href="/2023/08/28/%E6%B3%9B%E5%9E%8BList%E7%B1%BB/"/>
      <url>/2023/08/28/%E6%B3%9B%E5%9E%8BList%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>泛型list的底层是动态数组，其容量可自动或手动调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        List&lt;int&gt; IntList = new List&lt;int&gt;();</span><br><span class="line">        IntList.Add(1);</span><br><span class="line">        IntList.Add(2);</span><br><span class="line">        IntList.Add(3);</span><br><span class="line">        Console.WriteLine(IntList.Count);//集合元素的数量</span><br><span class="line">        Console.WriteLine(IntList.Capacity);//底层数组长度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以向（）中传入一个整数来限制list的底层数组大小。</p><h2 id="List常用API"><a href="#List常用API" class="headerlink" title="List常用API"></a>List常用API</h2><p>list.Add(int value)     添加元素</p><p>list.AddRange(IEnumerable <code>&lt;int&gt;</code> list)      添加一组元素</p><p>list.Insert(int index,int value)            插入元素</p><p>list.InsertRange(int index,IEnumerable <code>&lt;int&gt;</code>list)         插入一组元素</p><p>list.Clear()           清空（底层数组长度不变）</p><p>list.Remove(int index)      移除</p><p>list.RemoveRange(int index,int length)      移除length个元素</p><p>list.RemoveAll(e&#x3D;&gt;e&#x3D;&#x3D;400)     接受一个返回值为bool的委托，移除满足条件的成员</p><p>list.GetRange(int index,int length)       返回一个List <code>&lt;int&gt;</code>类型的对象，包含被截取的成员</p><p>list.GetEnumerator()          返回List <code>&lt;int&gt;</code>类型对象的Enumerator迭代器，迭代器会在之后的篇章中介绍。</p><p>list.ForEach(e&#x3D;&gt;e*10)       遍历</p><p>list.Contain(100)           返回bool，检测一个值是否存在于list中</p><p>list.Exists(e&#x3D;&gt;e&gt;500))      返回bool，用来检测list中是否有满足条件的元素</p><p>list.TrueForAll(e&#x3D;&gt;e&lt;&#x3D;40)        返回bool，检测所有元素是否都满足要求</p><p>list.IndexOf(300)        返回第一个值为300的成员的索引，底层调用&#x3D;&#x3D;，没有则返回-1</p><p>list.IndexOf(value,index)         从index位置开始，往后找value所在的索引,index最大为list.Count,再大就报错了</p><p>list.IndexOf(value,startIndex,much)     从stratIndex位置开始，到其往后much个元素位置，查找是否有value，返回value的索引</p><p>list.Find(e&#x3D;&gt;e%3&#x3D;&#x3D;0)      返回第一个满足要求的值</p><p>list.FindLast(e&#x3D;&gt;e%4&#x3D;&#x3D;0)          返回最后一个满足要求的值</p><p>list.FindAll(e&#x3D;&gt;e%3&#x3D;&#x3D;0)         返回一个由满足要求的值组成的新集合</p><p>list.FindIndex(e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindIndex(index,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindIndex(index,much,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(index,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.FindLastIndex(index,much,e&#x3D;&gt;e%2&#x3D;&#x3D;0)</p><p>list.BinarySearch(value)          在排好序的list中用二分查找value所在的位置</p><h2 id="list-Contain"><a href="#list-Contain" class="headerlink" title="list.Contain()"></a>list.Contain()</h2><p>其底层原理是&#x3D;&#x3D;，如果是引用类型则用Equals方法，自定义类型没有Equals方法需要覆写object的Equals方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        List&lt;Book&gt; list = new List&lt;Book&gt;();</span><br><span class="line">        Book book1 = new Book();</span><br><span class="line">        Book book2 = new Book();</span><br><span class="line">        book1.id = 1;</span><br><span class="line">        book2.id = 2;</span><br><span class="line">        list.Add(book1);</span><br><span class="line">        list.Add(book2);</span><br><span class="line">        Console.WriteLine(list.Contains(book1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book &#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public override bool Equals(object? obj) &#123;</span><br><span class="line">        if(obj ==null) return false;</span><br><span class="line">        Book other = obj as Book;</span><br><span class="line">        if(other == null) return false;</span><br><span class="line">        return this.id == other.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list-Sort"><a href="#list-Sort" class="headerlink" title="list.Sort()"></a>list.Sort()</h2><p>其底层用CompareTo方法，引用类型没有CompareTo方法所以要自己写，要求该引用类型实现IComparable&lt;&gt;接口&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Book book1 = new Book();</span><br><span class="line">        Book book2 = new Book();</span><br><span class="line">        Book book3 = new Book();</span><br><span class="line">        book1.ID = 9;</span><br><span class="line">        book2.ID=4;</span><br><span class="line">        book3.ID=15;</span><br><span class="line">        List&lt;Book&gt; list = new List&lt;Book&gt;&#123; book1,book2,book3&#125;;</span><br><span class="line">        list.Sort();</span><br><span class="line">        foreach (Book book in list) &#123;</span><br><span class="line">            Console.WriteLine(book.ID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book:IComparable&lt;Book&gt; &#123;</span><br><span class="line">    public int ID &#123; get; set; &#125;</span><br><span class="line">    public int CompareTo(Book? obj) &#123;</span><br><span class="line">        if (obj == null) return 1;</span><br><span class="line">        return this.ID - obj.ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList类</title>
      <link href="/2023/08/28/ArrayList%E7%B1%BB/"/>
      <url>/2023/08/28/ArrayList%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList类在System.Collections名称空间中，ArrayList存放的是object类型成员。<br>ArrayList的大小是按照其中存储的数据来动态扩充与收缩的。<br>ArrayList不是类型安全的，使用时可能会出现类型不匹配的错误。<br>就算都插入了同一类型的数据，在使用时也需要将它转成对应的袁类型来处理。<br>ArrayList的存储存在装箱、拆箱导致性能低下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        ArrayList arrayList = new ArrayList();</span><br><span class="line">        arrayList.Add(&quot;abc&quot;);</span><br><span class="line">        arrayList.Add(123);</span><br><span class="line">        arrayList[2] = 12.4;</span><br><span class="line">        arrayList.Remove(12.4);</span><br><span class="line">        arrayList.RemoveAt(1);</span><br><span class="line">        arrayList.Insert(0, &quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/08/28/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/08/28/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>C#不支持动态数组，如果想实现类似JS数组的效果，可以参考ArralList或者List。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>矩形数组：<br>某个维度的所有子数组具有相同长度的多维数组。<br>不管有多少维度，总是使用一组方括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mayArray[4,6,1];//一组方括号</span><br></pre></td></tr></table></figure><p>交错数组：<br>每一个子数组都是独立数组的多维数组。<br>可以有不同长度的子数组。<br>为数组的每一个维度使用一对方括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jagArray[2][7][4];</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%95%B0%E7%BB%84/1.jpg"></p><h2 id="声明一维数组与矩形数组"><a href="#声明一维数组与矩形数组" class="headerlink" title="声明一维数组与矩形数组"></a>声明一维数组与矩形数组</h2><p>一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr;</span><br></pre></td></tr></table></figure><p>矩形数组：<br>可以使用多个秩说明符。<br>不能在数组类型区域中放数组维度长度。秩是数组类型的一部分，而维度长度不是类型的一部分。<br>数组声明后维度数就是固定的了，然而数组长度直到数组实例化时才会确定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[,,] arr1;</span><br><span class="line">int[,] arr2;</span><br><span class="line">int[3,2,6] arr3;//编译错误</span><br></pre></td></tr></table></figure><h2 id="实例化一维数组与矩形数组"><a href="#实例化一维数组与矩形数组" class="headerlink" title="实例化一维数组与矩形数组"></a>实例化一维数组与矩形数组</h2><p>一维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = new int[4];</span><br><span class="line">int[] arr2 = new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">int[] arr3 = &#123;1,2,3,4&#125;;</span><br><span class="line">var intArr1 = new []&#123;1,2,3,4&#125;;//隐式数组，类型由编译器推断</span><br></pre></td></tr></table></figure><p>矩形数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[,,] arr4 = new int[3,6,2];</span><br><span class="line">int[,] arr5 = new int[,]&#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;</span><br><span class="line">int[,] arr6 = &#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;</span><br><span class="line">var intArr2 = new [,]&#123;&#123;10,1&#125;,&#123;2,10&#125;,&#123;11,9&#125;&#125;;//隐式数组，类型由编译器推断</span><br></pre></td></tr></table></figure><p>当数组被创建之后，每一个元素被自动初始化为类型的默认值</p><h2 id="声明交错数组"><a href="#声明交错数组" class="headerlink" title="声明交错数组"></a>声明交错数组</h2><p>方括号的数量决定了数组的秩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[][] SomeArr;</span><br><span class="line">int[][][] OtherArr;</span><br></pre></td></tr></table></figure><h2 id="实例化交错数组"><a href="#实例化交错数组" class="headerlink" title="实例化交错数组"></a>实例化交错数组</h2><p>不能在声明语句中初始化顶层数组之外的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] jagArr = new int[3][];</span><br></pre></td></tr></table></figure><h2 id="初始化交错数组"><a href="#初始化交错数组" class="headerlink" title="初始化交错数组"></a>初始化交错数组</h2><p>交错数组的初始化不能在一个步骤中完成，每一个数组必须独立创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[3][];</span><br><span class="line">arr[0] = new int[]&#123;1,2,3&#125;;</span><br><span class="line">arr[1] = new int[]&#123;4,5,6&#125;;</span><br><span class="line">arr[2] = new int[]&#123;7,8,9&#125;;</span><br></pre></td></tr></table></figure><h2 id="交错数组的子数组"><a href="#交错数组的子数组" class="headerlink" title="交错数组的子数组"></a>交错数组的子数组</h2><p>交错数组的子数组本事就是数组，因此子数组可能有矩形数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[][,]Arr;</span><br><span class="line">Arr = new int[3][,];</span><br><span class="line">Arr[0] = new int[]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;</span><br><span class="line">Arr[1] = new int[]&#123;&#123;5,6&#125;,&#123;7,8&#125;&#125;;</span><br><span class="line">Arr[2] = new int[]&#123;&#123;9,10&#125;,&#123;11,12&#125;&#125;;</span><br></pre></td></tr></table></figure><p>System.Array的GetLength(int n)方法可以获取数组中指定维度的长度。</p><h2 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h2><p>foreach语句会遍历实现IEnumerable接口的迭代对象，foreach遍历是只读的，不能在foreach中对迭代对象做修改。<br>想要遍历交错数组需要对交错数组中每一个维度使用独立的foreach语句。foreach语句必须嵌套以确保每一个嵌套数组都被正确处理。</p><h2 id="数组协变"><a href="#数组协变" class="headerlink" title="数组协变"></a>数组协变</h2><p>在某些情况下，即使某个对象不是数组的基类型，也可以把它赋值给数组元素这种属性称为协变，以下情况可以使用数组协变：<br>数组是引用类型数组。<br>在赋值的对象类型和数组基类型之间有隐式转换或显式转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        A[] AArr1 = new A[3];</span><br><span class="line">        A[] AArr2 = new A[3];</span><br><span class="line">        //普通</span><br><span class="line">        AArr1[0] = new A(); AArr1[1] = new A(); AArr1[2] = new A();</span><br><span class="line">        //协变</span><br><span class="line">        AArr2[0] = new (); AArr2[1] = new B(); AArr2[2] = new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123; &#125;</span><br><span class="line">class B:A &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="有用的数组成员"><a href="#有用的数组成员" class="headerlink" title="有用的数组成员"></a>有用的数组成员</h2><p>Rank属性实例获取数组维度数<br>Length属性实例获取所有维度的元素总数<br>GetLength 方法实例返回数组的指定维度的长度<br>Clear方法静态将某一范围内的元素设置为0或null<br>Sort 方法静态在一维数组中对元素进行排序<br>BinarySerach方法静态使用二分查找搜索一维数组中的值<br>Clone方法实例进行数组的浅复制——对于值类型数组复制元素对于引用类型则产生指向相同元素的两个数组<br>IndexOf方法静态返回一维数组中遇到的第一个值<br>Reverse方法静态反转一维数组中某一范围内的元素<br>GetUpperBound方法实例获取指定维度的上限</p><h2 id="Clone方法"><a href="#Clone方法" class="headerlink" title="Clone方法"></a>Clone方法</h2><p>对于值类型克隆产生两个数组<br>对于引用类型产生指向相同对象的两个数组<br>克隆方法返回object类型的引用，它必须被强制转换成数组类型！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int[] intArr1 = &#123; 1, 2, 3, &#125;;</span><br><span class="line">        var intArr2 = (int[])intArr1.Clone();</span><br><span class="line">        A[] AArr1 = &#123; new A(),new A(),new A() &#125;;</span><br><span class="line">        var AArr2 = (A[]) AArr1.Clone();</span><br><span class="line">        AArr2[0].val = 12;</span><br><span class="line">        Console.WriteLine(AArr1[0].val);//12</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">    public int val = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 数组 </tag>
            
            <tag> 矩形数组 </tag>
            
            <tag> 交错数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/08/28/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/08/28/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举的简单使用"><a href="#枚举的简单使用" class="headerlink" title="枚举的简单使用"></a>枚举的简单使用</h2><p>枚举是值类型，枚举只有一种类型成员——命名的整数值常量。<br>默认情况下第一个成员为0，每一个后继成员赋的值都比前一个成员多1。<br>枚举成员是静态的，他们和枚举有着相同的可访问性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum TrafficLight&#123;</span><br><span class="line">Green,Yellow,Red</span><br><span class="line">&#125;</span><br><span class="line">TrafficLight t = TrafficLight.Green;</span><br><span class="line">Console.WriteLine($&quot; &#123;t&#125; , &#123; (int)t &#125; &quot;);//Green,0</span><br></pre></td></tr></table></figure><p>注意枚举成员的ToString()方法返回的是成员名，强制转换才能看到枚举值。</p><h2 id="枚举底层类型与显示值"><a href="#枚举底层类型与显示值" class="headerlink" title="枚举底层类型与显示值"></a>枚举底层类型与显示值</h2><p>可以设置底层类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum TrraggicLight : ulong &#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以显式指定成员的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum TrafficLight&#123;</span><br><span class="line">Green,Yellow=12,Red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位标志"><a href="#位标志" class="headerlink" title="位标志"></a>位标志</h2><p>程序员经常使用单个字的不同位作为一组开&#x2F;关标志的紧凑方法，枚举为这样的使用提供了便利。<br>使用Flags特性装饰枚举实际上是不必要的，但可以带来一些额外的遍历。<br>要判断标志字是否包含特定的位标志集，可以使用枚举类型的HasFlag布尔方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        CardDeckSetting ops = CardDeckSetting.SingleDeck | CardDeckSetting.FancyNumber | CardDeckSetting.Animation;</span><br><span class="line">        bool useFancyNumbers = ops.HasFlag(CardDeckSetting.FancyNumber);</span><br><span class="line">        if(useFancyNumbers) &#123;</span><br><span class="line">            Console.WriteLine(&quot;ok&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[Flags]</span><br><span class="line">enum CardDeckSetting : uint &#123;</span><br><span class="line">    SingleDeck = 0x01,</span><br><span class="line">    LargePictures = 0x02,</span><br><span class="line">    FancyNumber = 0x04,</span><br><span class="line">    Animation = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flags特性"><a href="#Flags特性" class="headerlink" title="Flags特性"></a>Flags特性</h2><p>它通知编译器、对象浏览器以及其他查看这段代码的工具，该枚举的成员不仅可以用作单独的值，还可以组合成位标志，这样浏览器就可以更恰当地解释该枚举类型的变量了。<br>其次，它允许枚举的ToString方法为位标志的值提供更多格式化信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        CardDeckSetting ops = CardDeckSetting.SingleDeck | CardDeckSetting.FancyNumber | CardDeckSetting.Animation;</span><br><span class="line">        bool useFancyNumbers = ops.HasFlag(CardDeckSetting.FancyNumber);</span><br><span class="line">        //有Flags特性：SingleDeck, FancyNumber, Animation</span><br><span class="line">        //没有Flages特性：13</span><br><span class="line">        Console.WriteLine(ops);</span><br><span class="line">    &#125;                                           </span><br><span class="line">&#125;</span><br><span class="line">[Flags]</span><br><span class="line">enum CardDeckSetting : uint &#123;</span><br><span class="line">    SingleDeck = 0x01,</span><br><span class="line">    LargePictures = 0x02,</span><br><span class="line">    FancyNumber = 0x04,</span><br><span class="line">    Animation = 0x08</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum类型的一些静态方法"><a href="#Enum类型的一些静态方法" class="headerlink" title="Enum类型的一些静态方法"></a>Enum类型的一些静态方法</h2><p>Enum.GetName：<br>参数：枚举类型对象，整数<br>返回：对应成员的名称<br>Enum.GetNames：<br>参数：枚举类型对象<br>返回：所有成员的名称且实现IEnumerable接口</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 枚举 </tag>
            
            <tag> Flags特性 </tag>
            
            <tag> 位标志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/08/28/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="结构体的声明和使用"><a href="#结构体的声明和使用" class="headerlink" title="结构体的声明和使用"></a>结构体的声明和使用</h2><p>结构体是值类型，无法派生其他结构。<br>结构体变量不能为null，两个结构体变量不能引用同一对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Simple&#123;</span><br><span class="line">public int a;</span><br><span class="line">public int b;</span><br><span class="line">&#125;</span><br><span class="line">Simple simple = new Simple();</span><br></pre></td></tr></table></figure><p>把一个结构体赋值给另一个结构体，就是将一个结构体的值复制给你另一个结构体。<br>结构体可以有实例构造函数和静态构造函数，但不允许有析构函数。<br>结构体隐式含有一个无参构造函数，不可删除或重定义，结构体的值成员设置为默认值，引用成员设置为null。<br>对于类，编译器只在没有声明其他构造函数时提供隐式的无参构造函数。<br>可以不使用new来创建结构体实例，但这样做只有显式设置数据成员后才能使用它们的值并且在对所有数据成员赋值后，才能调用结构的函数成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple s1,s2;</span><br><span class="line">s1.a=3;</span><br><span class="line">s1.b=4;</span><br><span class="line">Console.WriteLine(s1.a);</span><br></pre></td></tr></table></figure><p>注意：声明结构体时不允许使用实例属性和字段初始化语句，但是静态属性和字段可以在声明时初始化即使结构体本身不是静态的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Simple&#123;</span><br><span class="line">public int a = 3;//报错</span><br><span class="line">public static int b = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构本身派生自System.ValueType，当创建一个和基类成员同名的成员时可以使用new或override修饰符。</p><h2 id="结构作为返回值和参数"><a href="#结构作为返回值和参数" class="headerlink" title="结构作为返回值和参数"></a>结构作为返回值和参数</h2><p>返回值：<br>当结构作为返回值时将创建副本从函数成员返回。<br>值参数：<br>创建副本传入函数。<br>ref和out：<br>传入结构的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结构代替类有时可以提高性能，但同时也要注意装箱拆箱的成本。<br>可以使用分部结构就像分部类一样。<br>结构可以实现接口。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式、运算符、语句、转换</title>
      <link href="/2023/08/28/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/08/28/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>基本的表达式、运算符、语句、转换在这就不过多介绍，有几个比较少见的就在这多提一嘴吧。</p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量@"></a>字符串字面量@</h2><p>逐字字符串字面量以@字符为前缀，而且该字符串中的转义序列不会被求值。<br>逐字字符串字面量的唯一例外是相邻的双引号组会被解释成单个双引号字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string vst1 = @&quot;Hello world&quot;&quot;&quot;;</span><br><span class="line">string vst2 = @&quot;H\tell\no\tworld&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><h2 id="委托的比较"><a href="#委托的比较" class="headerlink" title="委托的比较"></a>委托的比较</h2><p>如果两个委托都是null，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，那么比较返回true。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载不能创建新的运算符，不能改变运算符的语法，不能重新定义运算符如何处理预定义类型，不能改变运算符的优先级或结合性。<br>注意：对于引用类型的对象，前置操作没有问题，因为没有进行复制。但是对于后置操作，因为保存的副本是引用的副本，所以这意味着原始引用和引用副本指向相同的对象。</p><p>声明时必须使用public static。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        LimitedInt limitedInt = new LimitedInt();</span><br><span class="line">        Console.WriteLine((limitedInt + 8).TheValue);</span><br><span class="line">        Console.WriteLine((-limitedInt).TheValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int TheValue = 20;</span><br><span class="line">    public static LimitedInt operator +(LimitedInt x,double y) &#123;</span><br><span class="line">        LimitedInt li =new LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue + (int)y;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">    public static LimitedInt operator -(LimitedInt x) &#123;</span><br><span class="line">        LimitedInt li = new LimitedInt();</span><br><span class="line">        li.TheValue = 0;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只可以为类和结构定义用户自定义转换，不能重定义标准隐式或显式转换。</p><p>源类型和目标类型必须是不同类型，且不能通过继承关联。</p><p>源类型和目标类型不能是接口类型或object类型。</p><p>转换运算符必须是源类型或目标类型的成员。</p><p>对于相同的源类型和目标类型不能声明隐式和显式转换。</p><h2 id="using语句"><a href="#using语句" class="headerlink" title="using语句"></a>using语句</h2><p>某些类型的非托管对象有数量限制或很耗费系统资源，需要使用完尽快释放，using语言有助于简化该过程并确保这些资源被适当处理。<br>资源是指实现了System.IDisposable接口的类或结构，IDisposable接口含有单独一个名为Dispose的方法。<br>使用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using(TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))&#123;</span><br><span class="line">    tw.WriteLine(&quot;Four score and seven years age...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用于相同的多个类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using(TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;),</span><br><span class="line">      TextWriter tw = File.CreateText(&quot;Lincoln.txt&quot;))&#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>typeof运算符返回作为其参数的任何类型的System.Type对象，可以理解成该实例对应类型的说明，Type类型是反射和依赖注入的基础，之后我会详细介绍。</p><h2 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h2><p>有些转换是不成功的，并且在运行时抛出InvalidCastException异常。可以用is运算符检查转换是否成功完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expr is TargetType</span><br></pre></td></tr></table></figure><p>返回布尔值，如果Expr可以通过引用转换、装箱、拆箱成功转换为目标值，则运算符返回true。</p><p>is运算符只可以用于引用转换以及装箱拆箱，不能用于用户自定义转换。</p><h2 id="as运算符"><a href="#as运算符" class="headerlink" title="as运算符"></a>as运算符</h2><p>as运算符和强制转换相似，只是它不抛出异常，如果转换失败，它返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exper as TargetType</span><br></pre></td></tr></table></figure><p>as运算符只可以用于引用转换以及装箱拆箱，不能用于用户自定义转换。</p><h2 id="checked-unchecked语句和checked-unchecked运算符"><a href="#checked-unchecked语句和checked-unchecked运算符" class="headerlink" title="checked&#x2F;unchecked语句和checked&#x2F;unchecked运算符"></a>checked&#x2F;unchecked语句和checked&#x2F;unchecked运算符</h2><p>check语句用来检查转换结果是否溢出，如果我们指定一个表达式或一个代码片段为checked，当转换产生溢出时会抛出OverflowException异常。</p><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checked((int)3.14);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checked&#123;</span><br><span class="line">int a = 12.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户定义类型转换"><a href="#用户定义类型转换" class="headerlink" title="用户定义类型转换"></a>用户定义类型转换</h2><p>public和static是用户定义类型转换所必须的。<br>隐式转换（implicit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public static implicit operator int (LimitedInt li) &#123;//隐式转换LimitedInt——&gt;int</span><br><span class="line">        return li.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static implicit operator LimitedInt (int val) &#123;//隐式转换int——&gt;LimitedInt</span><br><span class="line">        LimitedInt li = new LimitedInt ();</span><br><span class="line">        li.value = val;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式转换（explicit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LimitedInt &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public static explicit operator int (LimitedInt li) &#123;//显式转换LimitedInt——&gt;int</span><br><span class="line">        return li.value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static explicit operator LimitedInt (int val) &#123;//显式转换int——&gt;LimitedInt</span><br><span class="line">        LimitedInt li = new LimitedInt ();</span><br><span class="line">        li.value = val;</span><br><span class="line">        return li;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 字符串字面量 </tag>
            
            <tag> using语句 </tag>
            
            <tag> is </tag>
            
            <tag> as </tag>
            
            <tag> checked </tag>
            
            <tag> 自定义类型转换 </tag>
            
            <tag> 运算符重载 </tag>
            
            <tag> typeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2023/08/28/%E5%A4%9A%E6%80%81/"/>
      <url>/2023/08/28/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>原本打算抽象类和接口一起讲的，但是抽象类也属于多态的章节，而多态又是C#中很重要的部分，所以我觉得还是抽象类和多态一起讲吧。</p><h2 id="虚方法与覆写方法（virtual）"><a href="#虚方法与覆写方法（virtual）" class="headerlink" title="虚方法与覆写方法（virtual）"></a>虚方法与覆写方法（virtual）</h2><p>虚方法可以使基类的引用访问升至派生类内。<br>基类的方法用virtual标注。<br>派生类的方法用override标注。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Human human = new Man();</span><br><span class="line">        human.Eat();//我可以吃方便面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    virtual public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man : Human &#123;</span><br><span class="line">   override public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以吃方便面&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆写和被覆写的方法必须有相同的可访问性。<br>不能复写static方法和非虚方法。<br>方法、属性、索引器、事件都可以声明virtual和override。<br>方法的调用被沿着派生层次上溯之中，一直到标记为override的方法的最高派生版本。</p><h2 id="抽象（abstract）"><a href="#抽象（abstract）" class="headerlink" title="抽象（abstract）"></a>抽象（abstract）</h2><p>抽象成员指的是必须被覆写的函数成员用abstract，与虚拟成员不同，虚拟成员是可以被覆写抽象成员则是必须被复写，两者都只能覆写函数成员且虚拟成员和抽象成员都不能是私有的。<br>有了abstract就不能写virtual了。<br>含有抽象成员的类被称为抽象类，抽象类只能被用作其他类的基类不能创建实例，被abstract修饰。<br>派生类中的抽象成员必须指定override修饰符，除非这个派生类也是抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract protected void Use();</span><br><span class="line">&#125;</span><br><span class="line">class Human : Animal &#123;</span><br><span class="line">    override protected void Use() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以生火和制造工具&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类常用来解耦，抽象类的进一步抽象便是接口。</p><h2 id="密封类（sealed）"><a href="#密封类（sealed）" class="headerlink" title="密封类（sealed）"></a>密封类（sealed）</h2><p>密封类不能用作基类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sealed class Human&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类（static）"><a href="#静态类（static）" class="headerlink" title="静态类（static）"></a>静态类（static）</h2><p>静态类中所有成员都是静态的。<br>可以有一个静态构造函数但是不能有实例构造函数，因为静态类不能创建实例。<br>不能继承静态类。<br>常用的静态类比如Math类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Math.Max(12,99));</span><br><span class="line">Console.WriteLine(Math.Round(12.567));</span><br></pre></td></tr></table></figure><p>静态类常用来做扩展方法：<br>扩展方法是Linq中常用的方法，用来给类增加静态方法和实例方法，以下是int类型的扩展方法演示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int a = 3;</span><br><span class="line">        if (a.Max(4)||) &#123;</span><br><span class="line">            Console.WriteLine(&quot;a更大&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            Console.WriteLine(&quot;a更小&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static class ExtendInt &#123;</span><br><span class="line">    public static bool Max(this int a,int b) &#123;</span><br><span class="line">        return a &gt; b ? true : false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须包裹在一个静态类中，拓展方法必须是静态的，拓展方法必须包含关键字this作为它的第一个参数类型，并在后面跟着它拓展的类的名称。<br>扩展方法同时扩展了静态方法和实例方法，如果想静态调用，则第一个参数应为拓展类型的实例。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> virtual </tag>
            
            <tag> abstract </tag>
            
            <tag> sealed </tag>
            
            <tag> static </tag>
            
            <tag> 多态 </tag>
            
            <tag> 扩展方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的继承</title>
      <link href="/2023/08/28/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2023/08/28/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="屏蔽基类的成员"><a href="#屏蔽基类的成员" class="headerlink" title="屏蔽基类的成员"></a>屏蔽基类的成员</h2><p>派生类不能删除它继承的成员但是可以用与基类成员名称相同的成员来屏蔽基类成员。<br>要让编译器知道你是故意屏蔽，可使用new操作符。<br>也可以屏蔽静态成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    public string name = &quot;爸爸&quot;;</span><br><span class="line">    public void MakeMoney() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我可以赚钱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son : Father &#123;</span><br><span class="line">    new public string name = &quot;儿子&quot;;</span><br><span class="line">    new public void MakeMoney() &#123;</span><br><span class="line">        Console.WriteLine(&quot;我也可以赚钱&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基类访问"><a href="#基类访问" class="headerlink" title="基类访问"></a>基类访问</h2><p>如果需要访问被隐藏的继承成员，可使用基类访问表达式：base.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(base.name);</span><br></pre></td></tr></table></figure><h2 id="基类引用"><a href="#基类引用" class="headerlink" title="基类引用"></a>基类引用</h2><p>可以声明基类变量引用子类实例，但是产生的变量仅能访问到基类身上的成员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father father = new Son();</span><br></pre></td></tr></table></figure><h2 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h2><p>初始化实例成员——&gt;调用基类构造函数——&gt;执行实例构造函数方法体。<br>注意：强烈反对在构造函数中调用虚方法。在执行基类的构造函数时，基类的虚方法会调用派生类的复写方法，但这是在执行派生类的构造函数方法体之前。因此，调用会在派生类完全初始化之前传递到派生类。</p><h2 id="初始化构造函数"><a href="#初始化构造函数" class="headerlink" title="初始化构造函数"></a>初始化构造函数</h2><p>可以指定用某个基类的构造函数来初始化子类的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Man man1 = new Man();</span><br><span class="line">        Console.WriteLine(man1.Height);</span><br><span class="line">        Man man2 = new Man(180);</span><br><span class="line">        Console.WriteLine(man2.Height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    public int Height;</span><br><span class="line">    public Human(int height) &#123;</span><br><span class="line">        this.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public Human() &#123;</span><br><span class="line">        this.Height = 165;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man : Human &#123;</span><br><span class="line">    public Man() :base() &#123;&#125;</span><br><span class="line">    public Man(int height) : base(height) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以让构造过程使用当前类中其他的构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Human human = new Human(75,180);</span><br><span class="line">        Console.WriteLine($&quot;身高&#123;human.Height&#125;，体重&#123;human.Weight&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">    public int Height;</span><br><span class="line">    public int Weight;</span><br><span class="line">    private Human(int height) &#123;</span><br><span class="line">        this.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public Human(int weight,int height) :this(height)&#123;</span><br><span class="line">        this.Weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有好几个构造函数，并且它们都需要在对象构造的过程开始时执行公共的代码，可以把公共代码抽取出来作为一个构造函数。<br>readonly字段只能在构造函数中初始化，但是readonly属性不受这个限制。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 屏蔽 </tag>
            
            <tag> 基类访问 </tag>
            
            <tag> 基类引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的参数</title>
      <link href="/2023/08/28/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2023/08/28/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引用参数（ref）"><a href="#引用参数（ref）" class="headerlink" title="引用参数（ref）"></a>引用参数（ref）</h2><p>当参数类型为引用参数时，实参必须是变量，在用作实参前必须被赋值！如果是引用类型变量，可以赋值为一个引用或null。<br>函数声明和调用时都需要在ref参数前加上”ref”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void RefTest(ref int a)&#123; ... &#125;</span><br><span class="line">int a = 3;</span><br><span class="line">RefTest(ref a);</span><br><span class="line">RefTest(3);//报错，必须为变量</span><br></pre></td></tr></table></figure><p>对于值参数，系统会在栈上为形参分配内存，而引用参数不会在栈上分配内存，形参的参数名将作为实参变量的别名指向相同的内存位置。<br>将引用类型对象作为值参数传递时：如果在方法内创建一个新对象并赋值给形参，在方法调用结束后，将切断形参和实参的关联，新对象也不复存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        //调用前</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.age = 20;</span><br><span class="line">        Console.WriteLine(&quot;执行前&quot;+std.age);</span><br><span class="line">        MakeStd(std);</span><br><span class="line">        Console.WriteLine(&quot;执行后&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeStd(Student std) &#123;</span><br><span class="line">std.age = 50;</span><br><span class="line">        Student std2 = new Student();</span><br><span class="line">        std2.age = 20;</span><br><span class="line">        std = std2;</span><br><span class="line">        Console.WriteLine(&quot;执行中：&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/1.jpg" alt="值参数"><br>将引用类型的对象作为引用参数传递时：如果在方法内创建一个新对象并赋值给形参，在方法调用结束后，该对象依然存在，并且是实参所引用的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        //调用前</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.age = 20;</span><br><span class="line">        Console.WriteLine(&quot;执行前&quot;+std.age);</span><br><span class="line">        MakeStd(ref std);</span><br><span class="line">        Console.WriteLine(&quot;执行后&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MakeStd(ref Student std) &#123;</span><br><span class="line">std.age = 50;</span><br><span class="line">        Student std2 = new Student();</span><br><span class="line">        std2.age = 20;</span><br><span class="line">        std = std2;</span><br><span class="line">        Console.WriteLine(&quot;执行中：&quot;+std.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/2.jpg" alt="应用参数"></p><h2 id="输出参数（out）"><a href="#输出参数（out）" class="headerlink" title="输出参数（out）"></a>输出参数（out）</h2><p>函数声明和调用时都需要在out参数前加上”out”。<br>实参必须是变量。<br>在方法内部，给输出参数赋值之后才能读取它。<br>方法返回之前，每条可能的路径都必须为输出参数赋值。<br>不可能使用输出参数把数据传入方法。<br>形参的名称被设置为实参的别名，可以认为形参实参指向相同内存位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        MyClass a1 = null;</span><br><span class="line">        int a2;</span><br><span class="line">        MyMethod(out a1, out a2);</span><br><span class="line">        Console.WriteLine(a1.val);</span><br><span class="line">        Console.WriteLine(a2);</span><br><span class="line">    &#125;</span><br><span class="line">    static void MyMethod(out MyClass f1 , out int f2) &#123;</span><br><span class="line">        f1 = new MyClass();</span><br><span class="line">        f1.val = 25;</span><br><span class="line">        f2 = 15;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    public int val = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main()&#123;</span><br><span class="line">MyMethod(out MyClass a1 , out int a2);</span><br><span class="line">Cosole.WriteLine(a2);</span><br><span class="line">Cosole.WriteLine(a1.val);</span><br><span class="line">a2++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/3.jpg" alt="out"></p><h2 id="参数数组（params）"><a href="#参数数组（params）" class="headerlink" title="参数数组（params）"></a>参数数组（params）</h2><p>一个参数列表中只能有一个参数数组，并且它必须是列表最后一个。<br>参数数组表示的所有参数必须是同一类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        ParamsTest(9, 8, 7, 6, 5, 4, 3, 2, 1);</span><br><span class="line">        int[] ints = &#123;7,6,5,4,3,2,1&#125;;</span><br><span class="line">        ParamsTest(9,8,ints);</span><br><span class="line">    &#125;</span><br><span class="line">    static void ParamsTest(int a, int b ,params int[] vals) &#123;</span><br><span class="line">        foreach(int i in vals) &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref局部变量与ref返回"><a href="#ref局部变量与ref返回" class="headerlink" title="ref局部变量与ref返回"></a>ref局部变量与ref返回</h2><p>ref局部变量：<br>相当于一个变量的别名，即使引用的对象是值类型。<br>对任意一个变量的赋值都会反映到另一个变量上。<br>ref变量声明时必须初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">reg int y = ref x;</span><br></pre></td></tr></table></figure><p>ref返回：<br>ref返回提供了一种使方法返回变量引用而不是变量值的方法。<br>函数声明返回值类型前有ref。<br>函数内部return后有ref。<br>函数调用时函数名前有ref。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int a = 3, b = 4;</span><br><span class="line">        ref int max = ref Max(ref a, ref b);</span><br><span class="line">        Console.WriteLine(++max);</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">        Console.WriteLine(b);</span><br><span class="line">    &#125;</span><br><span class="line">    static ref int Max(ref int a, ref int b) &#123;</span><br><span class="line">        if (a &gt; b)  return ref a; </span><br><span class="line">        else return ref b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>只要显式指定参数的名字，就可以以任意顺序在方法中列出实参。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">    int val;</span><br><span class="line">        val = Calc(c: 4, a: 1, b: 8);</span><br><span class="line">        Console.WriteLine(val);</span><br><span class="line">    &#125;</span><br><span class="line">    static int Calc(int a, int b,int c) &#123;</span><br><span class="line">        return (a+b) * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数（参数默认值）"><a href="#可选参数（参数默认值）" class="headerlink" title="可选参数（参数默认值）"></a>可选参数（参数默认值）</h2><p>不是所有参数类型都可以作为可选参数：<br>只要值类型的默认值在编译的时候可以确定，就可以使用值类型作为可选参数。<br>只有在默认值为null的时候，引用类型才可以用作可选参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        int val;</span><br><span class="line">        val = Calc(1,2);</span><br><span class="line">        Console.WriteLine(val);</span><br><span class="line">    &#125;</span><br><span class="line">    static int Calc(int a, int b , int c = 4) &#123;</span><br><span class="line">        return (a+b) * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 参数 </tag>
            
            <tag> ref </tag>
            
            <tag> out </tag>
            
            <tag> params </tag>
            
            <tag> ref返回 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数重载</title>
      <link href="/2023/08/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/08/28/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>当我们调用Console.WriteLine()函数时，我们有时候向这个函数传入整型数字，有时传入浮点数字，有时传入字符串。<br>为什么Console.WirteLine()函数可以接受不同的参数呢？<br>因为在C#语言中有着名为函数重载的功能。</p><h2 id="函数的签名"><a href="#函数的签名" class="headerlink" title="函数的签名"></a>函数的签名</h2><p>函数的签名包括：函数名，函数参数的种类、个数和顺序，还有它所在的类和名称空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">public void study(string name,int school)&#123;</span><br><span class="line">Console.WriteLine($&quot;我叫&#123;name&#125;，我在&#123;school&#125;读计算机专业。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！！！！！！方法的返回值不属于函数签名的一部分！！！！！！</p><h2 id="实现函数重载"><a href="#实现函数重载" class="headerlink" title="实现函数重载"></a>实现函数重载</h2><p>当函数的签名不同时，就可以实现函数的重载，我们可以声明多个同名函数保证他们的参数列表不同，在调用时传入想要执行的那个函数的参数，就可以做到实现不同的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public void study(string name, string school) &#123;</span><br><span class="line">        Console.WriteLine($&quot;我叫&#123;name&#125;，我在&#123;school&#125;读计算机专业。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void study(string name ,int age,string school) &#123;</span><br><span class="line">        Console.WriteLine($&quot;我叫&#123;name&#125;，我今年&#123;age&#125;岁了，我在&#123;school&#125;读幼儿园&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的构造函数也是函数，所以依然可以使用构造函数重载，实现对类成员不同方式的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解类</title>
      <link href="/2023/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB/"/>
      <url>/2023/08/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类与类成员"><a href="#类与类成员" class="headerlink" title="类与类成员"></a>类与类成员</h1><p>C#类访问限制：</p><p>public class可以被任意程序集所见、internal class仅能被自身程序集所见、static class常用来封装静态属性方法和扩展方法。</p><p>C#类的成员分为：</p><p>静态成员：字段、常量。</p><p>函数成员：属性、方法、索引器、事件、运算符、构造函数、析构函数。</p><p>C#成员访问限制：</p><p>public、static（静态）、private（仅限当前类内）、internal（仅限当前程序集）、protected（仅限当前类与该类的子类）</p><p>非静态成员就是函数成员。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>只用成员既有get又有set时才允许使用访问修饰符。<br>虽然两个访问器都必须出现但他们中只能有一个有访问修饰符。<br>访问器的修饰符限制必须比成员访问级别更严格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.age = -10;</span><br><span class="line">        Console.WriteLine(student.age);// 1</span><br><span class="line">        student.age = 10;</span><br><span class="line">        Console.WriteLine(student.age);// 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    private int _age=1;</span><br><span class="line">    public int age &#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return _age;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if(value &gt; 0 &amp;&amp; value &lt; 150) &#123;</span><br><span class="line">                _age = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public string name &#123; get; private set; &#125;//自动实现属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student std = new Student();</span><br><span class="line">        std.Eat();//实例方法</span><br><span class="line">        Student.Study();//静态方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    public static void Study() &#123;</span><br><span class="line">        Console.WriteLine(&quot;I can study&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Eat() &#123;</span><br><span class="line">        Console.WriteLine(&quot;I can eat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数必须和类名相同，且不能有返回值（连void都没有）。静态构造函数用static声明，类只能有有一个静态构造函数且不能带参数，静态构造函数不能有访问修饰符。<br>静态构造函数不能访问所在类的实例成员，因此不能使用this访问器，不能显式调用静态构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public static string school&#123; get; set; &#125;</span><br><span class="line">    public Student(string name) &#123; //构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    static Student() &#123;//静态构造函数</span><br><span class="line">        school = &quot;清北大学&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象初始化语句"><a href="#对象初始化语句" class="headerlink" title="对象初始化语句"></a>对象初始化语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student std = new Student() &#123; name = &quot;张三&quot; &#125;;</span><br><span class="line">Student std - new Student &#123; name = &quot;张三&quot; &#125;;</span><br></pre></td></tr></table></figure><p>注意静态字段和属性不能通过该方式初始化。</p><h2 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h2><p>const修饰符用于字段声明时，const字段使用方式和静态字段一样，几遍没有实例依然可以使用。<br>如果是static字段，初始化必须在静态构造函数中完成。<br>const字段相当于C&#x2F;C++中的#define，它在内存中没有存储位置</p><h2 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h2><p>const只能在字段声明中初始化，const的行为总是静态的。readonly字段可以使实例字段，也可以是静态字段，它在内存中有存储位置。<br>readonly允许在不同环境或不同构造函数中设置不同的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    public const string School = &quot;山河大学&quot;;</span><br><span class="line">    public readonly string Principal;//未初始化</span><br><span class="line">    public string name &#123; get; set; &#125;</span><br><span class="line">    public int age &#123; get; set; &#125;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        this.Principal = &quot;刘校长&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.Principal = &quot;高校长&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会好奇为什么会有两个构造函数，别担心，我会在之后的章节中介绍的函数重载详细说明。</p><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>索引器可以帮助我们以自己想要的方式调用和读取类的成员，索引器不用分配内存在这点索引器和属性的原理一样，不过属性用来表示单个数据成员而索引器用来表示多个成员。<br>索引的是一组get和set访问器。<br>索引器的参数列表在方括号中间，至少声明一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Program &#123;</span><br><span class="line">    static void Main(string[] args) &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student[0] = &quot;学号:2002220115&quot;;</span><br><span class="line">        student[1] = &quot;姓名:张三&quot;;</span><br><span class="line">        Console.WriteLine(student[0]);</span><br><span class="line">        Console.WriteLine(student[3]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">    public string this[int i] &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            switch(i) &#123;</span><br><span class="line">                case 0:return id; </span><br><span class="line">                case 1:return name;</span><br><span class="line">                default: return &quot;请在0-1中选择索引&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            switch (i) &#123;</span><br><span class="line">                case 0: id = value;break;</span><br><span class="line">                case 1: name = value;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器重载"><a href="#索引器重载" class="headerlink" title="索引器重载"></a>索引器重载</h2><p>只要索引器的参数列表不同（返回值不同是不够的），类就可以有多个索引器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">public string this[int index]&#123;</span><br><span class="line">get&#123;...&#125;</span><br><span class="line">set&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">public string this[int index1 , int index2]&#123;</span><br><span class="line">get&#123;...&#125;</span><br><span class="line">set&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分部类与分部方法（partial-class）"><a href="#分部类与分部方法（partial-class）" class="headerlink" title="分部类与分部方法（partial class）"></a>分部类与分部方法（partial class）</h2><p>分部类：<br>类的声明可以分割成几个分部类的声明。<br>每个分部类的声明都含有一些类成员的声明。<br>类的分部类声明可以在同一文件中也可以在不同文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">&#125;</span><br><span class="line">partial class Student &#123;</span><br><span class="line">    public int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分部方法：<br>方法的不同部分可以声明在分部类的不同部分中。<br>声明的实现部分只是一个分号，在实现部分以语句块方式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partial class Student &#123;</span><br><span class="line">    public string id;</span><br><span class="line">    public string name;</span><br><span class="line">    public void study(int x);//定义分部方法</span><br><span class="line">&#125;</span><br><span class="line">partial class Student &#123;</span><br><span class="line">    public int age;</span><br><span class="line">    public void study(int x)&#123;//实现分部方法</span><br><span class="line">Console.WriteLine(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> C#.Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .Net </tag>
            
            <tag> 类 </tag>
            
            <tag> 属性 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 静态构造函数 </tag>
            
            <tag> 索引器 </tag>
            
            <tag> const </tag>
            
            <tag> readonly </tag>
            
            <tag> 分部类 </tag>
            
            <tag> 分部方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/02/27/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>从今天开始我就要开始写自己的博客了，我会在博客中记录并分享我在学习C#、前端开发、单片机、数据库或其他课程中遇到的问题和解决方案还有一些课堂笔记，如果有遇到同样问题或者想学习以上技术的小伙伴，希望我的博客可以帮助到你们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;%s&quot;,&quot;欢迎来到我的博客&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/%E6%99%BA%E5%95%86+1.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
